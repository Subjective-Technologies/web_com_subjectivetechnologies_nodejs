"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_GoldenThinkerAnimation_js",{

/***/ "./components/GoldenThinkerAnimation.js":
/*!**********************************************!*\
  !*** ./components/GoldenThinkerAnimation.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Scene */ \"./components/Scene.js\");\n/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! postprocessing */ \"./node_modules/postprocessing/build/index.js\");\n// components/GoldenThinkerAnimation.js\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst GoldenThinkerAnimation = ()=>{\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        //const image360Path = 'images/360/back.jpg'; // Update with the actual path\n        const image360Path = \"images/360/background_black_4096x2048_360.png\";\n        const objPath = \"3d/anim_goldenthinker.obj\"; // Update with the actual path\n        //const objPath = '3d/anim_menu.obj';\n        // Create a gold material\n        const goldMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n            color: 0xD4AF37,\n            metalness: 1.5,\n            roughness: 0.3,\n            reflectivity: 1\n        });\n        function createBloomMaterial(originalMaterial) {\n            let bloomStrength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.5, bloomRadius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2, bloomThreshold = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.8;\n            const bloomMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial({\n                uniforms: {\n                    baseTexture: {\n                        value: null\n                    },\n                    bloomTexture: {\n                        value: null\n                    }\n                },\n                vertexShader: \"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n        }\\n      \",\n                fragmentShader: \"\\n        uniform sampler2D baseTexture;\\n        uniform sampler2D bloomTexture;\\n        varying vec2 vUv;\\n        \\n        void main() {\\n          vec4 baseColor = texture2D(baseTexture, vUv);\\n          vec4 bloomColor = texture2D(bloomTexture, vUv);\\n          \\n          gl_FragColor = baseColor + bloomColor * \".concat(bloomStrength, \";\\n        }\\n      \")\n            });\n            bloomMaterial.uniforms.baseTexture.value = originalMaterial.map;\n            bloomMaterial.uniforms.bloomTexture.value = originalMaterial.map; // You can replace this with your own bloom texture if needed.\n            const bloomPass = new postprocessing__WEBPACK_IMPORTED_MODULE_4__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), bloomStrength, bloomRadius, bloomThreshold);\n            return new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(originalMaterial, bloomMaterial);\n        }\n        MyBloomGoldMaterial = createBloomMaterial(goldMaterial);\n        const myScene = new _Scene__WEBPACK_IMPORTED_MODULE_2__[\"default\"](image360Path, objPath, MyBloomGoldMaterial);\n        /* \n     myScene.addElement(objPath, {\n       material: goldMaterial,\n       position: { x: 0, y: -2, z: 0 },\n       rotation: { x: 0, y: 0, z: 0 },\n     }); */ return ()=>{\n        // Clean up when the component unmounts\n        //myScene.dispose();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"animation_container\"\n    }, void 0, false, {\n        fileName: \"/workspaces/www_subjectivetechnologies_com_nodejs/components/GoldenThinkerAnimation.js\",\n        lineNumber: 90,\n        columnNumber: 10\n    }, undefined);\n};\n_s(GoldenThinkerAnimation, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = GoldenThinkerAnimation;\n/* harmony default export */ __webpack_exports__[\"default\"] = (GoldenThinkerAnimation);\nvar _c;\n$RefreshReg$(_c, \"GoldenThinkerAnimation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0dvbGRlblRoaW5rZXJBbmltYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSx1Q0FBdUM7OztBQUNVO0FBQ2xCO0FBQzhDO0FBQ1Q7QUFDeEM7QUFDcUI7QUFHakQsTUFBTVEseUJBQXlCOztJQUM3QlAsZ0RBQVNBLENBQUM7UUFDVCw0RUFBNEU7UUFDNUUsTUFBTVEsZUFBZTtRQUNyQixNQUFNQyxVQUFVLDZCQUE2Qiw4QkFBOEI7UUFFMUUscUNBQXFDO1FBQ3JDLHlCQUF5QjtRQUN6QixNQUFNQyxlQUFlLElBQUlSLHVEQUEwQixDQUFDO1lBQ2xEVSxPQUFPO1lBQ1BDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxjQUFjO1FBQ2hCO1FBSUYsU0FBU0Msb0JBQW9CQyxnQkFBZ0I7Z0JBQUVDLGdCQUFBQSxpRUFBZ0IsS0FBS0MsY0FBQUEsaUVBQWMsS0FBS0MsaUJBQUFBLGlFQUFpQjtZQUN0RyxNQUFNQyxnQkFBZ0IsSUFBSW5CLGlEQUFvQixDQUFDO2dCQUM3Q3FCLFVBQVU7b0JBQ1JDLGFBQWE7d0JBQUVDLE9BQU87b0JBQUs7b0JBQzNCQyxjQUFjO3dCQUFFRCxPQUFPO29CQUFLO2dCQUM5QjtnQkFDQUUsY0FBZTtnQkFPZkMsZ0JBQWdCLG9VQVM0QyxPQUFkVixlQUFjO1lBRzlEO1lBRUFHLGNBQWNFLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDQyxLQUFLLEdBQUdSLGlCQUFpQlksR0FBRztZQUMvRFIsY0FBY0UsUUFBUSxDQUFDRyxZQUFZLENBQUNELEtBQUssR0FBR1IsaUJBQWlCWSxHQUFHLEVBQUUsOERBQThEO1lBRWhJLE1BQU1DLFlBQVksSUFBSXhCLDJEQUFlQSxDQUFDLElBQUlKLDBDQUFhLENBQUM4QixPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVcsR0FBR2hCLGVBQWVDLGFBQWFDO1lBRTVILE9BQU8sSUFBSWxCLHVDQUFVLENBQUNlLGtCQUFrQkk7UUFDMUM7UUFLRWUsc0JBQXNCcEIsb0JBQW9CTjtRQUUxQyxNQUFNMkIsVUFBVSxJQUFJaEMsOENBQUtBLENBQUNHLGNBQWFDLFNBQVMyQjtRQUlwRDs7Ozs7U0FLUyxHQVFMLE9BQU87UUFDTCx1Q0FBdUM7UUFDdkMsb0JBQW9CO1FBQ3RCO0lBQ0YsR0FBRyxFQUFFO0lBRUwscUJBQU8sOERBQUNFO1FBQUlDLElBQUc7Ozs7OztBQUNqQjtHQWpGTWhDO0tBQUFBO0FBa0ZOLCtEQUFlQSxzQkFBc0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Hb2xkZW5UaGlua2VyQW5pbWF0aW9uLmpzP2JkNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tcG9uZW50cy9Hb2xkZW5UaGlua2VyQW5pbWF0aW9uLmpzXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanMnO1xuaW1wb3J0IHsgT0JKTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvT0JKTG9hZGVyLmpzJztcbmltcG9ydCBTY2VuZSBmcm9tICcuL1NjZW5lJztcbmltcG9ydCB7IFVucmVhbEJsb29tUGFzcyB9IGZyb20gJ3Bvc3Rwcm9jZXNzaW5nJztcblxuXG5jb25zdCBHb2xkZW5UaGlua2VyQW5pbWF0aW9uID0gKCkgPT4ge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgLy9jb25zdCBpbWFnZTM2MFBhdGggPSAnaW1hZ2VzLzM2MC9iYWNrLmpwZyc7IC8vIFVwZGF0ZSB3aXRoIHRoZSBhY3R1YWwgcGF0aFxuICAgY29uc3QgaW1hZ2UzNjBQYXRoID0gJ2ltYWdlcy8zNjAvYmFja2dyb3VuZF9ibGFja180MDk2eDIwNDhfMzYwLnBuZydcbiAgIGNvbnN0IG9ialBhdGggPSAnM2QvYW5pbV9nb2xkZW50aGlua2VyLm9iaic7IC8vIFVwZGF0ZSB3aXRoIHRoZSBhY3R1YWwgcGF0aFxuICAgIFxuICAgIC8vY29uc3Qgb2JqUGF0aCA9ICczZC9hbmltX21lbnUub2JqJztcbiAgICAvLyBDcmVhdGUgYSBnb2xkIG1hdGVyaWFsXG4gICAgY29uc3QgZ29sZE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAweEQ0QUYzNywgLy8gR29sZCBjb2xvclxuICAgICAgbWV0YWxuZXNzOiAxLjUsIC8vIEZ1bGwgbWV0YWxuZXNzIG1ha2VzIGl0IGxvb2sgbW9yZSBsaWtlIGdvbGRcbiAgICAgIHJvdWdobmVzczogMC4zLCAvLyBBZGp1c3QgdG8gbWFrZSBpdCBzaGluaWVyIG9yIG1vcmUgbWF0dGVcbiAgICAgIHJlZmxlY3Rpdml0eTogMSwgLy8gRnVsbCByZWZsZWN0aXZpdHkgZm9yIGEgbWV0YWxsaWMgbG9va1xuICAgIH0pO1xuXG4gIFxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJsb29tTWF0ZXJpYWwob3JpZ2luYWxNYXRlcmlhbCwgYmxvb21TdHJlbmd0aCA9IDEuNSwgYmxvb21SYWRpdXMgPSAwLjIsIGJsb29tVGhyZXNob2xkID0gMC44KSB7XG4gICAgY29uc3QgYmxvb21NYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBiYXNlVGV4dHVyZTogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgICBibG9vbVRleHR1cmU6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIHZVdiA9IHV2O1xuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBiYXNlVGV4dHVyZTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgYmxvb21UZXh0dXJlO1xuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIHZlYzQgYmFzZUNvbG9yID0gdGV4dHVyZTJEKGJhc2VUZXh0dXJlLCB2VXYpO1xuICAgICAgICAgIHZlYzQgYmxvb21Db2xvciA9IHRleHR1cmUyRChibG9vbVRleHR1cmUsIHZVdik7XG4gICAgICAgICAgXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gYmFzZUNvbG9yICsgYmxvb21Db2xvciAqICR7Ymxvb21TdHJlbmd0aH07XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgfSk7XG5cbiAgICBibG9vbU1hdGVyaWFsLnVuaWZvcm1zLmJhc2VUZXh0dXJlLnZhbHVlID0gb3JpZ2luYWxNYXRlcmlhbC5tYXA7XG4gICAgYmxvb21NYXRlcmlhbC51bmlmb3Jtcy5ibG9vbVRleHR1cmUudmFsdWUgPSBvcmlnaW5hbE1hdGVyaWFsLm1hcDsgLy8gWW91IGNhbiByZXBsYWNlIHRoaXMgd2l0aCB5b3VyIG93biBibG9vbSB0ZXh0dXJlIGlmIG5lZWRlZC5cblxuICAgIGNvbnN0IGJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MobmV3IFRIUkVFLlZlY3RvcjIod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCksIGJsb29tU3RyZW5ndGgsIGJsb29tUmFkaXVzLCBibG9vbVRocmVzaG9sZCk7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2gob3JpZ2luYWxNYXRlcmlhbCwgYmxvb21NYXRlcmlhbCk7XG4gIH1cblxuXG5cblxuICAgIE15Qmxvb21Hb2xkTWF0ZXJpYWwgPSBjcmVhdGVCbG9vbU1hdGVyaWFsKGdvbGRNYXRlcmlhbClcblxuICAgIGNvbnN0IG15U2NlbmUgPSBuZXcgU2NlbmUoaW1hZ2UzNjBQYXRoLG9ialBhdGgsIE15Qmxvb21Hb2xkTWF0ZXJpYWwpO1xuICAgIFxuXG4gICBcbi8qIFxuICAgICBteVNjZW5lLmFkZEVsZW1lbnQob2JqUGF0aCwge1xuICAgICAgIG1hdGVyaWFsOiBnb2xkTWF0ZXJpYWwsXG4gICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogLTIsIHo6IDAgfSxcbiAgICAgICByb3RhdGlvbjogeyB4OiAwLCB5OiAwLCB6OiAwIH0sXG4gICAgIH0pOyAqL1xuXG5cblxuXG5cblxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIENsZWFuIHVwIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xuICAgICAgLy9teVNjZW5lLmRpc3Bvc2UoKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIDxkaXYgaWQ9XCJhbmltYXRpb25fY29udGFpbmVyXCI+PC9kaXY+O1xufTtcbmV4cG9ydCBkZWZhdWx0IEdvbGRlblRoaW5rZXJBbmltYXRpb247XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJUSFJFRSIsIk9yYml0Q29udHJvbHMiLCJPQkpMb2FkZXIiLCJTY2VuZSIsIlVucmVhbEJsb29tUGFzcyIsIkdvbGRlblRoaW5rZXJBbmltYXRpb24iLCJpbWFnZTM2MFBhdGgiLCJvYmpQYXRoIiwiZ29sZE1hdGVyaWFsIiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJjb2xvciIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInJlZmxlY3Rpdml0eSIsImNyZWF0ZUJsb29tTWF0ZXJpYWwiLCJvcmlnaW5hbE1hdGVyaWFsIiwiYmxvb21TdHJlbmd0aCIsImJsb29tUmFkaXVzIiwiYmxvb21UaHJlc2hvbGQiLCJibG9vbU1hdGVyaWFsIiwiU2hhZGVyTWF0ZXJpYWwiLCJ1bmlmb3JtcyIsImJhc2VUZXh0dXJlIiwidmFsdWUiLCJibG9vbVRleHR1cmUiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsIm1hcCIsImJsb29tUGFzcyIsIlZlY3RvcjIiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJNZXNoIiwiTXlCbG9vbUdvbGRNYXRlcmlhbCIsIm15U2NlbmUiLCJkaXYiLCJpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/GoldenThinkerAnimation.js\n"));

/***/ }),

/***/ "./node_modules/postprocessing/build/index.js":
/*!****************************************************!*\
  !*** ./node_modules/postprocessing/build/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdaptiveLuminanceMaterial: function() { return /* binding */ AdaptiveLuminanceMaterial; },\n/* harmony export */   AdaptiveLuminancePass: function() { return /* binding */ AdaptiveLuminancePass; },\n/* harmony export */   BlendFunction: function() { return /* binding */ BlendFunction; },\n/* harmony export */   BlendMode: function() { return /* binding */ BlendMode; },\n/* harmony export */   BloomEffect: function() { return /* binding */ BloomEffect; },\n/* harmony export */   BlurPass: function() { return /* binding */ KawaseBlurPass; },\n/* harmony export */   BokehEffect: function() { return /* binding */ BokehEffect; },\n/* harmony export */   BokehMaterial: function() { return /* binding */ BokehMaterial; },\n/* harmony export */   BoxBlurMaterial: function() { return /* binding */ BoxBlurMaterial; },\n/* harmony export */   BoxBlurPass: function() { return /* binding */ BoxBlurPass; },\n/* harmony export */   BrightnessContrastEffect: function() { return /* binding */ BrightnessContrastEffect; },\n/* harmony export */   ChromaticAberrationEffect: function() { return /* binding */ ChromaticAberrationEffect; },\n/* harmony export */   CircleOfConfusionMaterial: function() { return /* binding */ CircleOfConfusionMaterial; },\n/* harmony export */   ClearMaskPass: function() { return /* binding */ ClearMaskPass; },\n/* harmony export */   ClearPass: function() { return /* binding */ ClearPass; },\n/* harmony export */   ColorAverageEffect: function() { return /* binding */ ColorAverageEffect; },\n/* harmony export */   ColorChannel: function() { return /* binding */ ColorChannel; },\n/* harmony export */   ColorDepthEffect: function() { return /* binding */ ColorDepthEffect; },\n/* harmony export */   ColorEdgesMaterial: function() { return /* binding */ EdgeDetectionMaterial; },\n/* harmony export */   ConvolutionMaterial: function() { return /* binding */ KawaseBlurMaterial; },\n/* harmony export */   CopyMaterial: function() { return /* binding */ CopyMaterial; },\n/* harmony export */   CopyPass: function() { return /* binding */ CopyPass; },\n/* harmony export */   DepthComparisonMaterial: function() { return /* binding */ DepthComparisonMaterial; },\n/* harmony export */   DepthCopyMaterial: function() { return /* binding */ DepthCopyMaterial; },\n/* harmony export */   DepthCopyMode: function() { return /* binding */ DepthCopyMode; },\n/* harmony export */   DepthCopyPass: function() { return /* binding */ DepthCopyPass; },\n/* harmony export */   DepthDownsamplingMaterial: function() { return /* binding */ DepthDownsamplingMaterial; },\n/* harmony export */   DepthDownsamplingPass: function() { return /* binding */ DepthDownsamplingPass; },\n/* harmony export */   DepthEffect: function() { return /* binding */ DepthEffect; },\n/* harmony export */   DepthMaskMaterial: function() { return /* binding */ DepthMaskMaterial; },\n/* harmony export */   DepthOfFieldEffect: function() { return /* binding */ DepthOfFieldEffect; },\n/* harmony export */   DepthPass: function() { return /* binding */ DepthPass; },\n/* harmony export */   DepthPickingPass: function() { return /* binding */ DepthPickingPass; },\n/* harmony export */   DepthSavePass: function() { return /* binding */ DepthCopyPass; },\n/* harmony export */   DepthTestStrategy: function() { return /* binding */ DepthTestStrategy; },\n/* harmony export */   DisplayP3ColorSpace: function() { return /* binding */ DisplayP3ColorSpace; },\n/* harmony export */   Disposable: function() { return /* binding */ Disposable; },\n/* harmony export */   DotScreenEffect: function() { return /* binding */ DotScreenEffect; },\n/* harmony export */   DownsamplingMaterial: function() { return /* binding */ DownsamplingMaterial; },\n/* harmony export */   EdgeDetectionMaterial: function() { return /* binding */ EdgeDetectionMaterial; },\n/* harmony export */   EdgeDetectionMode: function() { return /* binding */ EdgeDetectionMode; },\n/* harmony export */   Effect: function() { return /* binding */ Effect; },\n/* harmony export */   EffectAttribute: function() { return /* binding */ EffectAttribute; },\n/* harmony export */   EffectComposer: function() { return /* binding */ EffectComposer; },\n/* harmony export */   EffectMaterial: function() { return /* binding */ EffectMaterial; },\n/* harmony export */   EffectPass: function() { return /* binding */ EffectPass; },\n/* harmony export */   EffectShaderData: function() { return /* binding */ EffectShaderData; },\n/* harmony export */   EffectShaderSection: function() { return /* binding */ EffectShaderSection; },\n/* harmony export */   FXAAEffect: function() { return /* binding */ FXAAEffect; },\n/* harmony export */   GammaCorrectionEffect: function() { return /* binding */ GammaCorrectionEffect; },\n/* harmony export */   GaussKernel: function() { return /* binding */ GaussKernel; },\n/* harmony export */   GaussianBlurMaterial: function() { return /* binding */ GaussianBlurMaterial; },\n/* harmony export */   GaussianBlurPass: function() { return /* binding */ GaussianBlurPass; },\n/* harmony export */   GlitchEffect: function() { return /* binding */ GlitchEffect; },\n/* harmony export */   GlitchMode: function() { return /* binding */ GlitchMode; },\n/* harmony export */   GodRaysEffect: function() { return /* binding */ GodRaysEffect; },\n/* harmony export */   GodRaysMaterial: function() { return /* binding */ GodRaysMaterial; },\n/* harmony export */   GridEffect: function() { return /* binding */ GridEffect; },\n/* harmony export */   HueSaturationEffect: function() { return /* binding */ HueSaturationEffect; },\n/* harmony export */   ImmutableTimer: function() { return /* binding */ ImmutableTimer; },\n/* harmony export */   Initializable: function() { return /* binding */ Initializable; },\n/* harmony export */   KawaseBlurMaterial: function() { return /* binding */ KawaseBlurMaterial; },\n/* harmony export */   KawaseBlurPass: function() { return /* binding */ KawaseBlurPass; },\n/* harmony export */   KernelSize: function() { return /* binding */ KernelSize; },\n/* harmony export */   LUT1DEffect: function() { return /* binding */ LUT1DEffect; },\n/* harmony export */   LUT3DEffect: function() { return /* binding */ LUT3DEffect; },\n/* harmony export */   LUT3dlLoader: function() { return /* binding */ LUT3dlLoader; },\n/* harmony export */   LUTCubeLoader: function() { return /* binding */ LUTCubeLoader; },\n/* harmony export */   LUTEffect: function() { return /* binding */ LUT3DEffect; },\n/* harmony export */   LUTOperation: function() { return /* binding */ LUTOperation; },\n/* harmony export */   LambdaPass: function() { return /* binding */ LambdaPass; },\n/* harmony export */   LensDistortionEffect: function() { return /* binding */ LensDistortionEffect; },\n/* harmony export */   LinearSRGBColorSpace: function() { return /* binding */ LinearSRGBColorSpace; },\n/* harmony export */   LookupTexture: function() { return /* binding */ LookupTexture; },\n/* harmony export */   LookupTexture3D: function() { return /* binding */ LookupTexture; },\n/* harmony export */   LuminanceMaterial: function() { return /* binding */ LuminanceMaterial; },\n/* harmony export */   LuminancePass: function() { return /* binding */ LuminancePass; },\n/* harmony export */   MaskFunction: function() { return /* binding */ MaskFunction; },\n/* harmony export */   MaskMaterial: function() { return /* binding */ MaskMaterial; },\n/* harmony export */   MaskPass: function() { return /* binding */ MaskPass; },\n/* harmony export */   MipmapBlurPass: function() { return /* binding */ MipmapBlurPass; },\n/* harmony export */   NoColorSpace: function() { return /* binding */ NoColorSpace; },\n/* harmony export */   NoiseEffect: function() { return /* binding */ NoiseEffect; },\n/* harmony export */   NoiseTexture: function() { return /* binding */ NoiseTexture; },\n/* harmony export */   NormalPass: function() { return /* binding */ NormalPass; },\n/* harmony export */   OutlineEdgesMaterial: function() { return /* binding */ OutlineMaterial; },\n/* harmony export */   OutlineEffect: function() { return /* binding */ OutlineEffect; },\n/* harmony export */   OutlineMaterial: function() { return /* binding */ OutlineMaterial; },\n/* harmony export */   OverrideMaterialManager: function() { return /* binding */ OverrideMaterialManager; },\n/* harmony export */   Pass: function() { return /* binding */ Pass; },\n/* harmony export */   PixelationEffect: function() { return /* binding */ PixelationEffect; },\n/* harmony export */   PredicationMode: function() { return /* binding */ PredicationMode; },\n/* harmony export */   RawImageData: function() { return /* binding */ RawImageData; },\n/* harmony export */   RealisticBokehEffect: function() { return /* binding */ RealisticBokehEffect; },\n/* harmony export */   RenderPass: function() { return /* binding */ RenderPass; },\n/* harmony export */   Resizable: function() { return /* binding */ Resizable; },\n/* harmony export */   Resizer: function() { return /* binding */ Resolution; },\n/* harmony export */   Resolution: function() { return /* binding */ Resolution; },\n/* harmony export */   SMAAAreaImageData: function() { return /* binding */ SMAAAreaImageData; },\n/* harmony export */   SMAAEffect: function() { return /* binding */ SMAAEffect; },\n/* harmony export */   SMAAImageGenerator: function() { return /* binding */ SMAAImageGenerator; },\n/* harmony export */   SMAAImageLoader: function() { return /* binding */ SMAAImageLoader; },\n/* harmony export */   SMAAPreset: function() { return /* binding */ SMAAPreset; },\n/* harmony export */   SMAASearchImageData: function() { return /* binding */ SMAASearchImageData; },\n/* harmony export */   SMAAWeightsMaterial: function() { return /* binding */ SMAAWeightsMaterial; },\n/* harmony export */   SRGBColorSpace: function() { return /* binding */ SRGBColorSpace; },\n/* harmony export */   SSAOEffect: function() { return /* binding */ SSAOEffect; },\n/* harmony export */   SSAOMaterial: function() { return /* binding */ SSAOMaterial; },\n/* harmony export */   SavePass: function() { return /* binding */ CopyPass; },\n/* harmony export */   ScanlineEffect: function() { return /* binding */ ScanlineEffect; },\n/* harmony export */   Section: function() { return /* binding */ EffectShaderSection; },\n/* harmony export */   Selection: function() { return /* binding */ Selection; },\n/* harmony export */   SelectiveBloomEffect: function() { return /* binding */ SelectiveBloomEffect; },\n/* harmony export */   SepiaEffect: function() { return /* binding */ SepiaEffect; },\n/* harmony export */   ShaderPass: function() { return /* binding */ ShaderPass; },\n/* harmony export */   ShockWaveEffect: function() { return /* binding */ ShockWaveEffect; },\n/* harmony export */   TetrahedralUpscaler: function() { return /* binding */ TetrahedralUpscaler; },\n/* harmony export */   TextureEffect: function() { return /* binding */ TextureEffect; },\n/* harmony export */   TiltShiftBlurMaterial: function() { return /* binding */ TiltShiftBlurMaterial; },\n/* harmony export */   TiltShiftBlurPass: function() { return /* binding */ TiltShiftBlurPass; },\n/* harmony export */   TiltShiftEffect: function() { return /* binding */ TiltShiftEffect; },\n/* harmony export */   Timer: function() { return /* binding */ Timer; },\n/* harmony export */   ToneMappingEffect: function() { return /* binding */ ToneMappingEffect; },\n/* harmony export */   ToneMappingMode: function() { return /* binding */ ToneMappingMode; },\n/* harmony export */   UpsamplingMaterial: function() { return /* binding */ UpsamplingMaterial; },\n/* harmony export */   VignetteEffect: function() { return /* binding */ VignetteEffect; },\n/* harmony export */   VignetteTechnique: function() { return /* binding */ VignetteTechnique; },\n/* harmony export */   WebGLExtension: function() { return /* binding */ WebGLExtension; },\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/**\n * postprocessing v6.33.4 build Sat Dec 02 2023\n * https://github.com/pmndrs/postprocessing\n * Copyright 2015-2023 Raoul van RÃ¼schen\n * @license Zlib\n */\n\n// package.json\nvar version = \"6.33.4\";\n\n// src/core/Disposable.js\nvar Disposable = class {\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n  }\n};\n\n// src/core/EffectComposer.js\n\n\n// src/passes/AdaptiveLuminancePass.js\n\n\n// src/materials/AdaptiveLuminanceMaterial.js\n\n\n// src/materials/glsl/adaptive-luminance.frag\nvar adaptive_luminance_default = \"#include <packing>\\n#define packFloatToRGBA(v) packDepthToRGBA(v)\\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\\n#if __VERSION__ < 300\\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\\n#else\\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\\n#endif\\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}\";\n\n// src/materials/glsl/common.vert\nvar common_default = \"varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/AdaptiveLuminanceMaterial.js\nvar AdaptiveLuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new adaptive luminance material.\n   */\n  constructor() {\n    super({\n      name: \"AdaptiveLuminanceMaterial\",\n      defines: {\n        MIP_LEVEL_1X1: \"0.0\"\n      },\n      uniforms: {\n        luminanceBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        luminanceBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        minLuminance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n        deltaTime: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        tau: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      extensions: {\n        shaderTextureLOD: true\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: adaptive_luminance_default,\n      vertexShader: common_default\n    });\n  }\n  /**\n   * The primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @type {Texture}\n   */\n  set luminanceBuffer0(value) {\n    this.uniforms.luminanceBuffer0.value = value;\n  }\n  /**\n   * Sets the primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @deprecated Use luminanceBuffer0 instead.\n   * @param {Texture} value - The buffer.\n   */\n  setLuminanceBuffer0(value) {\n    this.uniforms.luminanceBuffer0.value = value;\n  }\n  /**\n   * The secondary luminance buffer.\n   *\n   * @type {Texture}\n   */\n  set luminanceBuffer1(value) {\n    this.uniforms.luminanceBuffer1.value = value;\n  }\n  /**\n   * Sets the secondary luminance buffer.\n   *\n   * @deprecated Use luminanceBuffer1 instead.\n   * @param {Texture} value - The buffer.\n   */\n  setLuminanceBuffer1(value) {\n    this.uniforms.luminanceBuffer1.value = value;\n  }\n  /**\n   * The 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the primary luminance buffer.\n   *\n   * @type {Number}\n   */\n  set mipLevel1x1(value) {\n    this.defines.MIP_LEVEL_1X1 = value.toFixed(1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the 1x1 mipmap level.\n   *\n   * @deprecated Use mipLevel1x1 instead.\n   * @param {Number} value - The level.\n   */\n  setMipLevel1x1(value) {\n    this.mipLevel1x1 = value;\n  }\n  /**\n   * The delta time.\n   *\n   * @type {Number}\n   */\n  set deltaTime(value) {\n    this.uniforms.deltaTime.value = value;\n  }\n  /**\n   * Sets the delta time.\n   *\n   * @deprecated Use deltaTime instead.\n   * @param {Number} value - The delta time.\n   */\n  setDeltaTime(value) {\n    this.uniforms.deltaTime.value = value;\n  }\n  /**\n   * The lowest possible luminance value.\n   *\n   * @type {Number}\n   */\n  get minLuminance() {\n    return this.uniforms.minLuminance.value;\n  }\n  set minLuminance(value) {\n    this.uniforms.minLuminance.value = value;\n  }\n  /**\n   * Returns the lowest possible luminance value.\n   *\n   * @deprecated Use minLuminance instead.\n   * @return {Number} The minimum luminance.\n   */\n  getMinLuminance() {\n    return this.uniforms.minLuminance.value;\n  }\n  /**\n   * Sets the minimum luminance.\n   *\n   * @deprecated Use minLuminance instead.\n   * @param {Number} value - The minimum luminance.\n   */\n  setMinLuminance(value) {\n    this.uniforms.minLuminance.value = value;\n  }\n  /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   */\n  get adaptationRate() {\n    return this.uniforms.tau.value;\n  }\n  set adaptationRate(value) {\n    this.uniforms.tau.value = value;\n  }\n  /**\n   * Returns the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @return {Number} The adaptation rate.\n   */\n  getAdaptationRate() {\n    return this.uniforms.tau.value;\n  }\n  /**\n   * Sets the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @param {Number} value - The adaptation rate.\n   */\n  setAdaptationRate(value) {\n    this.uniforms.tau.value = value;\n  }\n};\n\n// src/materials/BokehMaterial.js\n\n\n// src/materials/glsl/convolution.bokeh.frag\nvar convolution_bokeh_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#if PASS == 1\\nuniform vec4 kernel64[32];\\n#else\\nuniform vec4 kernel16[8];\\n#endif\\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\\n#ifdef FOREGROUND\\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\\n#else\\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\\n#endif\\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\\n#ifdef FOREGROUND\\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\\n#else\\nvec2 step=texelSize*coc;\\n#endif\\n#if PASS == 1\\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\\n#else\\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\\n#endif\\n}}\";\n\n// src/materials/BokehMaterial.js\nvar BokehMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new bokeh material.\n   *\n   * @param {Boolean} [fill=false] - Enables or disables the bokeh highlight fill mode.\n   * @param {Boolean} [foreground=false] - Determines whether this material will be applied to foreground colors.\n   */\n  constructor(fill = false, foreground = false) {\n    super({\n      name: \"BokehMaterial\",\n      defines: {\n        PASS: fill ? \"2\" : \"1\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        cocBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        kernel64: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        kernel16: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_bokeh_default,\n      vertexShader: common_default\n    });\n    if (foreground) {\n      this.defines.FOREGROUND = \"1\";\n    }\n    this.generateKernel();\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The circle of confusion buffer.\n   *\n   * @type {Texture}\n   */\n  set cocBuffer(value) {\n    this.uniforms.cocBuffer.value = value;\n  }\n  /**\n   * Sets the circle of confusion buffer.\n   *\n   * @deprecated Use cocBuffer instead.\n   * @param {Texture} value - The buffer.\n   */\n  setCoCBuffer(value) {\n    this.uniforms.cocBuffer.value = value;\n  }\n  /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */\n  getScale(value) {\n    return this.scale;\n  }\n  /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */\n  setScale(value) {\n    this.scale = value;\n  }\n  /**\n   * Generates the blur kernel.\n   *\n   * @private\n   */\n  generateKernel() {\n    const GOLDEN_ANGLE = 2.39996323;\n    const points64 = new Float64Array(128);\n    const points16 = new Float64Array(32);\n    let i64 = 0, i16 = 0;\n    for (let i = 0, sqrt80 = Math.sqrt(80); i < 80; ++i) {\n      const theta = i * GOLDEN_ANGLE;\n      const r = Math.sqrt(i) / sqrt80;\n      const u = r * Math.cos(theta), v3 = r * Math.sin(theta);\n      if (i % 5 === 0) {\n        points16[i16++] = u;\n        points16[i16++] = v3;\n      } else {\n        points64[i64++] = u;\n        points64[i64++] = v3;\n      }\n    }\n    this.uniforms.kernel64.value = points64;\n    this.uniforms.kernel16.value = points16;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/BoxBlurMaterial.js\n\n\n// src/utils/BackCompat.js\n\n\n// src/enums/BlendFunction.js\nvar BlendFunction = {\n  SKIP: 9,\n  SET: 30,\n  ADD: 0,\n  ALPHA: 1,\n  AVERAGE: 2,\n  COLOR: 3,\n  COLOR_BURN: 4,\n  COLOR_DODGE: 5,\n  DARKEN: 6,\n  DIFFERENCE: 7,\n  DIVIDE: 8,\n  DST: 9,\n  EXCLUSION: 10,\n  HARD_LIGHT: 11,\n  HARD_MIX: 12,\n  HUE: 13,\n  INVERT: 14,\n  INVERT_RGB: 15,\n  LIGHTEN: 16,\n  LINEAR_BURN: 17,\n  LINEAR_DODGE: 18,\n  LINEAR_LIGHT: 19,\n  LUMINOSITY: 20,\n  MULTIPLY: 21,\n  NEGATION: 22,\n  NORMAL: 23,\n  OVERLAY: 24,\n  PIN_LIGHT: 25,\n  REFLECT: 26,\n  SATURATION: 27,\n  SCREEN: 28,\n  SOFT_LIGHT: 29,\n  SRC: 30,\n  SUBTRACT: 31,\n  VIVID_LIGHT: 32\n};\n\n// src/enums/ColorChannel.js\nvar ColorChannel = {\n  RED: 0,\n  GREEN: 1,\n  BLUE: 2,\n  ALPHA: 3\n};\n\n// src/enums/ColorSpace.js\nvar NoColorSpace = \"\";\nvar SRGBColorSpace = \"srgb\";\nvar LinearSRGBColorSpace = \"srgb-linear\";\nvar DisplayP3ColorSpace = \"display-p3\";\n\n// src/enums/DepthCopyMode.js\nvar DepthCopyMode = {\n  FULL: 0,\n  SINGLE: 1\n};\n\n// src/enums/DepthTestStrategy.js\nvar DepthTestStrategy = {\n  DEFAULT: 0,\n  KEEP_MAX_DEPTH: 1,\n  DISCARD_MAX_DEPTH: 2\n};\n\n// src/enums/EdgeDetectionMode.js\nvar EdgeDetectionMode = {\n  DEPTH: 0,\n  LUMA: 1,\n  COLOR: 2\n};\n\n// src/enums/EffectAttribute.js\nvar EffectAttribute = {\n  NONE: 0,\n  DEPTH: 1,\n  CONVOLUTION: 2\n};\n\n// src/enums/EffectShaderSection.js\nvar EffectShaderSection = {\n  FRAGMENT_HEAD: \"FRAGMENT_HEAD\",\n  FRAGMENT_MAIN_UV: \"FRAGMENT_MAIN_UV\",\n  FRAGMENT_MAIN_IMAGE: \"FRAGMENT_MAIN_IMAGE\",\n  VERTEX_HEAD: \"VERTEX_HEAD\",\n  VERTEX_MAIN_SUPPORT: \"VERTEX_MAIN_SUPPORT\"\n};\n\n// src/enums/GlitchMode.js\nvar GlitchMode = {\n  DISABLED: 0,\n  SPORADIC: 1,\n  CONSTANT_MILD: 2,\n  CONSTANT_WILD: 3\n};\n\n// src/enums/KernelSize.js\nvar KernelSize = {\n  VERY_SMALL: 0,\n  SMALL: 1,\n  MEDIUM: 2,\n  LARGE: 3,\n  VERY_LARGE: 4,\n  HUGE: 5\n};\n\n// src/enums/LUTOperation.js\nvar LUTOperation = {\n  SCALE_UP: \"lut.scaleup\"\n};\n\n// src/enums/MaskFunction.js\nvar MaskFunction = {\n  DISCARD: 0,\n  MULTIPLY: 1,\n  MULTIPLY_RGB_SET_ALPHA: 2,\n  MULTIPLY_RGB: 3\n};\n\n// src/enums/PredicationMode.js\nvar PredicationMode = {\n  DISABLED: 0,\n  DEPTH: 1,\n  CUSTOM: 2\n};\n\n// src/enums/SMAAPreset.js\nvar SMAAPreset = {\n  LOW: 0,\n  MEDIUM: 1,\n  HIGH: 2,\n  ULTRA: 3\n};\n\n// src/enums/ToneMappingMode.js\nvar ToneMappingMode = {\n  REINHARD: 0,\n  REINHARD2: 1,\n  REINHARD2_ADAPTIVE: 2,\n  OPTIMIZED_CINEON: 3,\n  ACES_FILMIC: 4,\n  UNCHARTED2: 5\n};\n\n// src/enums/VignetteTechnique.js\nvar VignetteTechnique = {\n  DEFAULT: 0,\n  ESKIL: 1\n};\n\n// src/enums/WebGLExtension.js\nvar WebGLExtension = {\n  DERIVATIVES: \"derivatives\",\n  FRAG_DEPTH: \"fragDepth\",\n  DRAW_BUFFERS: \"drawBuffers\",\n  SHADER_TEXTURE_LOD: \"shaderTextureLOD\"\n};\n\n// src/utils/BackCompat.js\nvar revision = Number(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nvar useColorSpace = revision >= 152;\nvar encodingToColorSpace = /* @__PURE__ */ new Map([\n  [three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding, LinearSRGBColorSpace],\n  [three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding, SRGBColorSpace]\n]);\nvar colorSpaceToEncoding = /* @__PURE__ */ new Map([\n  [LinearSRGBColorSpace, three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding],\n  [SRGBColorSpace, three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding]\n]);\nfunction getOutputColorSpace(renderer) {\n  return renderer === null ? null : useColorSpace ? renderer.outputColorSpace : encodingToColorSpace.get(renderer.outputEncoding);\n}\nfunction setTextureColorSpace(texture, colorSpace) {\n  if (texture === null) {\n    return;\n  }\n  if (useColorSpace) {\n    texture.colorSpace = colorSpace;\n  } else {\n    texture.encoding = colorSpaceToEncoding.get(colorSpace);\n  }\n}\nfunction copyTextureColorSpace(src, dest) {\n  if (src === null || dest === null) {\n    return;\n  }\n  if (useColorSpace) {\n    dest.colorSpace = src.colorSpace;\n  } else {\n    dest.encoding = src.encoding;\n  }\n}\nfunction updateFragmentShader(fragmentShader) {\n  if (revision < 154) {\n    return fragmentShader.replace(\"colorspace_fragment\", \"encodings_fragment\");\n  }\n  return fragmentShader;\n}\n\n// src/utils/orthographicDepthToViewZ.js\nfunction orthographicDepthToViewZ(depth, near, far) {\n  return depth * (near - far) - near;\n}\n\n// src/utils/viewZToOrthographicDepth.js\nfunction viewZToOrthographicDepth(viewZ, near, far) {\n  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);\n}\n\n// src/materials/glsl/convolution.box.frag\nvar convolution_box_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#ifdef BILATERAL\\n#include <packing>\\nuniform vec2 cameraNearFar;\\n#ifdef NORMAL_DEPTH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\\n#else\\n#if DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}\\n#endif\\nfloat getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#endif\\n}\\n#ifdef PERSPECTIVE_CAMERA\\n#define linearDepth(v) viewZToOrthographicDepth(getViewZ(readDepth(v)), cameraNearFar.x, cameraNearFar.y)\\n#else\\n#define linearDepth(v) readDepth(v)\\n#endif\\n#endif\\n#define getTexel(v) texture2D(inputBuffer, v)\\n#if KERNEL_SIZE == 3\\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\\n#else\\nuniform vec2 texelSize;uniform float scale;varying vec2 vUv;\\n#endif\\nvoid main(){\\n#if KERNEL_SIZE == 3\\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08));\\n#ifdef BILATERAL\\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08));\\n#endif\\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08),getTexel(vUv09),getTexel(vUv10),getTexel(vUv11),getTexel(vUv12),getTexel(vUv13),getTexel(vUv14),getTexel(vUv15),getTexel(vUv16),getTexel(vUv17),getTexel(vUv18),getTexel(vUv19),getTexel(vUv20),getTexel(vUv21),getTexel(vUv22),getTexel(vUv23),getTexel(vUv24));\\n#ifdef BILATERAL\\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08),linearDepth(vUv09),linearDepth(vUv10),linearDepth(vUv11),linearDepth(vUv12),linearDepth(vUv13),linearDepth(vUv14),linearDepth(vUv15),linearDepth(vUv16),linearDepth(vUv17),linearDepth(vUv18),linearDepth(vUv19),linearDepth(vUv20),linearDepth(vUv21),linearDepth(vUv22),linearDepth(vUv23),linearDepth(vUv24));\\n#endif\\n#endif\\nvec4 result=vec4(0.0);\\n#ifdef BILATERAL\\nfloat w=0.0;\\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\\nfloat centerDepth=z[KERNEL_SIZE_SQ_HALF];for(int i=0;i<KERNEL_SIZE_SQ;++i){float d=step(abs(z[i]-centerDepth),DISTANCE_THRESHOLD);result+=c[i]*d;w+=d;}\\n#else\\nfloat centerDepth=linearDepth(vUv);vec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){vec2 coords=vUv+vec2(x,y)*s;vec4 c=getTexel(coords);float z=(x==0&&y==0)?centerDepth:linearDepth(coords);float d=step(abs(z-centerDepth),DISTANCE_THRESHOLD);result+=c*d;w+=d;}}\\n#endif\\ngl_FragColor=result/max(w,1.0);\\n#else\\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\\nfor(int i=0;i<KERNEL_SIZE_SQ;++i){result+=c[i];}\\n#else\\nvec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){result+=getTexel(uv+vec2(x,y)*s);}}\\n#endif\\ngl_FragColor=result*INV_KERNEL_SIZE_SQ;\\n#endif\\n}\";\n\n// src/materials/glsl/convolution.box.vert\nvar convolution_box_default2 = \"uniform vec2 texelSize;uniform float scale;\\n#if KERNEL_SIZE == 3\\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\\n#else\\nvarying vec2 vUv;\\n#endif\\nvoid main(){vec2 uv=position.xy*0.5+0.5;\\n#if KERNEL_SIZE == 3\\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-1.0,-1.0);vUv01=uv+s*vec2(0.0,-1.0);vUv02=uv+s*vec2(1.0,-1.0);vUv03=uv+s*vec2(-1.0,0.0);vUv04=uv;vUv05=uv+s*vec2(1.0,0.0);vUv06=uv+s*vec2(-1.0,1.0);vUv07=uv+s*vec2(0.0,1.0);vUv08=uv+s*vec2(1.0,1.0);\\n#elif KERNEL_SIZE == 5\\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-2.0,-2.0);vUv01=uv+s*vec2(-1.0,-2.0);vUv02=uv+s*vec2(0.0,-2.0);vUv03=uv+s*vec2(1.0,-2.0);vUv04=uv+s*vec2(2.0,-2.0);vUv05=uv+s*vec2(-2.0,-1.0);vUv06=uv+s*vec2(-1.0,-1.0);vUv07=uv+s*vec2(0.0,-1.0);vUv08=uv+s*vec2(1.0,-1.0);vUv09=uv+s*vec2(2.0,-1.0);vUv10=uv+s*vec2(-2.0,0.0);vUv11=uv+s*vec2(-1.0,0.0);vUv12=uv;vUv13=uv+s*vec2(1.0,0.0);vUv14=uv+s*vec2(2.0,0.0);vUv15=uv+s*vec2(-2.0,1.0);vUv16=uv+s*vec2(-1.0,1.0);vUv17=uv+s*vec2(0.0,1.0);vUv18=uv+s*vec2(1.0,1.0);vUv19=uv+s*vec2(2.0,1.0);vUv20=uv+s*vec2(-2.0,2.0);vUv21=uv+s*vec2(-1.0,2.0);vUv22=uv+s*vec2(0.0,2.0);vUv23=uv+s*vec2(1.0,2.0);vUv24=uv+s*vec2(2.0,2.0);\\n#else\\nvUv=uv;\\n#endif\\ngl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/BoxBlurMaterial.js\nvar BoxBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new box blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.kernelSize=5] - The kernel size.\n   */\n  constructor({ bilateral = false, kernelSize = 5 } = {}) {\n    super({\n      name: \"BoxBlurMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\",\n        DISTANCE_THRESHOLD: \"0.1\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_box_default,\n      vertexShader: convolution_box_default2\n    });\n    this.bilateral = bilateral;\n    this.kernelSize = kernelSize;\n    this.maxVaryingVectors = 8;\n  }\n  /**\n   * The maximum amount of varying vectors.\n   *\n   * Should be synced with `renderer.capabilities.maxVaryings`. Default is 8.\n   *\n   * @type {Number}\n   */\n  set maxVaryingVectors(value) {\n    this.defines.MAX_VARYING_VECTORS = value.toFixed(0);\n  }\n  /**\n   * The kernel size.\n   *\n   * - Must be an odd number\n   * - Kernel size 3 and 5 use optimized code paths\n   * - Default is 5\n   *\n   * @type {Number}\n   */\n  get kernelSize() {\n    return Number(this.defines.KERNEL_SIZE);\n  }\n  set kernelSize(value) {\n    if (value % 2 === 0) {\n      throw new Error(\"The kernel size must be an odd number\");\n    }\n    this.defines.KERNEL_SIZE = value.toFixed(0);\n    this.defines.KERNEL_SIZE_HALF = Math.floor(value / 2).toFixed(0);\n    this.defines.KERNEL_SIZE_SQ = (value ** 2).toFixed(0);\n    this.defines.KERNEL_SIZE_SQ_HALF = Math.floor(value ** 2 / 2).toFixed(0);\n    this.defines.INV_KERNEL_SIZE_SQ = (1 / value ** 2).toFixed(6);\n    this.needsUpdate = true;\n  }\n  /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get near() {\n    return this.uniforms.cameraNearFar.value.x;\n  }\n  /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get far() {\n    return this.uniforms.cameraNearFar.value.y;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * A combined normal-depth buffer. Overrides {@link depthBuffer} if set.\n   *\n   * @type {Texture}\n   */\n  set normalDepthBuffer(value) {\n    this.uniforms.normalDepthBuffer.value = value;\n    if (value !== null) {\n      this.defines.NORMAL_DEPTH = \"1\";\n    } else {\n      delete this.defines.NORMAL_DEPTH;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether bilateral filtering is enabled.\n   *\n   * @type {Boolean}\n   */\n  get bilateral() {\n    return this.defines.BILATERAL !== void 0;\n  }\n  set bilateral(value) {\n    if (value !== null) {\n      this.defines.BILATERAL = \"1\";\n    } else {\n      delete this.defines.BILATERAL;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * The bilateral filter distance threshold in world units.\n   *\n   * @type {Number}\n   */\n  get worldDistanceThreshold() {\n    return -orthographicDepthToViewZ(Number(this.defines.DISTANCE_THRESHOLD), this.near, this.far);\n  }\n  set worldDistanceThreshold(value) {\n    const threshold = viewZToOrthographicDepth(-value, this.near, this.far);\n    this.defines.DISTANCE_THRESHOLD = threshold.toFixed(12);\n    this.needsUpdate = true;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/CircleOfConfusionMaterial.js\n\n\n// src/materials/glsl/circle-of-confusion.frag\nvar circle_of_confusion_default = \"#include <common>\\n#include <packing>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nfloat depth=texture2D(depthBuffer,uv).r;\\n#endif\\n#ifdef LOG_DEPTH\\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\\n#endif\\nreturn depth;}void main(){float depth=readDepth(vUv);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\\n#else\\nfloat linearDepth=depth;\\n#endif\\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}\";\n\n// src/materials/CircleOfConfusionMaterial.js\nvar CircleOfConfusionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new CoC material.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  constructor(camera) {\n    super({\n      name: \"CircleOfConfusionMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        focusDistance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        focusRange: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n        cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: circle_of_confusion_default,\n      vertexShader: common_default\n    });\n    this.uniforms.focalLength = this.uniforms.focusRange;\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get near() {\n    return this.uniforms.cameraNear.value;\n  }\n  /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get far() {\n    return this.uniforms.cameraFar.value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The focus distance. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get focusDistance() {\n    return this.uniforms.focusDistance.value;\n  }\n  set focusDistance(value) {\n    this.uniforms.focusDistance.value = value;\n  }\n  /**\n   * The focus distance in world units.\n   *\n   * @type {Number}\n   */\n  get worldFocusDistance() {\n    return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);\n  }\n  set worldFocusDistance(value) {\n    this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Returns the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @return {Number} The focus distance.\n   */\n  getFocusDistance(value) {\n    this.uniforms.focusDistance.value = value;\n  }\n  /**\n   * Sets the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @param {Number} value - The focus distance.\n   */\n  setFocusDistance(value) {\n    this.uniforms.focusDistance.value = value;\n  }\n  /**\n   * The focal length.\n   *\n   * @deprecated Renamed to focusRange.\n   * @type {Number}\n   */\n  get focalLength() {\n    return this.focusRange;\n  }\n  set focalLength(value) {\n    this.focusRange = value;\n  }\n  /**\n   * The focus range. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get focusRange() {\n    return this.uniforms.focusRange.value;\n  }\n  set focusRange(value) {\n    this.uniforms.focusRange.value = value;\n  }\n  /**\n   * The focus range in world units.\n   *\n   * @type {Number}\n   */\n  get worldFocusRange() {\n    return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);\n  }\n  set worldFocusRange(value) {\n    this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Returns the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @return {Number} The focal length.\n   */\n  getFocalLength(value) {\n    return this.focusRange;\n  }\n  /**\n   * Sets the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @param {Number} value - The focal length.\n   */\n  setFocalLength(value) {\n    this.focusRange = value;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNear.value = camera.near;\n      this.uniforms.cameraFar.value = camera.far;\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n};\n\n// src/materials/KawaseBlurMaterial.js\n\n\n// src/materials/glsl/convolution.kawase.frag\nvar convolution_kawase_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\\n#include <colorspace_fragment>\\n}\";\n\n// src/materials/glsl/convolution.kawase.vert\nvar convolution_kawase_default2 = \"uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/KawaseBlurMaterial.js\nvar kernelPresets = [\n  new Float32Array([0, 0]),\n  new Float32Array([0, 1, 1]),\n  new Float32Array([0, 1, 1, 2]),\n  new Float32Array([0, 1, 2, 2, 3]),\n  new Float32Array([0, 1, 2, 3, 4, 4, 5]),\n  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])\n];\nvar KawaseBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new convolution material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector4} [texelSize] - Deprecated.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()) {\n    super({\n      name: \"KawaseBlurMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_kawase_default,\n      vertexShader: convolution_kawase_default2\n    });\n    this.fragmentShader = updateFragmentShader(this.fragmentShader);\n    this.setTexelSize(texelSize.x, texelSize.y);\n    this.kernelSize = KernelSize.MEDIUM;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.inputBuffer = value;\n  }\n  /**\n   * The kernel sequence for the current kernel size.\n   *\n   * @type {Float32Array}\n   */\n  get kernelSequence() {\n    return kernelPresets[this.kernelSize];\n  }\n  /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */\n  getScale() {\n    return this.uniforms.scale.value;\n  }\n  /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} value - The scale.\n   */\n  setScale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Returns the kernel.\n   *\n   * @return {Float32Array} The kernel.\n   * @deprecated Implementation detail, removed with no replacement.\n   */\n  getKernel() {\n    return null;\n  }\n  /**\n   * The current kernel.\n   *\n   * @type {Number}\n   */\n  get kernel() {\n    return this.uniforms.kernel.value;\n  }\n  set kernel(value) {\n    this.uniforms.kernel.value = value;\n  }\n  /**\n   * Sets the current kernel.\n   *\n   * @deprecated Use kernel instead.\n   * @param {Number} value - The kernel.\n   */\n  setKernel(value) {\n    this.kernel = value;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const x = 1 / width, y = 1 / height;\n    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n  }\n};\n\n// src/materials/CopyMaterial.js\n\n\n// src/materials/glsl/copy.frag\nvar copy_default = \"#include <common>\\n#include <dithering_pars_fragment>\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\\n#include <colorspace_fragment>\\n#include <dithering_fragment>\\n}\";\n\n// src/materials/CopyMaterial.js\nvar CopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new copy material.\n   */\n  constructor() {\n    super({\n      name: \"CopyMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        opacity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: copy_default,\n      vertexShader: common_default\n    });\n    this.fragmentShader = updateFragmentShader(this.fragmentShader);\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Number} value - The buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Returns the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @return {Number} The opacity.\n   */\n  getOpacity(value) {\n    return this.uniforms.opacity.value;\n  }\n  /**\n   * Sets the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @param {Number} value - The opacity.\n   */\n  setOpacity(value) {\n    this.uniforms.opacity.value = value;\n  }\n};\n\n// src/materials/DepthComparisonMaterial.js\n\n\n// src/materials/glsl/depth-comparison.frag\nvar depth_comparison_default = \"#include <packing>\\n#include <clipping_planes_pars_fragment>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nuniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){\\n#include <clipping_planes_fragment>\\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\\n#if DEPTH_PACKING == 3201\\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\\n#else\\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\\n#endif\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\\n#else\\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\\n#endif\\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}\";\n\n// src/materials/glsl/depth-comparison.vert\nvar depth_comparison_default2 = \"#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\\n#include <skinbase_vertex>\\n#include <begin_vertex>\\n#include <morphtarget_vertex>\\n#include <skinning_vertex>\\n#include <project_vertex>\\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\\n#include <clipping_planes_vertex>\\n}\";\n\n// src/materials/DepthComparisonMaterial.js\nvar DepthComparisonMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth comparison material.\n   *\n   * @param {Texture} [depthTexture=null] - A depth texture.\n   * @param {PerspectiveCamera} [camera] - A camera.\n   */\n  constructor(depthTexture = null, camera) {\n    super({\n      name: \"DepthComparisonMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n        cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_comparison_default,\n      vertexShader: depth_comparison_default2\n    });\n    this.depthBuffer = depthTexture;\n    this.depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNear.value = camera.near;\n      this.uniforms.cameraFar.value = camera.far;\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n};\n\n// src/materials/DepthCopyMaterial.js\n\n\n// src/materials/glsl/depth-copy.frag\nvar depth_copy_default = \"#include <packing>\\nvarying vec2 vUv;\\n#ifdef NORMAL_DEPTH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\\n#else\\n#if INPUT_DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if INPUT_DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}\\n#endif\\nvoid main(){\\n#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING\\ngl_FragColor=texture2D(depthBuffer,vUv);\\n#else\\nfloat depth=readDepth(vUv);\\n#if OUTPUT_DEPTH_PACKING == 3201\\ngl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);\\n#else\\ngl_FragColor=vec4(vec3(depth),1.0);\\n#endif\\n#endif\\n}\";\n\n// src/materials/glsl/depth-copy.vert\nvar depth_copy_default2 = \"varying vec2 vUv;\\n#if DEPTH_COPY_MODE == 1\\nuniform vec2 texelPosition;\\n#endif\\nvoid main(){\\n#if DEPTH_COPY_MODE == 1\\nvUv=texelPosition;\\n#else\\nvUv=position.xy*0.5+0.5;\\n#endif\\ngl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/DepthCopyMaterial.js\nvar DepthCopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth copy material.\n   */\n  constructor() {\n    super({\n      name: \"DepthCopyMaterial\",\n      defines: {\n        INPUT_DEPTH_PACKING: \"0\",\n        OUTPUT_DEPTH_PACKING: \"0\",\n        DEPTH_COPY_MODE: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_copy_default,\n      vertexShader: depth_copy_default2\n    });\n    this.depthCopyMode = DepthCopyMode.FULL;\n  }\n  /**\n   * The input depth buffer.\n   *\n   * @type {Texture}\n   */\n  get depthBuffer() {\n    return this.uniforms.depthBuffer.value;\n  }\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The input depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set inputDepthPacking(value) {\n    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * The output depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  get outputDepthPacking() {\n    return Number(this.defines.OUTPUT_DEPTH_PACKING);\n  }\n  set outputDepthPacking(value) {\n    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the input depth buffer.\n   *\n   * @deprecated Use depthBuffer and inputDepthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.inputDepthPacking = depthPacking;\n  }\n  /**\n   * Returns the current input depth packing strategy.\n   *\n   * @deprecated\n   * @return {DepthPackingStrategies} The input depth packing strategy.\n   */\n  getInputDepthPacking() {\n    return Number(this.defines.INPUT_DEPTH_PACKING);\n  }\n  /**\n   * Sets the input depth packing strategy.\n   *\n   * @deprecated Use inputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new input depth packing strategy.\n   */\n  setInputDepthPacking(value) {\n    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @return {DepthPackingStrategies} The output depth packing strategy.\n   */\n  getOutputDepthPacking() {\n    return Number(this.defines.OUTPUT_DEPTH_PACKING);\n  }\n  /**\n   * Sets the output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new output depth packing strategy.\n   */\n  setOutputDepthPacking(value) {\n    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * The screen space position used for single-texel copy operations.\n   *\n   * @type {Vector2}\n   */\n  get texelPosition() {\n    return this.uniforms.texelPosition.value;\n  }\n  /**\n   * Returns the screen space position used for single-texel copy operations.\n   *\n   * @deprecated Use texelPosition instead.\n   * @return {Vector2} The position.\n   */\n  getTexelPosition() {\n    return this.uniforms.texelPosition.value;\n  }\n  /**\n   * Sets the screen space position used for single-texel copy operations.\n   *\n   * @deprecated\n   * @param {Vector2} value - The position.\n   */\n  setTexelPosition(value) {\n    this.uniforms.texelPosition.value = value;\n  }\n  /**\n   * The depth copy mode.\n   *\n   * @type {DepthCopyMode}\n   */\n  get mode() {\n    return this.depthCopyMode;\n  }\n  set mode(value) {\n    this.depthCopyMode = value;\n    this.defines.DEPTH_COPY_MODE = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {DepthCopyMode} The depth copy mode.\n   */\n  getMode() {\n    return this.mode;\n  }\n  /**\n   * Sets the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {DepthCopyMode} value - The new mode.\n   */\n  setMode(value) {\n    this.mode = value;\n  }\n};\n\n// src/materials/DepthDownsamplingMaterial.js\n\n\n// src/materials/glsl/depth-downsampling.frag\nvar depth_downsampling_default = \"#include <packing>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\n#ifdef DOWNSAMPLE_NORMALS\\nuniform lowp sampler2D normalBuffer;\\n#endif\\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\\n#ifdef DOWNSAMPLE_NORMALS\\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\\n#else\\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\\n#endif\\ngl_FragColor=vec4(n[index],d[index]);}\";\n\n// src/materials/glsl/depth-downsampling.vert\nvar depth_downsampling_default2 = \"uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/DepthDownsamplingMaterial.js\nvar DepthDownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth downsampling material.\n   */\n  constructor() {\n    super({\n      name: \"DepthDownsamplingMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_downsampling_default,\n      vertexShader: depth_downsampling_default2\n    });\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */\n  set normalBuffer(value) {\n    this.uniforms.normalBuffer.value = value;\n    if (value !== null) {\n      this.defines.DOWNSAMPLE_NORMALS = \"1\";\n    } else {\n      delete this.defines.DOWNSAMPLE_NORMALS;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Texture} value - The normal buffer.\n   */\n  setNormalBuffer(value) {\n    this.normalBuffer = value;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/DepthMaskMaterial.js\n\n\n// src/materials/glsl/depth-mask.frag\nvar depth_mask_default = \"#include <common>\\n#include <packing>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\\n#else\\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\\n#endif\\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#endif\\n}varying vec2 vUv;void main(){vec2 depth;\\n#if DEPTH_PACKING_0 == 3201\\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\\n#else\\ndepth.x=texture2D(depthBuffer0,vUv).r;\\n#ifdef LOG_DEPTH\\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\\n#endif\\n#endif\\n#if DEPTH_PACKING_1 == 3201\\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\\n#else\\ndepth.y=texture2D(depthBuffer1,vUv).r;\\n#ifdef LOG_DEPTH\\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\\n#endif\\n#endif\\nbool isMaxDepth=(depth.x==1.0);\\n#ifdef PERSPECTIVE_CAMERA\\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\\n#endif\\n#if DEPTH_TEST_STRATEGY == 0\\nbool keep=depthTest(depth.x,depth.y);\\n#elif DEPTH_TEST_STRATEGY == 1\\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\\n#else\\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\\n#endif\\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}\";\n\n// src/materials/DepthMaskMaterial.js\nvar DepthMaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth mask material.\n   */\n  constructor() {\n    super({\n      name: \"DepthMaskMaterial\",\n      defines: {\n        DEPTH_EPSILON: \"0.0001\",\n        DEPTH_PACKING_0: \"0\",\n        DEPTH_PACKING_1: \"0\",\n        DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1))\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_mask_default,\n      vertexShader: common_default\n    });\n    this.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.LessDepth;\n  }\n  /**\n   * The primary depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer0(value) {\n    this.uniforms.depthBuffer0.value = value;\n  }\n  /**\n   * The primary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking0(value) {\n    this.defines.DEPTH_PACKING_0 = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the base depth buffer.\n   *\n   * @deprecated Use depthBuffer0 and depthPacking0 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer0(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer0 = buffer;\n    this.depthPacking0 = depthPacking;\n  }\n  /**\n   * The secondary depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer1(value) {\n    this.uniforms.depthBuffer1.value = value;\n  }\n  /**\n   * The secondary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking1(value) {\n    this.defines.DEPTH_PACKING_1 = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer that will be compared with the base depth buffer.\n   *\n   * @deprecated Use depthBuffer1 and depthPacking1 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer1(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer1 = buffer;\n    this.depthPacking1 = depthPacking;\n  }\n  /**\n   * The strategy for handling maximum depth.\n   *\n   * @type {DepthTestStrategy}\n   */\n  get maxDepthStrategy() {\n    return Number(this.defines.DEPTH_TEST_STRATEGY);\n  }\n  set maxDepthStrategy(value) {\n    this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether maximum depth values should be preserved.\n   *\n   * @type {Boolean}\n   * @deprecated Use maxDepthStrategy instead.\n   */\n  get keepFar() {\n    return this.maxDepthStrategy;\n  }\n  set keepFar(value) {\n    this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;\n  }\n  /**\n   * Returns the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @return {DepthTestStrategy} The strategy.\n   */\n  getMaxDepthStrategy() {\n    return this.maxDepthStrategy;\n  }\n  /**\n   * Sets the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @param {DepthTestStrategy} value - The strategy.\n   */\n  setMaxDepthStrategy(value) {\n    this.maxDepthStrategy = value;\n  }\n  /**\n   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.\n   *\n   * @type {Number}\n   */\n  get epsilon() {\n    return Number(this.defines.DEPTH_EPSILON);\n  }\n  set epsilon(value) {\n    this.defines.DEPTH_EPSILON = value.toFixed(16);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current error threshold for depth comparisons.\n   *\n   * @deprecated Use epsilon instead.\n   * @return {Number} The error threshold.\n   */\n  getEpsilon() {\n    return this.epsilon;\n  }\n  /**\n   * Sets the depth comparison error threshold.\n   *\n   * @deprecated Use epsilon instead.\n   * @param {Number} value - The new error threshold.\n   */\n  setEpsilon(value) {\n    this.epsilon = value;\n  }\n  /**\n   * The depth mode.\n   *\n   * @see https://threejs.org/docs/#api/en/constants/Materials\n   * @type {DepthModes}\n   */\n  get depthMode() {\n    return Number(this.defines.DEPTH_MODE);\n  }\n  set depthMode(value) {\n    let depthTest;\n    switch (value) {\n      case three__WEBPACK_IMPORTED_MODULE_0__.NeverDepth:\n        depthTest = \"false\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth:\n        depthTest = \"true\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth:\n        depthTest = \"abs(d1 - d0) <= DEPTH_EPSILON\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth:\n        depthTest = \"abs(d1 - d0) > DEPTH_EPSILON\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.LessDepth:\n        depthTest = \"d0 > d1\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth:\n        depthTest = \"d0 >= d1\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth:\n        depthTest = \"d0 <= d1\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth:\n      default:\n        depthTest = \"d0 < d1\";\n        break;\n    }\n    this.defines.DEPTH_MODE = value.toFixed(0);\n    this.defines[\"depthTest(d0, d1)\"] = depthTest;\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @return {DepthModes} The depth mode. Default is `LessDepth`.\n   */\n  getDepthMode() {\n    return this.depthMode;\n  }\n  /**\n   * Sets the depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @param {DepthModes} mode - The depth mode.\n   */\n  setDepthMode(mode) {\n    this.depthMode = mode;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n};\n\n// src/materials/DownsamplingMaterial.js\n\n\n// src/materials/glsl/convolution.downsampling.frag\nvar convolution_downsampling_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#define WEIGHT_INNER 0.125\\n#define WEIGHT_OUTER 0.0555555\\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\\n#include <colorspace_fragment>\\n}\";\n\n// src/materials/glsl/convolution.downsampling.vert\nvar convolution_downsampling_default2 = \"uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/DownsamplingMaterial.js\nvar DownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new downsampling material.\n   */\n  constructor() {\n    super({\n      name: \"DownsamplingMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_downsampling_default,\n      vertexShader: convolution_downsampling_default2\n    });\n    this.fragmentShader = updateFragmentShader(this.fragmentShader);\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/EdgeDetectionMaterial.js\n\n\n// src/materials/glsl/edge-detection.frag\nvar edge_detection_default = \"varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#if EDGE_DETECTION_MODE != 0\\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\\n#endif\\n#if EDGE_DETECTION_MODE == 1\\n#include <common>\\n#endif\\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\\n#elif PREDICATION_MODE == 2\\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\\n#endif\\n#if PREDICATION_MODE != 0\\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\\n#endif\\n#if EDGE_DETECTION_MODE != 0\\nuniform sampler2D inputBuffer;\\n#endif\\nvoid main(){\\n#if EDGE_DETECTION_MODE == 0\\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\\n#elif PREDICATION_MODE != 0\\nvec2 threshold=calculatePredicatedThreshold();\\n#else\\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\\n#endif\\n#if EDGE_DETECTION_MODE == 0\\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\\n#elif EDGE_DETECTION_MODE == 1\\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\\n#elif EDGE_DETECTION_MODE == 2\\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\\n#endif\\n}\";\n\n// src/materials/glsl/edge-detection.vert\nvar edge_detection_default2 = \"uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\\n#if EDGE_DETECTION_MODE != 0\\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\\n#endif\\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\\n#if EDGE_DETECTION_MODE != 0\\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\\n#endif\\ngl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/EdgeDetectionMaterial.js\nvar EdgeDetectionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new edge detection material.\n   *\n   * TODO Remove parameters.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), mode = EdgeDetectionMode.COLOR) {\n    super({\n      name: \"EdgeDetectionMaterial\",\n      defines: {\n        THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n        LOCAL_CONTRAST_ADAPTATION_FACTOR: \"2.0\",\n        EDGE_THRESHOLD: \"0.1\",\n        DEPTH_THRESHOLD: \"0.01\",\n        PREDICATION_MODE: \"0\",\n        PREDICATION_THRESHOLD: \"0.01\",\n        PREDICATION_SCALE: \"2.0\",\n        PREDICATION_STRENGTH: \"1.0\",\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        predicationBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: edge_detection_default,\n      vertexShader: edge_detection_default2\n    });\n    this.edgeDetectionMode = mode;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The edge detection mode.\n   *\n   * @type {EdgeDetectionMode}\n   */\n  get edgeDetectionMode() {\n    return Number(this.defines.EDGE_DETECTION_MODE);\n  }\n  set edgeDetectionMode(value) {\n    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @return {EdgeDetectionMode} The mode.\n   */\n  getEdgeDetectionMode() {\n    return this.edgeDetectionMode;\n  }\n  /**\n   * Sets the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @param {EdgeDetectionMode} value - The edge detection mode.\n   */\n  setEdgeDetectionMode(value) {\n    this.edgeDetectionMode = value;\n  }\n  /**\n   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.\n   *\n   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.\n   *\n   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a\n   * direction, the perceptual contrast in the other neighbors will be hidden.\n   *\n   * @type {Number}\n   */\n  get localContrastAdaptationFactor() {\n    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);\n  }\n  set localContrastAdaptationFactor(value) {\n    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the local contrast adaptation factor.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @return {Number} The factor.\n   */\n  getLocalContrastAdaptationFactor() {\n    return this.localContrastAdaptationFactor;\n  }\n  /**\n   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.\n   */\n  setLocalContrastAdaptationFactor(value) {\n    this.localContrastAdaptationFactor = value;\n  }\n  /**\n   * The edge detection threshold. Range: [0.0, 0.5].\n   *\n   * A lower value results in more edges being detected at the expense of performance.\n   *\n   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05\n   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.\n   *\n   * If depth-based edge detection is used, the threshold will depend on the scene depth.\n   *\n   * @type {Number}\n   */\n  get edgeDetectionThreshold() {\n    return Number(this.defines.EDGE_THRESHOLD);\n  }\n  set edgeDetectionThreshold(value) {\n    this.defines.EDGE_THRESHOLD = value.toFixed(\"6\");\n    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @return {Number} The threshold.\n   */\n  getEdgeDetectionThreshold() {\n    return this.edgeDetectionThreshold;\n  }\n  /**\n   * Sets the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].\n   */\n  setEdgeDetectionThreshold(value) {\n    this.edgeDetectionThreshold = value;\n  }\n  /**\n   * The predication mode.\n   *\n   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional\n   * buffer such as a light accumulation or depth buffer.\n   *\n   * @type {PredicationMode}\n   */\n  get predicationMode() {\n    return Number(this.defines.PREDICATION_MODE);\n  }\n  set predicationMode(value) {\n    this.defines.PREDICATION_MODE = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @return {PredicationMode} The mode.\n   */\n  getPredicationMode() {\n    return this.predicationMode;\n  }\n  /**\n   * Sets the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @param {PredicationMode} value - The predication mode.\n   */\n  setPredicationMode(value) {\n    this.predicationMode = value;\n  }\n  /**\n   * The predication buffer.\n   *\n   * @type {Texture}\n   */\n  set predicationBuffer(value) {\n    this.uniforms.predicationBuffer.value = value;\n  }\n  /**\n   * Sets a custom predication buffer.\n   *\n   * @deprecated Use predicationBuffer instead.\n   * @param {Texture} value - The predication buffer.\n   */\n  setPredicationBuffer(value) {\n    this.uniforms.predicationBuffer.value = value;\n  }\n  /**\n   * The predication threshold.\n   *\n   * @type {Number}\n   */\n  get predicationThreshold() {\n    return Number(this.defines.PREDICATION_THRESHOLD);\n  }\n  set predicationThreshold(value) {\n    this.defines.PREDICATION_THRESHOLD = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @return {Number} The threshold.\n   */\n  getPredicationThreshold() {\n    return this.predicationThreshold;\n  }\n  /**\n   * Sets the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @param {Number} value - The threshold.\n   */\n  setPredicationThreshold(value) {\n    this.predicationThreshold = value;\n  }\n  /**\n   * The predication scale. Range: [1.0, 5.0].\n   *\n   * Determines how much the edge detection threshold should be scaled when using predication.\n   *\n   * @type {Boolean|Texture|Number}\n   */\n  get predicationScale() {\n    return Number(this.defines.PREDICATION_SCALE);\n  }\n  set predicationScale(value) {\n    this.defines.PREDICATION_SCALE = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @return {Number} The scale.\n   */\n  getPredicationScale() {\n    return this.predicationScale;\n  }\n  /**\n   * Sets the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @param {Number} value - The scale. Range: [1.0, 5.0].\n   */\n  setPredicationScale(value) {\n    this.predicationScale = value;\n  }\n  /**\n   * The predication strength. Range: [0.0, 1.0].\n   *\n   * Determines how much the edge detection threshold should be decreased locally when using predication.\n   *\n   * @type {Number}\n   */\n  get predicationStrength() {\n    return Number(this.defines.PREDICATION_STRENGTH);\n  }\n  set predicationStrength(value) {\n    this.defines.PREDICATION_STRENGTH = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @return {Number} The strength.\n   */\n  getPredicationStrength() {\n    return this.predicationStrength;\n  }\n  /**\n   * Sets the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @param {Number} value - The strength. Range: [0.0, 1.0].\n   */\n  setPredicationStrength(value) {\n    this.predicationStrength = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/EffectMaterial.js\n\n\n// src/materials/glsl/effect.frag\nvar effect_default = \"#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#define packFloatToRGBA(v) packDepthToRGBA(v)\\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#if DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#if THREE_REVISION >= 137\\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\\n#endif\\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\\n#ifdef ENCODE_OUTPUT\\n#include <colorspace_fragment>\\n#endif\\n#include <dithering_fragment>\\n}\";\n\n// src/materials/glsl/effect.vert\nvar effect_default2 = \"uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/EffectMaterial.js\nvar EffectMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new effect material.\n   *\n   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.\n   * @param {Camera} [camera] - A camera.\n   * @param {Boolean} [dithering=false] - Deprecated.\n   */\n  constructor(shaderParts, defines, uniforms, camera, dithering = false) {\n    super({\n      name: \"EffectMaterial\",\n      defines: {\n        THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n        DEPTH_PACKING: \"0\",\n        ENCODE_OUTPUT: \"1\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n        cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3),\n        aspect: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        time: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      dithering\n    });\n    if (shaderParts) {\n      this.setShaderParts(shaderParts);\n    }\n    if (defines) {\n      this.setDefines(defines);\n    }\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  get depthBuffer() {\n    return this.uniforms.depthBuffer.value;\n  }\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  get depthPacking() {\n    return Number(this.defines.DEPTH_PACKING);\n  }\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * Sets the shader data.\n   *\n   * @param {EffectShaderData} data - The shader data.\n   * @return {EffectMaterial} This material.\n   */\n  setShaderData(data) {\n    this.setShaderParts(data.shaderParts);\n    this.setDefines(data.defines);\n    this.setUniforms(data.uniforms);\n    this.setExtensions(data.extensions);\n  }\n  /**\n   * Sets the shader parts.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.\n   * @return {EffectMaterial} This material.\n   */\n  setShaderParts(shaderParts) {\n    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\");\n    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\");\n    this.fragmentShader = updateFragmentShader(this.fragmentShader);\n    this.needsUpdate = true;\n    return this;\n  }\n  /**\n   * Sets the shader macros.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.\n   * @return {EffectMaterial} This material.\n   */\n  setDefines(defines) {\n    for (const entry of defines.entries()) {\n      this.defines[entry[0]] = entry[1];\n    }\n    this.needsUpdate = true;\n    return this;\n  }\n  /**\n   * Sets the shader uniforms.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.\n   * @return {EffectMaterial} This material.\n   */\n  setUniforms(uniforms) {\n    for (const entry of uniforms.entries()) {\n      this.uniforms[entry[0]] = entry[1];\n    }\n    return this;\n  }\n  /**\n   * Sets the required shader extensions.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Set<WebGLExtension>} extensions - A collection of extensions.\n   * @return {EffectMaterial} This material.\n   */\n  setExtensions(extensions) {\n    this.extensions = {};\n    for (const extension of extensions) {\n      this.extensions[extension] = true;\n    }\n    return this;\n  }\n  /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @type {Boolean}\n   */\n  get encodeOutput() {\n    return this.defines.ENCODE_OUTPUT !== void 0;\n  }\n  set encodeOutput(value) {\n    if (this.encodeOutput !== value) {\n      if (value) {\n        this.defines.ENCODE_OUTPUT = \"1\";\n      } else {\n        delete this.defines.ENCODE_OUTPUT;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @return {Boolean} Whether output encoding is enabled.\n   */\n  isOutputEncodingEnabled(value) {\n    return this.encodeOutput;\n  }\n  /**\n   * Enables or disables output encoding.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @param {Boolean} value - Whether output encoding should be enabled.\n   */\n  setOutputEncodingEnabled(value) {\n    this.encodeOutput = value;\n  }\n  /**\n   * The time in seconds.\n   *\n   * @type {Number}\n   */\n  get time() {\n    return this.uniforms.time.value;\n  }\n  set time(value) {\n    this.uniforms.time.value = value;\n  }\n  /**\n   * Sets the delta time.\n   *\n   * @deprecated Use time instead.\n   * @param {Number} value - The delta time in seconds.\n   */\n  setDeltaTime(value) {\n    this.uniforms.time.value += value;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNear.value = camera.near;\n      this.uniforms.cameraFar.value = camera.far;\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Sets the resolution.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const uniforms = this.uniforms;\n    uniforms.resolution.value.set(width, height);\n    uniforms.texelSize.value.set(1 / width, 1 / height);\n    uniforms.aspect.value = width / height;\n  }\n  /**\n   * An enumeration of shader code placeholders.\n   *\n   * @deprecated Use EffectShaderSection instead.\n   * @type {Object}\n   */\n  static get Section() {\n    return EffectShaderSection;\n  }\n};\n\n// src/materials/GaussianBlurMaterial.js\n\n\n// src/materials/glsl/convolution.gaussian.frag\nvar convolution_gaussian_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform vec2 kernel[STEPS];varying vec2 vOffset;varying vec2 vUv;void main(){vec4 result=texture2D(inputBuffer,vUv)*kernel[0].y;for(int i=1;i<STEPS;++i){vec2 offset=kernel[i].x*vOffset;vec4 c0=texture2D(inputBuffer,vUv+offset);vec4 c1=texture2D(inputBuffer,vUv-offset);result+=(c0+c1)*kernel[i].y;}gl_FragColor=result;\\n#include <colorspace_fragment>\\n}\";\n\n// src/materials/glsl/convolution.gaussian.vert\nvar convolution_gaussian_default2 = \"uniform vec2 texelSize;uniform vec2 direction;uniform float scale;varying vec2 vOffset;varying vec2 vUv;void main(){vOffset=direction*texelSize*scale;vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/GaussianBlurMaterial.js\nvar GaussianBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new convolution material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size.\n   */\n  constructor({ kernelSize = 35 } = {}) {\n    super({\n      name: \"GaussianBlurMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        direction: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_gaussian_default,\n      vertexShader: convolution_gaussian_default2\n    });\n    this.fragmentShader = updateFragmentShader(this.fragmentShader);\n    this._kernelSize = 0;\n    this.kernelSize = kernelSize;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The kernel size.\n   *\n   * @type {Number}\n   */\n  get kernelSize() {\n    return this._kernelSize;\n  }\n  set kernelSize(value) {\n    this._kernelSize = value;\n    this.generateKernel(value);\n  }\n  /**\n   * The blur direction.\n   *\n   * @type {Vector2}\n   */\n  get direction() {\n    return this.uniforms.direction.value;\n  }\n  /**\n   * The blur kernel scale. Values greater than 1.0 may introduce artifacts.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Generates the Gauss kernel.\n   *\n   * @param {KernelSize} kernelSize - The kernel size. Should be an odd number.\n   * @private\n   */\n  generateKernel(kernelSize) {\n    const kernel = new GaussKernel(kernelSize);\n    const steps = kernel.linearSteps;\n    const kernelData = new Float64Array(steps * 2);\n    for (let i = 0, j = 0; i < steps; ++i) {\n      kernelData[j++] = kernel.linearOffsets[i];\n      kernelData[j++] = kernel.linearWeights[i];\n    }\n    this.uniforms.kernel.value = kernelData;\n    this.defines.STEPS = steps.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/GodRaysMaterial.js\n\n\n// src/materials/glsl/convolution.god-rays.frag\nvar convolution_god_rays_default = \"#include <common>\\n#include <dithering_pars_fragment>\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);\\n#include <dithering_fragment>\\n}\";\n\n// src/materials/GodRaysMaterial.js\nvar GodRaysMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new god rays material.\n   *\n   * TODO Remove lightPosition param.\n   * @param {Vector2} lightPosition - Deprecated.\n   */\n  constructor(lightPosition) {\n    super({\n      name: \"GodRaysMaterial\",\n      defines: {\n        SAMPLES_INT: \"60\",\n        SAMPLES_FLOAT: \"60.0\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        lightPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lightPosition),\n        density: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        decay: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        weight: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        exposure: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        clampMax: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_god_rays_default,\n      vertexShader: common_default\n    });\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The screen space position of the light source.\n   *\n   * @type {Vector2}\n   */\n  get lightPosition() {\n    return this.uniforms.lightPosition.value;\n  }\n  /**\n   * Returns the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @return {Vector2} The position.\n   */\n  getLightPosition() {\n    return this.uniforms.lightPosition.value;\n  }\n  /**\n   * Sets the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @param {Vector2} value - The position.\n   */\n  setLightPosition(value) {\n    this.uniforms.lightPosition.value = value;\n  }\n  /**\n   * The density.\n   *\n   * @type {Number}\n   */\n  get density() {\n    return this.uniforms.density.value;\n  }\n  set density(value) {\n    this.uniforms.density.value = value;\n  }\n  /**\n   * Returns the density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The density.\n   */\n  getDensity() {\n    return this.uniforms.density.value;\n  }\n  /**\n   * Sets the density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The density.\n   */\n  setDensity(value) {\n    this.uniforms.density.value = value;\n  }\n  /**\n   * The decay.\n   *\n   * @type {Number}\n   */\n  get decay() {\n    return this.uniforms.decay.value;\n  }\n  set decay(value) {\n    this.uniforms.decay.value = value;\n  }\n  /**\n   * Returns the decay.\n   *\n   * @deprecated Use decay instead.\n   * @return {Number} The decay.\n   */\n  getDecay() {\n    return this.uniforms.decay.value;\n  }\n  /**\n   * Sets the decay.\n   *\n   * @deprecated Use decay instead.\n   * @param {Number} value - The decay.\n   */\n  setDecay(value) {\n    this.uniforms.decay.value = value;\n  }\n  /**\n   * The weight.\n   *\n   * @type {Number}\n   */\n  get weight() {\n    return this.uniforms.weight.value;\n  }\n  set weight(value) {\n    this.uniforms.weight.value = value;\n  }\n  /**\n   * Returns the weight.\n   *\n   * @deprecated Use weight instead.\n   * @return {Number} The weight.\n   */\n  getWeight() {\n    return this.uniforms.weight.value;\n  }\n  /**\n   * Sets the weight.\n   *\n   * @deprecated Use weight instead.\n   * @param {Number} value - The weight.\n   */\n  setWeight(value) {\n    this.uniforms.weight.value = value;\n  }\n  /**\n   * The exposure.\n   *\n   * @type {Number}\n   */\n  get exposure() {\n    return this.uniforms.exposure.value;\n  }\n  set exposure(value) {\n    this.uniforms.exposure.value = value;\n  }\n  /**\n   * Returns the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @return {Number} The exposure.\n   */\n  getExposure() {\n    return this.uniforms.exposure.value;\n  }\n  /**\n   * Sets the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @param {Number} value - The exposure.\n   */\n  setExposure(value) {\n    this.uniforms.exposure.value = value;\n  }\n  /**\n   * The maximum light intensity.\n   *\n   * @type {Number}\n   */\n  get maxIntensity() {\n    return this.uniforms.clampMax.value;\n  }\n  set maxIntensity(value) {\n    this.uniforms.clampMax.value = value;\n  }\n  /**\n   * Returns the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @return {Number} The maximum light intensity.\n   */\n  getMaxIntensity() {\n    return this.uniforms.clampMax.value;\n  }\n  /**\n   * Sets the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @param {Number} value - The maximum light intensity.\n   */\n  setMaxIntensity(value) {\n    this.uniforms.clampMax.value = value;\n  }\n  /**\n   * The amount of samples per pixel.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number(this.defines.SAMPLES_INT);\n  }\n  set samples(value) {\n    const s = Math.floor(value);\n    this.defines.SAMPLES_INT = s.toFixed(0);\n    this.defines.SAMPLES_FLOAT = s.toFixed(1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */\n  getSamples() {\n    return this.samples;\n  }\n  /**\n   * Sets the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */\n  setSamples(value) {\n    this.samples = value;\n  }\n};\n\n// src/materials/LuminanceMaterial.js\n\n\n// src/materials/glsl/luminance.frag\nvar luminance_default = \"#include <common>\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#ifdef RANGE\\nuniform vec2 range;\\n#elif defined(THRESHOLD)\\nuniform float threshold;uniform float smoothing;\\n#endif\\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\\n#ifdef RANGE\\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\\n#elif defined(THRESHOLD)\\nl=smoothstep(threshold,threshold+smoothing,l);\\n#endif\\n#ifdef COLOR\\ngl_FragColor=vec4(texel.rgb*l,l);\\n#else\\ngl_FragColor=vec4(l);\\n#endif\\n}\";\n\n// src/materials/LuminanceMaterial.js\nvar LuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new luminance material.\n   *\n   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.\n   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.\n   */\n  constructor(colorOutput = false, luminanceRange = null) {\n    super({\n      name: \"LuminanceMaterial\",\n      defines: {\n        THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        threshold: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        smoothing: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        range: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: luminance_default,\n      vertexShader: common_default\n    });\n    this.colorOutput = colorOutput;\n    this.luminanceRange = luminanceRange;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The luminance threshold.\n   *\n   * @type {Number}\n   */\n  get threshold() {\n    return this.uniforms.threshold.value;\n  }\n  set threshold(value) {\n    if (this.smoothing > 0 || value > 0) {\n      this.defines.THRESHOLD = \"1\";\n    } else {\n      delete this.defines.THRESHOLD;\n    }\n    this.uniforms.threshold.value = value;\n  }\n  /**\n   * Returns the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @return {Number} The threshold.\n   */\n  getThreshold() {\n    return this.threshold;\n  }\n  /**\n   * Sets the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @param {Number} value - The threshold.\n   */\n  setThreshold(value) {\n    this.threshold = value;\n  }\n  /**\n   * The luminance threshold smoothing.\n   *\n   * @type {Number}\n   */\n  get smoothing() {\n    return this.uniforms.smoothing.value;\n  }\n  set smoothing(value) {\n    if (this.threshold > 0 || value > 0) {\n      this.defines.THRESHOLD = \"1\";\n    } else {\n      delete this.defines.THRESHOLD;\n    }\n    this.uniforms.smoothing.value = value;\n  }\n  /**\n   * Returns the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @return {Number} The smoothing factor.\n   */\n  getSmoothingFactor() {\n    return this.smoothing;\n  }\n  /**\n   * Sets the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @param {Number} value - The smoothing factor.\n   */\n  setSmoothingFactor(value) {\n    this.smoothing = value;\n  }\n  /**\n   * Indicates whether the luminance threshold is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Adjust the threshold or smoothing factor instead.\n   */\n  get useThreshold() {\n    return this.threshold > 0 || this.smoothing > 0;\n  }\n  set useThreshold(value) {\n  }\n  /**\n   * Indicates whether color output is enabled.\n   *\n   * @type {Boolean}\n   */\n  get colorOutput() {\n    return this.defines.COLOR !== void 0;\n  }\n  set colorOutput(value) {\n    if (value) {\n      this.defines.COLOR = \"1\";\n    } else {\n      delete this.defines.COLOR;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether color output is enabled.\n   *\n   * @deprecated Use colorOutput instead.\n   * @return {Boolean} Whether color output is enabled.\n   */\n  isColorOutputEnabled(value) {\n    return this.colorOutput;\n  }\n  /**\n   * Enables or disables color output.\n   *\n   * @deprecated Use colorOutput instead.\n   * @param {Boolean} value - Whether color output should be enabled.\n   */\n  setColorOutputEnabled(value) {\n    this.colorOutput = value;\n  }\n  /**\n   * Indicates whether luminance masking is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get useRange() {\n    return this.luminanceRange !== null;\n  }\n  set useRange(value) {\n    this.luminanceRange = null;\n  }\n  /**\n   * The luminance range. Set to null to disable.\n   *\n   * @type {Boolean}\n   */\n  get luminanceRange() {\n    return this.uniforms.range.value;\n  }\n  set luminanceRange(value) {\n    if (value !== null) {\n      this.defines.RANGE = \"1\";\n    } else {\n      delete this.defines.RANGE;\n    }\n    this.uniforms.range.value = value;\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current luminance range.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @return {Vector2} The luminance range.\n   */\n  getLuminanceRange() {\n    return this.luminanceRange;\n  }\n  /**\n   * Sets a luminance range. Set to null to disable.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @param {Vector2} value - The luminance range.\n   */\n  setLuminanceRange(value) {\n    this.luminanceRange = value;\n  }\n};\n\n// src/materials/MaskMaterial.js\n\n\n// src/materials/glsl/mask.frag\nvar mask_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#ifdef MASK_PRECISION_HIGH\\nuniform mediump sampler2D maskTexture;\\n#else\\nuniform lowp sampler2D maskTexture;\\n#endif\\n#if MASK_FUNCTION != 0\\nuniform float strength;\\n#endif\\nvarying vec2 vUv;void main(){\\n#if COLOR_CHANNEL == 0\\nfloat mask=texture2D(maskTexture,vUv).r;\\n#elif COLOR_CHANNEL == 1\\nfloat mask=texture2D(maskTexture,vUv).g;\\n#elif COLOR_CHANNEL == 2\\nfloat mask=texture2D(maskTexture,vUv).b;\\n#else\\nfloat mask=texture2D(maskTexture,vUv).a;\\n#endif\\n#if MASK_FUNCTION == 0\\n#ifdef INVERTED\\nmask=step(mask,0.0);\\n#else\\nmask=1.0-step(mask,0.0);\\n#endif\\n#else\\nmask=clamp(mask*strength,0.0,1.0);\\n#ifdef INVERTED\\nmask=1.0-mask;\\n#endif\\n#endif\\n#if MASK_FUNCTION == 3\\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\\n#elif MASK_FUNCTION == 2\\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\\n#else\\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\\n#endif\\n}\";\n\n// src/materials/MaskMaterial.js\nvar MaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new mask material.\n   *\n   * @param {Texture} [maskTexture] - The mask texture.\n   */\n  constructor(maskTexture = null) {\n    super({\n      name: \"MaskMaterial\",\n      uniforms: {\n        maskTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maskTexture),\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        strength: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: mask_default,\n      vertexShader: common_default\n    });\n    this.colorChannel = ColorChannel.RED;\n    this.maskFunction = MaskFunction.DISCARD;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The mask texture.\n   *\n   * @type {Texture}\n   */\n  set maskTexture(value) {\n    this.uniforms.maskTexture.value = value;\n    delete this.defines.MASK_PRECISION_HIGH;\n    if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.defines.MASK_PRECISION_HIGH = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the mask texture.\n   *\n   * @deprecated Use maskTexture instead.\n   * @param {Texture} value - The texture.\n   */\n  setMaskTexture(value) {\n    this.maskTexture = value;\n  }\n  /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @type {ColorChannel}\n   */\n  set colorChannel(value) {\n    this.defines.COLOR_CHANNEL = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @deprecated Use colorChannel instead.\n   * @param {ColorChannel} value - The channel.\n   */\n  setColorChannel(value) {\n    this.colorChannel = value;\n  }\n  /**\n   * The masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @type {MaskFunction}\n   */\n  set maskFunction(value) {\n    this.defines.MASK_FUNCTION = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @deprecated Use maskFunction instead.\n   * @param {MaskFunction} value - The function.\n   */\n  setMaskFunction(value) {\n    this.maskFunction = value;\n  }\n  /**\n   * Indicates whether the masking is inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this.defines.INVERTED !== void 0;\n  }\n  set inverted(value) {\n    if (this.inverted && !value) {\n      delete this.defines.INVERTED;\n    } else if (value) {\n      this.defines.INVERTED = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether the masking is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the masking is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Determines whether the masking should be inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the masking should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n  /**\n   * The current mask strength.\n   *\n   * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @type {Number}\n   */\n  get strength() {\n    return this.uniforms.strength.value;\n  }\n  set strength(value) {\n    this.uniforms.strength.value = value;\n  }\n  /**\n   * Returns the current mask strength.\n   *\n   * @deprecated Use strength instead.\n   * @return {Number} The mask strength.\n   */\n  getStrength() {\n    return this.strength;\n  }\n  /**\n   * Sets the mask strength.\n   *\n   * Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @deprecated Use strength instead.\n   * @param {Number} value - The mask strength.\n   */\n  setStrength(value) {\n    this.strength = value;\n  }\n};\n\n// src/materials/OutlineMaterial.js\n\n\n// src/materials/glsl/outline.frag\nvar outline_default = \"uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}\";\n\n// src/materials/glsl/outline.vert\nvar outline_default2 = \"uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/OutlineMaterial.js\nvar OutlineMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new outline material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()) {\n    super({\n      name: \"OutlineMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: outline_default,\n      vertexShader: outline_default2\n    });\n    this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);\n    this.uniforms.maskTexture = this.uniforms.inputBuffer;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/SMAAWeightsMaterial.js\n\n\n// src/materials/glsl/smaa-weights.frag\nvar smaa_weights_default = \"#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\\n#if __VERSION__ < 300\\n#define round(v) floor(v + 0.5)\\n#endif\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\\n#if !defined(DISABLE_CORNER_DETECTION)\\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\\n#endif\\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\\n#if !defined(DISABLE_CORNER_DETECTION)\\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\\n#endif\\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\\n#if !defined(DISABLE_DIAG_DETECTION)\\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\\n#endif\\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\\n#if !defined(DISABLE_DIAG_DETECTION)\\n}else{e.r=0.0;}\\n#endif\\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}\";\n\n// src/materials/glsl/smaa-weights.vert\nvar smaa_weights_default2 = \"uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/SMAAWeightsMaterial.js\nvar SMAAWeightsMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new SMAA weights material.\n   *\n   * @param {Vector2} [texelSize] - The absolute screen texel size.\n   * @param {Vector2} [resolution] - The resolution.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()) {\n    super({\n      name: \"SMAAWeightsMaterial\",\n      defines: {\n        // Configurable settings:\n        MAX_SEARCH_STEPS_INT: \"16\",\n        MAX_SEARCH_STEPS_FLOAT: \"16.0\",\n        MAX_SEARCH_STEPS_DIAG_INT: \"8\",\n        MAX_SEARCH_STEPS_DIAG_FLOAT: \"8.0\",\n        CORNER_ROUNDING: \"25\",\n        CORNER_ROUNDING_NORM: \"0.25\",\n        // Non-configurable settings:\n        AREATEX_MAX_DISTANCE: \"16.0\",\n        AREATEX_MAX_DISTANCE_DIAG: \"20.0\",\n        AREATEX_PIXEL_SIZE: \"(1.0 / vec2(160.0, 560.0))\",\n        AREATEX_SUBTEX_SIZE: \"(1.0 / 7.0)\",\n        SEARCHTEX_SIZE: \"vec2(66.0, 33.0)\",\n        SEARCHTEX_PACKED_SIZE: \"vec2(64.0, 16.0)\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        searchTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        areaTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(resolution),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: smaa_weights_default,\n      vertexShader: smaa_weights_default2\n    });\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The search lookup texture.\n   *\n   * @type {Texture}\n   */\n  get searchTexture() {\n    return this.uniforms.searchTexture.value;\n  }\n  set searchTexture(value) {\n    this.uniforms.searchTexture.value = value;\n  }\n  /**\n   * The area lookup texture.\n   *\n   * @type {Texture}\n   */\n  get areaTexture() {\n    return this.uniforms.areaTexture.value;\n  }\n  set areaTexture(value) {\n    this.uniforms.areaTexture.value = value;\n  }\n  /**\n   * Sets the search and area lookup textures.\n   *\n   * @deprecated Use searchTexture and areaTexture instead.\n   * @param {Texture} search - The search lookup texture.\n   * @param {Texture} area - The area lookup texture.\n   */\n  setLookupTextures(search, area2) {\n    this.searchTexture = search;\n    this.areaTexture = area2;\n  }\n  /**\n   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   * Range: [0, 112].\n   *\n   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is\n   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).\n   *\n   * @type {Number}\n   */\n  get orthogonalSearchSteps() {\n    return Number(this.defines.MAX_SEARCH_STEPS_INT);\n  }\n  set orthogonalSearchSteps(value) {\n    const s = Math.min(Math.max(value, 0), 112);\n    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed(\"0\");\n    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed(\"1\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use orthogonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 112].\n   */\n  setOrthogonalSearchSteps(value) {\n    this.orthogonalSearchSteps = value;\n  }\n  /**\n   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search\n   * jumps one pixel at a time. Range: [0, 20].\n   *\n   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a\n   * significant impact on older machines.\n   *\n   * @type {Number}\n   */\n  get diagonalSearchSteps() {\n    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);\n  }\n  set diagonalSearchSteps(value) {\n    const s = Math.min(Math.max(value, 0), 20);\n    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed(\"0\");\n    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed(\"1\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use diagonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 20].\n   */\n  setDiagonalSearchSteps(value) {\n    this.diagonalSearchSteps = value;\n  }\n  /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @type {Boolean}\n   */\n  get diagonalDetection() {\n    return this.defines.DISABLE_DIAG_DETECTION === void 0;\n  }\n  set diagonalDetection(value) {\n    if (value) {\n      delete this.defines.DISABLE_DIAG_DETECTION;\n    } else {\n      this.defines.DISABLE_DIAG_DETECTION = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @return {Boolean} Whether diagonal pattern detection is enabled.\n   */\n  isDiagonalDetectionEnabled() {\n    return this.diagonalDetection;\n  }\n  /**\n   * Enables or disables diagonal pattern detection.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.\n   */\n  setDiagonalDetectionEnabled(value) {\n    this.diagonalDetection = value;\n  }\n  /**\n   * Specifies how much sharp corners will be rounded. Range: [0, 100].\n   *\n   * @type {Number}\n   */\n  get cornerRounding() {\n    return Number(this.defines.CORNER_ROUNDING);\n  }\n  set cornerRounding(value) {\n    const r = Math.min(Math.max(value, 0), 100);\n    this.defines.CORNER_ROUNDING = r.toFixed(\"4\");\n    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed(\"4\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Specifies how much sharp corners will be rounded.\n   *\n   * @deprecated Use cornerRounding instead.\n   * @param {Number} value - The corner rounding amount. Range: [0, 100].\n   */\n  setCornerRounding(value) {\n    this.cornerRounding = value;\n  }\n  /**\n   * Indicates whether corner detection is enabled.\n   *\n   * @type {Number}\n   */\n  get cornerDetection() {\n    return this.defines.DISABLE_CORNER_DETECTION === void 0;\n  }\n  set cornerDetection(value) {\n    if (value) {\n      delete this.defines.DISABLE_CORNER_DETECTION;\n    } else {\n      this.defines.DISABLE_CORNER_DETECTION = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether corner rounding is enabled.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @return {Boolean} Whether corner rounding is enabled.\n   */\n  isCornerRoundingEnabled() {\n    return this.cornerDetection;\n  }\n  /**\n   * Enables or disables corner rounding.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @param {Boolean} value - Whether corner rounding should be enabled.\n   */\n  setCornerRoundingEnabled(value) {\n    this.cornerDetection = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const uniforms = this.uniforms;\n    uniforms.texelSize.value.set(1 / width, 1 / height);\n    uniforms.resolution.value.set(width, height);\n  }\n};\n\n// src/materials/SSAOMaterial.js\n\n\n// src/materials/glsl/ssao.frag\nvar ssao_default = \"#include <common>\\n#include <packing>\\n#ifdef NORMAL_DEPTH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\\n#else\\nuniform lowp sampler2D normalBuffer;\\n#if DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}\\n#endif\\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#endif\\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\\n#else\\nfloat linearSampleDepth=sampleDepth;\\n#endif\\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\\n#ifdef NORMAL_DEPTH\\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\\n#else\\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\\n#endif\\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\\n#else\\nfloat linearDepth=depth;\\n#endif\\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\\n#ifdef LEGACY_INTENSITY\\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\\n#endif\\n}gl_FragColor.r=ao;}\";\n\n// src/materials/glsl/ssao.vert\nvar ssao_default2 = \"uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/SSAOMaterial.js\nvar SSAOMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new SSAO material.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  constructor(camera) {\n    super({\n      name: \"SSAOMaterial\",\n      defines: {\n        SAMPLES_INT: \"0\",\n        INV_SAMPLES_FLOAT: \"0.0\",\n        SPIRAL_TURNS: \"0.0\",\n        RADIUS: \"1.0\",\n        RADIUS_SQ: \"1.0\",\n        DISTANCE_SCALING: \"1\",\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        noiseTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        inverseProjectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n        projectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        distanceCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        proximityCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        noiseScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        minRadiusScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.33),\n        intensity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        fade: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n        bias: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: ssao_default,\n      vertexShader: ssao_default2\n    });\n    this.copyCameraSettings(camera);\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.r = 1;\n  }\n  /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get near() {\n    return this.uniforms.cameraNearFar.value.x;\n  }\n  /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get far() {\n    return this.uniforms.cameraNearFar.value.y;\n  }\n  /**\n   * A combined normal-depth buffer.\n   *\n   * @type {Texture}\n   */\n  set normalDepthBuffer(value) {\n    this.uniforms.normalDepthBuffer.value = value;\n    if (value !== null) {\n      this.defines.NORMAL_DEPTH = \"1\";\n    } else {\n      delete this.defines.NORMAL_DEPTH;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the combined normal-depth buffer.\n   *\n   * @deprecated Use normalDepthBuffer instead.\n   * @param {Number} value - The buffer.\n   */\n  setNormalDepthBuffer(value) {\n    this.normalDepthBuffer = value;\n  }\n  /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */\n  set normalBuffer(value) {\n    this.uniforms.normalBuffer.value = value;\n  }\n  /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Number} value - The buffer.\n   */\n  setNormalBuffer(value) {\n    this.uniforms.normalBuffer.value = value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The noise texture.\n   *\n   * @type {Texture}\n   */\n  set noiseTexture(value) {\n    this.uniforms.noiseTexture.value = value;\n  }\n  /**\n   * Sets the noise texture.\n   *\n   * @deprecated Use noiseTexture instead.\n   * @param {Number} value - The texture.\n   */\n  setNoiseTexture(value) {\n    this.uniforms.noiseTexture.value = value;\n  }\n  /**\n   * The sample count.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number(this.defines.SAMPLES_INT);\n  }\n  set samples(value) {\n    this.defines.SAMPLES_INT = value.toFixed(0);\n    this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */\n  getSamples() {\n    return this.samples;\n  }\n  /**\n   * Sets the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */\n  setSamples(value) {\n    this.samples = value;\n  }\n  /**\n   * The sampling spiral ring count.\n   *\n   * @type {Number}\n   */\n  get rings() {\n    return Number(this.defines.SPIRAL_TURNS);\n  }\n  set rings(value) {\n    this.defines.SPIRAL_TURNS = value.toFixed(1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @return {Number} The radius.\n   */\n  getRings() {\n    return this.rings;\n  }\n  /**\n   * Sets the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @param {Number} value - The radius.\n   */\n  setRings(value) {\n    this.rings = value;\n  }\n  /**\n   * The intensity.\n   *\n   * @type {Number}\n   * @deprecated Use SSAOEffect.intensity instead.\n   */\n  get intensity() {\n    return this.uniforms.intensity.value;\n  }\n  set intensity(value) {\n    this.uniforms.intensity.value = value;\n    if (this.defines.LEGACY_INTENSITY === void 0) {\n      this.defines.LEGACY_INTENSITY = \"1\";\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Returns the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @return {Number} The intensity.\n   */\n  getIntensity() {\n    return this.uniforms.intensity.value;\n  }\n  /**\n   * Sets the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @param {Number} value - The intensity.\n   */\n  setIntensity(value) {\n    this.uniforms.intensity.value = value;\n  }\n  /**\n   * The depth fade factor.\n   *\n   * @type {Number}\n   */\n  get fade() {\n    return this.uniforms.fade.value;\n  }\n  set fade(value) {\n    this.uniforms.fade.value = value;\n  }\n  /**\n   * Returns the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @return {Number} The fade factor.\n   */\n  getFade() {\n    return this.uniforms.fade.value;\n  }\n  /**\n   * Sets the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @param {Number} value - The fade factor.\n   */\n  setFade(value) {\n    this.uniforms.fade.value = value;\n  }\n  /**\n   * The depth bias. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get bias() {\n    return this.uniforms.bias.value;\n  }\n  set bias(value) {\n    this.uniforms.bias.value = value;\n  }\n  /**\n   * Returns the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @return {Number} The bias.\n   */\n  getBias() {\n    return this.uniforms.bias.value;\n  }\n  /**\n   * Sets the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @param {Number} value - The bias.\n   */\n  setBias(value) {\n    this.uniforms.bias.value = value;\n  }\n  /**\n   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get minRadiusScale() {\n    return this.uniforms.minRadiusScale.value;\n  }\n  set minRadiusScale(value) {\n    this.uniforms.minRadiusScale.value = value;\n  }\n  /**\n   * Returns the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @return {Number} The minimum radius scale.\n   */\n  getMinRadiusScale() {\n    return this.uniforms.minRadiusScale.value;\n  }\n  /**\n   * Sets the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @param {Number} value - The minimum radius scale.\n   */\n  setMinRadiusScale(value) {\n    this.uniforms.minRadiusScale.value = value;\n  }\n  /**\n   * Updates the absolute radius.\n   *\n   * @private\n   */\n  updateRadius() {\n    const radius = this.r * this.resolution.height;\n    this.defines.RADIUS = radius.toFixed(11);\n    this.defines.RADIUS_SQ = (radius * radius).toFixed(11);\n    this.needsUpdate = true;\n  }\n  /**\n   * The occlusion sampling radius. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get radius() {\n    return this.r;\n  }\n  set radius(value) {\n    this.r = Math.min(Math.max(value, 1e-6), 1);\n    this.updateRadius();\n  }\n  /**\n   * Returns the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @return {Number} The radius.\n   */\n  getRadius() {\n    return this.radius;\n  }\n  /**\n   * Sets the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @param {Number} value - The radius. Range [1e-6, 1.0].\n   */\n  setRadius(value) {\n    this.radius = value;\n  }\n  /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get distanceScaling() {\n    return true;\n  }\n  set distanceScaling(value) {\n  }\n  /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @deprecated\n   * @return {Boolean} Whether distance scaling is enabled.\n   */\n  isDistanceScalingEnabled() {\n    return this.distanceScaling;\n  }\n  /**\n   * Enables or disables distance-based radius scaling.\n   *\n   * @deprecated\n   * @param {Boolean} value - Whether distance scaling should be enabled.\n   */\n  setDistanceScalingEnabled(value) {\n    this.distanceScaling = value;\n  }\n  /**\n   * The occlusion distance threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get distanceThreshold() {\n    return this.uniforms.distanceCutoff.value.x;\n  }\n  set distanceThreshold(value) {\n    this.uniforms.distanceCutoff.value.set(\n      Math.min(Math.max(value, 0), 1),\n      Math.min(Math.max(value + this.distanceFalloff, 0), 1)\n    );\n  }\n  /**\n   * The occlusion distance threshold in world units.\n   *\n   * @type {Number}\n   */\n  get worldDistanceThreshold() {\n    return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);\n  }\n  set worldDistanceThreshold(value) {\n    this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * The occlusion distance falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get distanceFalloff() {\n    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;\n  }\n  set distanceFalloff(value) {\n    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);\n  }\n  /**\n   * The occlusion distance falloff in world units.\n   *\n   * @type {Number}\n   */\n  get worldDistanceFalloff() {\n    return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);\n  }\n  set worldDistanceFalloff(value) {\n    this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use distanceThreshold and distanceFalloff instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setDistanceCutoff(threshold, falloff) {\n    this.uniforms.distanceCutoff.value.set(\n      Math.min(Math.max(threshold, 0), 1),\n      Math.min(Math.max(threshold + falloff, 0), 1)\n    );\n  }\n  /**\n   * The occlusion proximity threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get proximityThreshold() {\n    return this.uniforms.proximityCutoff.value.x;\n  }\n  set proximityThreshold(value) {\n    this.uniforms.proximityCutoff.value.set(\n      Math.min(Math.max(value, 0), 1),\n      Math.min(Math.max(value + this.proximityFalloff, 0), 1)\n    );\n  }\n  /**\n   * The occlusion proximity threshold in world units.\n   *\n   * @type {Number}\n   */\n  get worldProximityThreshold() {\n    return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);\n  }\n  set worldProximityThreshold(value) {\n    this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * The occlusion proximity falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get proximityFalloff() {\n    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;\n  }\n  set proximityFalloff(value) {\n    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);\n  }\n  /**\n   * The occlusion proximity falloff in world units.\n   *\n   * @type {Number}\n   */\n  get worldProximityFalloff() {\n    return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);\n  }\n  set worldProximityFalloff(value) {\n    this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use proximityThreshold and proximityFalloff instead.\n   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setProximityCutoff(threshold, falloff) {\n    this.uniforms.proximityCutoff.value.set(\n      Math.min(Math.max(threshold, 0), 1),\n      Math.min(Math.max(threshold + falloff, 0), 1)\n    );\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n      this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);\n      this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const uniforms = this.uniforms;\n    const noiseTexture = uniforms.noiseTexture.value;\n    if (noiseTexture !== null) {\n      uniforms.noiseScale.value.set(\n        width / noiseTexture.image.width,\n        height / noiseTexture.image.height\n      );\n    }\n    uniforms.texelSize.value.set(1 / width, 1 / height);\n    this.resolution.set(width, height);\n    this.updateRadius();\n  }\n};\n\n// src/materials/TiltShiftBlurMaterial.js\n\n\n// src/materials/glsl/convolution.tilt-shift.frag\nvar convolution_tilt_shift_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\\n#include <colorspace_fragment>\\n}\";\n\n// src/materials/glsl/convolution.tilt-shift.vert\nvar convolution_tilt_shift_default2 = \"uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/TiltShiftBlurMaterial.js\nvar TiltShiftBlurMaterial = class extends KawaseBlurMaterial {\n  /**\n   * Constructs a new tilt shift blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   */\n  constructor({\n    kernelSize = KernelSize.MEDIUM,\n    offset = 0,\n    rotation = 0,\n    focusArea = 0.4,\n    feather = 0.3\n  } = {}) {\n    super();\n    this.fragmentShader = convolution_tilt_shift_default;\n    this.vertexShader = convolution_tilt_shift_default2;\n    this.kernelSize = kernelSize;\n    this.fragmentShader = updateFragmentShader(this.fragmentShader);\n    this.uniforms.aspect = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1);\n    this.uniforms.rotation = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    this.uniforms.maskParams = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4());\n    this._offset = offset;\n    this._focusArea = focusArea;\n    this._feather = feather;\n    this.rotation = rotation;\n    this.updateParams();\n  }\n  /**\n   * The relative offset of the focus area.\n   *\n   * @private\n   */\n  updateParams() {\n    const params = this.uniforms.maskParams.value;\n    const a = Math.max(this.focusArea, 0);\n    const b = Math.max(a - this.feather, 0);\n    params.set(\n      this.offset - a,\n      this.offset - b,\n      this.offset + a,\n      this.offset + b\n    );\n  }\n  /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */\n  get rotation() {\n    return Math.acos(this.uniforms.rotation.value.x);\n  }\n  set rotation(value) {\n    this.uniforms.rotation.value.set(Math.cos(value), Math.sin(value));\n  }\n  /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */\n  get offset() {\n    return this._offset;\n  }\n  set offset(value) {\n    this._offset = value;\n    this.updateParams();\n  }\n  /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */\n  get focusArea() {\n    return this._focusArea;\n  }\n  set focusArea(value) {\n    this._focusArea = value;\n    this.updateParams();\n  }\n  /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */\n  get feather() {\n    return this._feather;\n  }\n  set feather(value) {\n    this._feather = value;\n    this.updateParams();\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    super.setSize(width, height);\n    this.uniforms.aspect.value = width / height;\n  }\n};\n\n// src/materials/UpsamplingMaterial.js\n\n\n// src/materials/glsl/convolution.upsampling.frag\nvar convolution_upsampling_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\\n#endif\\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\\n#include <colorspace_fragment>\\n}\";\n\n// src/materials/glsl/convolution.upsampling.vert\nvar convolution_upsampling_default2 = \"uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}\";\n\n// src/materials/UpsamplingMaterial.js\nvar UpsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new upsampling material.\n   */\n  constructor() {\n    super({\n      name: \"UpsamplingMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        supportBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        radius: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.85)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_upsampling_default,\n      vertexShader: convolution_upsampling_default2\n    });\n    this.fragmentShader = updateFragmentShader(this.fragmentShader);\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * A support buffer.\n   *\n   * @type {Texture}\n   */\n  set supportBuffer(value) {\n    this.uniforms.supportBuffer.value = value;\n  }\n  /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */\n  get radius() {\n    return this.uniforms.radius.value;\n  }\n  set radius(value) {\n    this.uniforms.radius.value = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/passes/CopyPass.js\n\n\n// src/passes/Pass.js\n\nvar dummyCamera = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Camera();\nvar geometry = null;\nfunction getFullscreenTriangle() {\n  if (geometry === null) {\n    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);\n    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    if (geometry.setAttribute !== void 0) {\n      geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(uvs, 2));\n    } else {\n      geometry.addAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(vertices, 3));\n      geometry.addAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(uvs, 2));\n    }\n  }\n  return geometry;\n}\nvar Pass = class _Pass {\n  /**\n   * Constructs a new pass.\n   *\n   * @param {String} [name] - The name of this pass. Does not have to be unique.\n   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.\n   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.\n   */\n  constructor(name = \"Pass\", scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene(), camera = dummyCamera) {\n    this.name = name;\n    this.renderer = null;\n    this.scene = scene;\n    this.camera = camera;\n    this.screen = null;\n    this.rtt = true;\n    this.needsSwap = true;\n    this.needsDepthTexture = false;\n    this.enabled = true;\n  }\n  /**\n   * Sets the render to screen flag.\n   *\n   * If this flag is changed, the fullscreen material will be updated as well.\n   *\n   * @type {Boolean}\n   */\n  get renderToScreen() {\n    return !this.rtt;\n  }\n  set renderToScreen(value) {\n    if (this.rtt === value) {\n      const material = this.fullscreenMaterial;\n      if (material !== null) {\n        material.needsUpdate = true;\n      }\n      this.rtt = !value;\n    }\n  }\n  /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */\n  set mainScene(value) {\n  }\n  /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */\n  set mainCamera(value) {\n  }\n  /**\n   * Sets the renderer\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */\n  setRenderer(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * Indicates whether this pass is enabled.\n   *\n   * @deprecated Use enabled instead.\n   * @return {Boolean} Whether this pass is enabled.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables this pass.\n   *\n   * @deprecated Use enabled instead.\n   * @param {Boolean} value - Whether the pass should be enabled.\n   */\n  setEnabled(value) {\n    this.enabled = value;\n  }\n  /**\n   * The fullscreen material.\n   *\n   * @type {Material}\n   */\n  get fullscreenMaterial() {\n    return this.screen !== null ? this.screen.material : null;\n  }\n  set fullscreenMaterial(value) {\n    let screen = this.screen;\n    if (screen !== null) {\n      screen.material = value;\n    } else {\n      screen = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(getFullscreenTriangle(), value);\n      screen.frustumCulled = false;\n      if (this.scene === null) {\n        this.scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n      }\n      this.scene.add(screen);\n      this.screen = screen;\n    }\n  }\n  /**\n   * Returns the current fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @return {Material} The current fullscreen material, or null if there is none.\n   */\n  getFullscreenMaterial() {\n    return this.fullscreenMaterial;\n  }\n  /**\n   * Sets the fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @protected\n   * @param {Material} value - A fullscreen material.\n   */\n  setFullscreenMaterial(value) {\n    this.fullscreenMaterial = value;\n  }\n  /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */\n  getDepthTexture() {\n    return null;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * This method will be called automatically by the {@link EffectComposer}.\n   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n  }\n  /**\n   * Renders this pass.\n   *\n   * This is an abstract method that must be overridden.\n   *\n   * @abstract\n   * @throws {Error} An error is thrown if the method is not overridden.\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    throw new Error(\"Render method not implemented!\");\n  }\n  /**\n   * Sets the size.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * This method is called when this pass is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n  }\n  /**\n   * Performs a shallow search for disposable properties and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free\n   * memory when you're certain that you don't need this pass anymore.\n   */\n  dispose() {\n    for (const key of Object.keys(this)) {\n      const property = this[key];\n      const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof _Pass;\n      if (isDisposable) {\n        this[key].dispose();\n      }\n    }\n  }\n};\n\n// src/passes/CopyPass.js\nvar CopyPass = class extends Pass {\n  /**\n   * Constructs a new save pass.\n   *\n   * @param {WebGLRenderTarget} [renderTarget] - A render target.\n   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.\n   */\n  constructor(renderTarget, autoResize = true) {\n    super(\"CopyPass\");\n    this.fullscreenMaterial = new CopyMaterial();\n    this.needsSwap = false;\n    this.renderTarget = renderTarget;\n    if (renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n        minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n        magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n        stencilBuffer: false,\n        depthBuffer: false\n      });\n      this.renderTarget.texture.name = \"CopyPass.Target\";\n    }\n    this.autoResize = autoResize;\n  }\n  /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @type {Boolean}\n   */\n  get resize() {\n    return this.autoResize;\n  }\n  set resize(value) {\n    this.autoResize = value;\n  }\n  /**\n   * The output texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the output texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @param {Boolean} value - Whether the render target size should be updated automatically.\n   */\n  setAutoResizeEnabled(value) {\n    this.autoResize = value;\n  }\n  /**\n   * Saves the input buffer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    if (this.autoResize) {\n      this.renderTarget.setSize(width, height);\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/passes/AdaptiveLuminancePass.js\nvar AdaptiveLuminancePass = class extends Pass {\n  /**\n   * Constructs a new adaptive luminance pass.\n   *\n   * @param {Texture} luminanceBuffer - A buffer that contains the current scene luminance.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */\n  constructor(luminanceBuffer, { minLuminance = 0.01, adaptationRate = 1 } = {}) {\n    super(\"AdaptiveLuminancePass\");\n    this.fullscreenMaterial = new AdaptiveLuminanceMaterial();\n    this.needsSwap = false;\n    this.renderTargetPrevious = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      depthBuffer: false\n    });\n    this.renderTargetPrevious.texture.name = \"Luminance.Previous\";\n    const material = this.fullscreenMaterial;\n    material.luminanceBuffer0 = this.renderTargetPrevious.texture;\n    material.luminanceBuffer1 = luminanceBuffer;\n    material.minLuminance = minLuminance;\n    material.adaptationRate = adaptationRate;\n    this.renderTargetAdapted = this.renderTargetPrevious.clone();\n    this.renderTargetAdapted.texture.name = \"Luminance.Adapted\";\n    this.copyPass = new CopyPass(this.renderTargetPrevious, false);\n  }\n  /**\n   * The adaptive luminance texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTargetAdapted.texture;\n  }\n  /**\n   * Returns the adaptive 1x1 luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTargetAdapted.texture;\n  }\n  /**\n   * Sets the 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the main luminance texture which contains the downsampled\n   * average scene luminance.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.mipLevel1x1 instead.\n   */\n  set mipLevel1x1(value) {\n    this.fullscreenMaterial.mipLevel1x1 = value;\n  }\n  /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */\n  get adaptationRate() {\n    return this.fullscreenMaterial.adaptationRate;\n  }\n  /**\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */\n  set adaptationRate(value) {\n    this.fullscreenMaterial.adaptationRate = value;\n  }\n  /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    this.fullscreenMaterial.deltaTime = deltaTime;\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);\n    renderer.render(this.scene, this.camera);\n    this.copyPass.render(renderer, this.renderTargetAdapted);\n  }\n};\n\n// src/passes/BoxBlurPass.js\n\nvar BoxBlurPass = class extends Pass {\n  /**\n   * Constructs a new box blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=5] - Must be an odd number. The sizes 3 and 5 use optimized code paths.\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    kernelSize = 5,\n    iterations = 1,\n    bilateral = false,\n    resolutionScale = 1,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super(\"BoxBlurPass\");\n    this.needsDepthTexture = bilateral;\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"Blur.Target.A\";\n    this.renderTargetB = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetB.texture.name = \"Blur.Target.B\";\n    this.blurMaterial = new BoxBlurMaterial({ bilateral, kernelSize });\n    this.copyMaterial = new CopyMaterial();\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.iterations = iterations;\n  }\n  set mainCamera(value) {\n    this.blurMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.blurMaterial.depthBuffer = depthTexture;\n    this.blurMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    const blurMaterial = this.blurMaterial;\n    this.fullscreenMaterial = blurMaterial;\n    let previousBuffer = inputBuffer;\n    for (let i = 0, l = Math.max(this.iterations, 1); i < l; ++i) {\n      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      blurMaterial.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(buffer);\n      renderer.render(scene, camera);\n      previousBuffer = buffer;\n    }\n    this.copyMaterial.inputBuffer = previousBuffer.texture;\n    this.fullscreenMaterial = this.copyMaterial;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.blurMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurMaterial.maxVaryingVectors = renderer.capabilities.maxVaryings;\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/passes/ClearMaskPass.js\nvar ClearMaskPass = class extends Pass {\n  /**\n   * Constructs a new clear mask pass.\n   */\n  constructor() {\n    super(\"ClearMaskPass\", null, null);\n    this.needsSwap = false;\n  }\n  /**\n   * Disables the global stencil test.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const stencil = renderer.state.buffers.stencil;\n    stencil.setLocked(false);\n    stencil.setTest(false);\n  }\n};\n\n// src/passes/ClearPass.js\n\nvar color = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar ClearPass = class extends Pass {\n  /**\n   * Constructs a new clear pass.\n   *\n   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.\n   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.\n   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.\n   */\n  constructor(color2 = true, depth = true, stencil = false) {\n    super(\"ClearPass\", null, null);\n    this.needsSwap = false;\n    this.color = color2;\n    this.depth = depth;\n    this.stencil = stencil;\n    this.overrideClearColor = null;\n    this.overrideClearAlpha = -1;\n  }\n  /**\n   * Sets the clear flags.\n   *\n   * @param {Boolean} color - Whether the color buffer should be cleared.\n   * @param {Boolean} depth - Whether the depth buffer should be cleared.\n   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.\n   */\n  setClearFlags(color2, depth, stencil) {\n    this.color = color2;\n    this.depth = depth;\n    this.stencil = stencil;\n  }\n  /**\n   * Returns the override clear color. Default is null.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @return {Color} The clear color.\n   */\n  getOverrideClearColor() {\n    return this.overrideClearColor;\n  }\n  /**\n   * Sets the override clear color.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @param {Color} value - The clear color.\n   */\n  setOverrideClearColor(value) {\n    this.overrideClearColor = value;\n  }\n  /**\n   * Returns the override clear alpha. Default is -1.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @return {Number} The clear alpha.\n   */\n  getOverrideClearAlpha() {\n    return this.overrideClearAlpha;\n  }\n  /**\n   * Sets the override clear alpha.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @param {Number} value - The clear alpha.\n   */\n  setOverrideClearAlpha(value) {\n    this.overrideClearAlpha = value;\n  }\n  /**\n   * Clears the input buffer or the screen.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const overrideClearColor = this.overrideClearColor;\n    const overrideClearAlpha = this.overrideClearAlpha;\n    const clearAlpha = renderer.getClearAlpha();\n    const hasOverrideClearColor = overrideClearColor !== null;\n    const hasOverrideClearAlpha = overrideClearAlpha >= 0;\n    if (hasOverrideClearColor) {\n      renderer.getClearColor(color);\n      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);\n    } else if (hasOverrideClearAlpha) {\n      renderer.setClearAlpha(overrideClearAlpha);\n    }\n    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);\n    renderer.clear(this.color, this.depth, this.stencil);\n    if (hasOverrideClearColor) {\n      renderer.setClearColor(color, clearAlpha);\n    } else if (hasOverrideClearAlpha) {\n      renderer.setClearAlpha(clearAlpha);\n    }\n  }\n};\n\n// src/passes/DepthPass.js\n\n\n// src/passes/RenderPass.js\nvar RenderPass = class extends Pass {\n  /**\n   * Constructs a new render pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Material} [overrideMaterial=null] - An override material.\n   */\n  constructor(scene, camera, overrideMaterial = null) {\n    super(\"RenderPass\", scene, camera);\n    this.needsSwap = false;\n    this.clearPass = new ClearPass();\n    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);\n    this.ignoreBackground = false;\n    this.skipShadowMapUpdate = false;\n    this.selection = null;\n  }\n  set mainScene(value) {\n    this.scene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n  }\n  get renderToScreen() {\n    return super.renderToScreen;\n  }\n  set renderToScreen(value) {\n    super.renderToScreen = value;\n    this.clearPass.renderToScreen = value;\n  }\n  /**\n   * The current override material.\n   *\n   * @type {Material}\n   */\n  get overrideMaterial() {\n    const manager = this.overrideMaterialManager;\n    return manager !== null ? manager.material : null;\n  }\n  set overrideMaterial(value) {\n    const manager = this.overrideMaterialManager;\n    if (value !== null) {\n      if (manager !== null) {\n        manager.setMaterial(value);\n      } else {\n        this.overrideMaterialManager = new OverrideMaterialManager(value);\n      }\n    } else if (manager !== null) {\n      manager.dispose();\n      this.overrideMaterialManager = null;\n    }\n  }\n  /**\n   * Returns the current override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} The material.\n   */\n  getOverrideMaterial() {\n    return this.overrideMaterial;\n  }\n  /**\n   * Sets the override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} value - The material.\n   */\n  setOverrideMaterial(value) {\n    this.overrideMaterial = value;\n  }\n  /**\n   * Indicates whether the target buffer should be cleared before rendering.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */\n  get clear() {\n    return this.clearPass.enabled;\n  }\n  set clear(value) {\n    this.clearPass.enabled = value;\n  }\n  /**\n   * Returns the selection. Default is `null` (no restriction).\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */\n  getSelection() {\n    return this.selection;\n  }\n  /**\n   * Sets the selection. Set to `null` to disable.\n   *\n   * @deprecated Use selection instead.\n   * @param {Selection} value - The selection.\n   */\n  setSelection(value) {\n    this.selection = value;\n  }\n  /**\n   * Indicates whether the scene background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the scene background is disabled.\n   */\n  isBackgroundDisabled() {\n    return this.ignoreBackground;\n  }\n  /**\n   * Enables or disables the scene background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the scene background should be disabled.\n   */\n  setBackgroundDisabled(value) {\n    this.ignoreBackground = value;\n  }\n  /**\n   * Indicates whether the shadow map auto update is disabled.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @return {Boolean} Whether the shadow map update is disabled.\n   */\n  isShadowMapDisabled() {\n    return this.skipShadowMapUpdate;\n  }\n  /**\n   * Enables or disables the shadow map auto update.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @param {Boolean} value - Whether the shadow map auto update should be disabled.\n   */\n  setShadowMapDisabled(value) {\n    this.skipShadowMapUpdate = value;\n  }\n  /**\n   * Returns the clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */\n  getClearPass() {\n    return this.clearPass;\n  }\n  /**\n   * Renders the scene.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const selection = this.selection;\n    const mask = camera.layers.mask;\n    const background = scene.background;\n    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;\n    const renderTarget = this.renderToScreen ? null : inputBuffer;\n    if (selection !== null) {\n      camera.layers.set(selection.getLayer());\n    }\n    if (this.skipShadowMapUpdate) {\n      renderer.shadowMap.autoUpdate = false;\n    }\n    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {\n      scene.background = null;\n    }\n    if (this.clearPass.enabled) {\n      this.clearPass.render(renderer, inputBuffer);\n    }\n    renderer.setRenderTarget(renderTarget);\n    if (this.overrideMaterialManager !== null) {\n      this.overrideMaterialManager.render(renderer, scene, camera);\n    } else {\n      renderer.render(scene, camera);\n    }\n    camera.layers.mask = mask;\n    scene.background = background;\n    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;\n  }\n};\n\n// src/passes/DepthPass.js\nvar DepthPass = class extends Pass {\n  /**\n   * Constructs a new depth pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(scene, camera, {\n    renderTarget,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"DepthPass\");\n    this.needsSwap = false;\n    this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({\n      depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking\n    }));\n    const renderPass = this.renderPass;\n    renderPass.skipShadowMapUpdate = true;\n    renderPass.ignoreBackground = true;\n    const clearPass = renderPass.clearPass;\n    clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    clearPass.overrideClearAlpha = 1;\n    this.renderTarget = renderTarget;\n    if (this.renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n        minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n        magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n      });\n      this.renderTarget.texture.name = \"DepthPass.Target\";\n    }\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  set mainScene(value) {\n    this.renderPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.renderPass.mainCamera = value;\n  }\n  /**\n   * The depth texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Renders the scene depth.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const renderTarget = this.renderToScreen ? null : this.renderTarget;\n    this.renderPass.render(renderer, renderTarget);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n  }\n};\n\n// src/passes/DepthDownsamplingPass.js\n\nvar DepthDownsamplingPass = class extends Pass {\n  /**\n   * Constructs a new depth downsampling pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor({\n    normalBuffer = null,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"DepthDownsamplingPass\");\n    const material = new DepthDownsamplingMaterial();\n    material.normalBuffer = normalBuffer;\n    this.fullscreenMaterial = material;\n    this.needsDepthTexture = true;\n    this.needsSwap = false;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      depthBuffer: false,\n      type: three__WEBPACK_IMPORTED_MODULE_0__.FloatType\n    });\n    this.renderTarget.texture.name = \"DepthDownsamplingPass.Target\";\n    this.renderTarget.texture.generateMipmaps = false;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  /**\n   * The normal(RGB) + depth(A) texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the normal(RGB) + depth(A) texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.fullscreenMaterial.depthBuffer = depthTexture;\n    this.fullscreenMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Downsamples depth and scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n    this.fullscreenMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    const gl = renderer.getContext();\n    const renderable = gl.getExtension(\"EXT_color_buffer_float\") || gl.getExtension(\"EXT_color_buffer_half_float\");\n    if (!renderable) {\n      throw new Error(\"Rendering to float texture is not supported.\");\n    }\n  }\n};\n\n// src/passes/DepthPickingPass.js\n\n\n// src/passes/DepthCopyPass.js\n\nvar DepthCopyPass = class extends Pass {\n  /**\n   * Constructs a new depth save pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The output depth packing.\n   */\n  constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking } = {}) {\n    super(\"DepthCopyPass\");\n    const material = new DepthCopyMaterial();\n    material.outputDepthPacking = depthPacking;\n    this.fullscreenMaterial = material;\n    this.needsDepthTexture = true;\n    this.needsSwap = false;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      type: depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType : three__WEBPACK_IMPORTED_MODULE_0__.FloatType,\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      depthBuffer: false\n    });\n    this.renderTarget.texture.name = \"DepthCopyPass.Target\";\n  }\n  /**\n   * The output depth texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the output depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * The output depth packing.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  get depthPacking() {\n    return this.fullscreenMaterial.outputDepthPacking;\n  }\n  /**\n   * Returns the output depth packing.\n   *\n   * @deprecated Use depthPacking instead.\n   * @return {DepthPackingStrategies} The depth packing.\n   */\n  getDepthPacking() {\n    return this.fullscreenMaterial.outputDepthPacking;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.fullscreenMaterial.depthBuffer = depthTexture;\n    this.fullscreenMaterial.inputDepthPacking = depthPacking;\n  }\n  /**\n   * Copies depth from a depth texture.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n  }\n};\n\n// src/passes/DepthPickingPass.js\nvar unpackFactors = new Float32Array([\n  255 / 256 / 256 ** 3,\n  255 / 256 / 256 ** 2,\n  255 / 256 / 256,\n  255 / 256\n]);\nfunction unpackRGBAToDepth(packedDepth) {\n  return (packedDepth[0] * unpackFactors[0] + packedDepth[1] * unpackFactors[1] + packedDepth[2] * unpackFactors[2] + packedDepth[3] * unpackFactors[3]) / 255;\n}\nvar DepthPickingPass = class extends DepthCopyPass {\n  /**\n   * Constructs a new depth picking pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The depth packing.\n   * @param {Number} [options.mode=DepthCopyMode.SINGLE] - The depth copy mode.\n   */\n  constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking, mode = DepthCopyMode.SINGLE } = {}) {\n    super({ depthPacking });\n    this.name = \"DepthPickingPass\";\n    this.fullscreenMaterial.mode = mode;\n    this.pixelBuffer = depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? new Uint8Array(4) : new Float32Array(4);\n    this.callback = null;\n  }\n  /**\n   * Reads depth at a specific screen position.\n   *\n   * Only one depth value can be picked per frame. Calling this method multiple times per frame will overwrite the\n   * picking coordinates. Unresolved promises will be abandoned.\n   *\n   * @example\n   * const ndc = new Vector3();\n   * const clientRect = myViewport.getBoundingClientRect();\n   * const clientX = pointerEvent.clientX - clientRect.left;\n   * const clientY = pointerEvent.clientY - clientRect.top;\n   * ndc.x = (clientX / myViewport.clientWidth) * 2.0 - 1.0;\n   * ndc.y = -(clientY / myViewport.clientHeight) * 2.0 + 1.0;\n   * const depth = await depthPickingPass.readDepth(ndc);\n   * ndc.z = depth * 2.0 - 1.0;\n   *\n   * const worldPosition = ndc.unproject(camera);\n   *\n   * @param {Vector2|Vector3} ndc - Normalized device coordinates. Only X and Y are relevant.\n   * @return {Promise<Number>} A promise that returns the depth on the next frame.\n   */\n  readDepth(ndc) {\n    this.fullscreenMaterial.texelPosition.set(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);\n    return new Promise((resolve) => {\n      this.callback = resolve;\n    });\n  }\n  /**\n   * Copies depth and resolves depth picking promises.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const material = this.fullscreenMaterial;\n    const mode = material.mode;\n    if (mode === DepthCopyMode.FULL) {\n      super.render(renderer);\n    }\n    if (this.callback !== null) {\n      const renderTarget = this.renderTarget;\n      const pixelBuffer = this.pixelBuffer;\n      const packed = renderTarget.texture.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n      let x = 0, y = 0;\n      if (mode === DepthCopyMode.SINGLE) {\n        super.render(renderer);\n      } else {\n        const texelPosition = material.texelPosition;\n        x = Math.round(texelPosition.x * renderTarget.width);\n        y = Math.round(texelPosition.y * renderTarget.height);\n      }\n      renderer.readRenderTargetPixels(renderTarget, x, y, 1, 1, pixelBuffer);\n      this.callback(packed ? unpackRGBAToDepth(pixelBuffer) : pixelBuffer[0]);\n      this.callback = null;\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    if (this.fullscreenMaterial.mode === DepthCopyMode.FULL) {\n      super.setSize(width, height);\n    }\n  }\n};\n\n// src/passes/EffectPass.js\n\nfunction prefixSubstrings(prefix, substrings, strings) {\n  for (const substring of substrings) {\n    const prefixed = \"$1\" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);\n    const regExp = new RegExp(\"([^\\\\.])(\\\\b\" + substring + \"\\\\b)\", \"g\");\n    for (const entry of strings.entries()) {\n      if (entry[1] !== null) {\n        strings.set(entry[0], entry[1].replace(regExp, prefixed));\n      }\n    }\n  }\n}\nfunction integrateEffect(prefix, effect, data) {\n  let fragmentShader = effect.getFragmentShader();\n  let vertexShader = effect.getVertexShader();\n  const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);\n  const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);\n  data.attributes |= effect.getAttributes();\n  if (fragmentShader === void 0) {\n    throw new Error(`Missing fragment shader (${effect.name})`);\n  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {\n    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);\n  } else if (!mainImageExists && !mainUvExists) {\n    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);\n  } else {\n    const functionRegExp = /\\w+\\s+(\\w+)\\([\\w\\s,]*\\)\\s*{/g;\n    const shaderParts = data.shaderParts;\n    let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\";\n    let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\";\n    let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\";\n    let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\";\n    let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\";\n    const varyings = /* @__PURE__ */ new Set();\n    const names = /* @__PURE__ */ new Set();\n    if (mainUvExists) {\n      fragmentMainUv += `\t${prefix}MainUv(UV);\n`;\n      data.uvTransformation = true;\n    }\n    if (vertexShader !== null && /mainSupport/.test(vertexShader)) {\n      const needsUv = /mainSupport *\\([\\w\\s]*?uv\\s*?\\)/.test(vertexShader);\n      vertexMainSupport += `\t${prefix}MainSupport(`;\n      vertexMainSupport += needsUv ? \"vUv);\\n\" : \");\\n\";\n      for (const m2 of vertexShader.matchAll(/(?:varying\\s+\\w+\\s+([\\S\\s]*?);)/g)) {\n        for (const n of m2[1].split(/\\s*,\\s*/)) {\n          data.varyings.add(n);\n          varyings.add(n);\n          names.add(n);\n        }\n      }\n      for (const m2 of vertexShader.matchAll(functionRegExp)) {\n        names.add(m2[1]);\n      }\n    }\n    for (const m2 of fragmentShader.matchAll(functionRegExp)) {\n      names.add(m2[1]);\n    }\n    for (const d of effect.defines.keys()) {\n      names.add(d.replace(/\\([\\w\\s,]*\\)/g, \"\"));\n    }\n    for (const u of effect.uniforms.keys()) {\n      names.add(u);\n    }\n    names.delete(\"while\");\n    names.delete(\"for\");\n    names.delete(\"if\");\n    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n    effect.defines.forEach((val, key) => data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n    const shaders = /* @__PURE__ */ new Map([[\"fragment\", fragmentShader], [\"vertex\", vertexShader]]);\n    prefixSubstrings(prefix, names, data.defines);\n    prefixSubstrings(prefix, names, shaders);\n    fragmentShader = shaders.get(\"fragment\");\n    vertexShader = shaders.get(\"vertex\");\n    const blendMode = effect.blendMode;\n    data.blendModes.set(blendMode.blendFunction, blendMode);\n    if (mainImageExists) {\n      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {\n        fragmentMainImage += effect.inputColorSpace === SRGBColorSpace ? \"color0 = LinearTosRGB(color0);\\n\t\" : \"color0 = sRGBToLinear(color0);\\n\t\";\n      }\n      if (effect.outputColorSpace !== NoColorSpace) {\n        data.colorSpace = effect.outputColorSpace;\n      } else if (effect.inputColorSpace !== null) {\n        data.colorSpace = effect.inputColorSpace;\n      }\n      const depthParamRegExp = /MainImage *\\([\\w\\s,]*?depth[\\w\\s,]*?\\)/;\n      fragmentMainImage += `${prefix}MainImage(color0, UV, `;\n      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {\n        fragmentMainImage += \"depth, \";\n        data.readDepth = true;\n      }\n      fragmentMainImage += \"color1);\\n\t\";\n      const blendOpacity = prefix + \"BlendOpacity\";\n      data.uniforms.set(blendOpacity, blendMode.opacity);\n      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});\n\n\t`;\n      fragmentHead += `uniform float ${blendOpacity};\n\n`;\n    }\n    fragmentHead += fragmentShader + \"\\n\";\n    if (vertexShader !== null) {\n      vertexHead += vertexShader + \"\\n\";\n    }\n    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);\n    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);\n    if (effect.extensions !== null) {\n      for (const extension of effect.extensions) {\n        data.extensions.add(extension);\n      }\n    }\n  }\n}\nvar EffectPass = class extends Pass {\n  /**\n   * Constructs a new effect pass.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {...Effect} effects - The effects that will be rendered by this pass.\n   */\n  constructor(camera, ...effects) {\n    super(\"EffectPass\");\n    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);\n    this.listener = (event) => this.handleEvent(event);\n    this.effects = [];\n    this.setEffects(effects);\n    this.skipRendering = false;\n    this.minTime = 1;\n    this.maxTime = Number.POSITIVE_INFINITY;\n    this.timeScale = 1;\n  }\n  set mainScene(value) {\n    for (const effect of this.effects) {\n      effect.mainScene = value;\n    }\n  }\n  set mainCamera(value) {\n    this.fullscreenMaterial.copyCameraSettings(value);\n    for (const effect of this.effects) {\n      effect.mainCamera = value;\n    }\n  }\n  /**\n   * Indicates whether this pass encodes its output when rendering to screen.\n   *\n   * @type {Boolean}\n   * @deprecated Use fullscreenMaterial.encodeOutput instead.\n   */\n  get encodeOutput() {\n    return this.fullscreenMaterial.encodeOutput;\n  }\n  set encodeOutput(value) {\n    this.fullscreenMaterial.encodeOutput = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   */\n  get dithering() {\n    return this.fullscreenMaterial.dithering;\n  }\n  set dithering(value) {\n    const material = this.fullscreenMaterial;\n    material.dithering = value;\n    material.needsUpdate = true;\n  }\n  /**\n   * Sets the effects.\n   *\n   * @param {Effect[]} effects - The effects.\n   * @protected\n   */\n  setEffects(effects) {\n    for (const effect of this.effects) {\n      effect.removeEventListener(\"change\", this.listener);\n    }\n    this.effects = effects.sort((a, b) => b.attributes - a.attributes);\n    for (const effect of this.effects) {\n      effect.addEventListener(\"change\", this.listener);\n    }\n  }\n  /**\n   * Updates the compound shader material.\n   *\n   * @protected\n   */\n  updateMaterial() {\n    const data = new EffectShaderData();\n    let id = 0;\n    for (const effect of this.effects) {\n      if (effect.blendMode.blendFunction === BlendFunction.DST) {\n        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;\n      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {\n        throw new Error(`Convolution effects cannot be merged (${effect.name})`);\n      } else {\n        integrateEffect(\"e\" + id++, effect, data);\n      }\n    }\n    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);\n    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);\n    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);\n    const blendRegExp = /\\bblend\\b/g;\n    for (const blendMode of data.blendModes.values()) {\n      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + \"\\n\";\n    }\n    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {\n      if (data.readDepth) {\n        fragmentMainImage = \"float depth = readDepth(UV);\\n\\n\t\" + fragmentMainImage;\n      }\n      this.needsDepthTexture = this.getDepthTexture() === null;\n    } else {\n      this.needsDepthTexture = false;\n    }\n    if (data.colorSpace === SRGBColorSpace) {\n      fragmentMainImage += \"color0 = sRGBToLinear(color0);\\n\t\";\n    }\n    if (data.uvTransformation) {\n      fragmentMainUv = \"vec2 transformedUv = vUv;\\n\" + fragmentMainUv;\n      data.defines.set(\"UV\", \"transformedUv\");\n    } else {\n      data.defines.set(\"UV\", \"vUv\");\n    }\n    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n    for (const [key, value] of data.shaderParts) {\n      if (value !== null) {\n        data.shaderParts.set(key, value.trim().replace(/^#/, \"\\n#\"));\n      }\n    }\n    this.skipRendering = id === 0;\n    this.needsSwap = !this.skipRendering;\n    this.fullscreenMaterial.setShaderData(data);\n  }\n  /**\n   * Rebuilds the shader material.\n   */\n  recompile() {\n    this.updateMaterial();\n  }\n  /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */\n  getDepthTexture() {\n    return this.fullscreenMaterial.depthBuffer;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.fullscreenMaterial.depthBuffer = depthTexture;\n    this.fullscreenMaterial.depthPacking = depthPacking;\n    for (const effect of this.effects) {\n      effect.setDepthTexture(depthTexture, depthPacking);\n    }\n  }\n  /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    for (const effect of this.effects) {\n      effect.update(renderer, inputBuffer, deltaTime);\n    }\n    if (!this.skipRendering || this.renderToScreen) {\n      const material = this.fullscreenMaterial;\n      material.inputBuffer = inputBuffer.texture;\n      material.time += deltaTime * this.timeScale;\n      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n      renderer.render(this.scene, this.camera);\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.fullscreenMaterial.setSize(width, height);\n    for (const effect of this.effects) {\n      effect.setSize(width, height);\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.renderer = renderer;\n    for (const effect of this.effects) {\n      effect.initialize(renderer, alpha, frameBufferType);\n    }\n    this.updateMaterial();\n    if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n    }\n  }\n  /**\n   * Deletes disposable objects.\n   */\n  dispose() {\n    super.dispose();\n    for (const effect of this.effects) {\n      effect.removeEventListener(\"change\", this.listener);\n      effect.dispose();\n    }\n  }\n  /**\n   * Handles events.\n   *\n   * @param {Event} event - An event.\n   */\n  handleEvent(event) {\n    switch (event.type) {\n      case \"change\":\n        this.recompile();\n        break;\n    }\n  }\n};\n\n// src/passes/GaussianBlurPass.js\n\nvar GaussianBlurPass = class extends Pass {\n  /**\n   * Constructs a new Gaussian blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    kernelSize = 35,\n    iterations = 1,\n    resolutionScale = 1,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super(\"GaussianBlurPass\");\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"Blur.Target.A\";\n    this.renderTargetB = this.renderTargetA.clone();\n    this.renderTargetB.texture.name = \"Blur.Target.B\";\n    this.blurMaterial = new GaussianBlurMaterial({ kernelSize });\n    this.copyMaterial = new CopyMaterial();\n    this.copyMaterial.inputBuffer = this.renderTargetB.texture;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.iterations = iterations;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    const blurMaterial = this.blurMaterial;\n    this.fullscreenMaterial = blurMaterial;\n    let previousBuffer = inputBuffer;\n    for (let i = 0, l = Math.max(this.iterations, 1); i < l; ++i) {\n      blurMaterial.direction.set(1, 0);\n      blurMaterial.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(renderTargetA);\n      renderer.render(scene, camera);\n      blurMaterial.direction.set(0, 1);\n      blurMaterial.inputBuffer = renderTargetA.texture;\n      renderer.setRenderTarget(renderTargetB);\n      renderer.render(scene, camera);\n      if (i === 0 && l > 1) {\n        previousBuffer = renderTargetB;\n      }\n    }\n    this.fullscreenMaterial = this.copyMaterial;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.blurMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/passes/KawaseBlurPass.js\n\nvar KawaseBlurPass = class extends Pass {\n  /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor({\n    kernelSize = KernelSize.MEDIUM,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"KawaseBlurPass\");\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"Blur.Target.A\";\n    this.renderTargetB = this.renderTargetA.clone();\n    this.renderTargetB.texture.name = \"Blur.Target.B\";\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this._blurMaterial = new KawaseBlurMaterial();\n    this._blurMaterial.kernelSize = kernelSize;\n    this.copyMaterial = new CopyMaterial();\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   */\n  get blurMaterial() {\n    return this._blurMaterial;\n  }\n  /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   * @protected\n   */\n  set blurMaterial(value) {\n    this._blurMaterial = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use copyMaterial.dithering instead.\n   */\n  get dithering() {\n    return this.copyMaterial.dithering;\n  }\n  set dithering(value) {\n    this.copyMaterial.dithering = value;\n  }\n  /**\n   * The kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurMaterial.kernelSize instead.\n   */\n  get kernelSize() {\n    return this.blurMaterial.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurMaterial.kernelSize = value;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  /**\n   * Sets the render width.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredWidth instead.\n   */\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  /**\n   * Sets the render height.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredHeight instead.\n   */\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * The current blur scale.\n   *\n   * @type {Number}\n   * @deprecated Use blurMaterial.scale instead.\n   */\n  get scale() {\n    return this.blurMaterial.scale;\n  }\n  set scale(value) {\n    this.blurMaterial.scale = value;\n  }\n  /**\n   * Returns the current blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @return {Number} The scale.\n   */\n  getScale() {\n    return this.blurMaterial.scale;\n  }\n  /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @param {Number} value - The scale.\n   */\n  setScale(value) {\n    this.blurMaterial.scale = value;\n  }\n  /**\n   * Returns the kernel size.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @return {KernelSize} The kernel size.\n   */\n  getKernelSize() {\n    return this.kernelSize;\n  }\n  /**\n   * Sets the kernel size.\n   *\n   * Larger kernels require more processing power but scale well with larger render resolutions.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @param {KernelSize} value - The kernel size.\n   */\n  setKernelSize(value) {\n    this.kernelSize = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    const material = this.blurMaterial;\n    const kernelSequence = material.kernelSequence;\n    let previousBuffer = inputBuffer;\n    this.fullscreenMaterial = material;\n    for (let i = 0, l = kernelSequence.length; i < l; ++i) {\n      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      material.kernel = kernelSequence[i];\n      material.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(buffer);\n      renderer.render(scene, camera);\n      previousBuffer = buffer;\n    }\n    this.fullscreenMaterial = this.copyMaterial;\n    this.copyMaterial.inputBuffer = previousBuffer.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.blurMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n      }\n    }\n  }\n  /**\n   * An auto sizing flag.\n   *\n   * @type {Number}\n   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.\n   */\n  static get AUTO_SIZE() {\n    return Resolution.AUTO_SIZE;\n  }\n};\n\n// src/passes/LambdaPass.js\nvar LambdaPass = class extends Pass {\n  /**\n   * Constructs a new lambda pass.\n   *\n   * @param {Function} f - A function.\n   */\n  constructor(f) {\n    super(\"LambdaPass\", null, null);\n    this.needsSwap = false;\n    this.f = f;\n  }\n  /**\n   * Executes the function.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    this.f();\n  }\n};\n\n// src/passes/LuminancePass.js\n\nvar LuminancePass = class extends Pass {\n  /**\n   * Constructs a new luminance pass.\n   *\n   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor({\n    renderTarget,\n    luminanceRange,\n    colorOutput,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"LuminancePass\");\n    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);\n    this.needsSwap = false;\n    this.renderTarget = renderTarget;\n    if (this.renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n      this.renderTarget.texture.name = \"LuminancePass.Target\";\n    }\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  /**\n   * The luminance texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Renders the luminance.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const material = this.fullscreenMaterial;\n    material.inputBuffer = inputBuffer.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.renderTarget.texture.type = frameBufferType;\n      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n    }\n  }\n};\n\n// src/passes/MaskPass.js\nvar MaskPass = class extends Pass {\n  /**\n   * Constructs a new mask pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use.\n   */\n  constructor(scene, camera) {\n    super(\"MaskPass\", scene, camera);\n    this.needsSwap = false;\n    this.clearPass = new ClearPass(false, false, true);\n    this.inverse = false;\n  }\n  set mainScene(value) {\n    this.scene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n  }\n  /**\n   * Indicates whether the mask should be inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this.inverse;\n  }\n  set inverted(value) {\n    this.inverse = value;\n  }\n  /**\n   * Indicates whether this pass should clear the stencil buffer.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */\n  get clear() {\n    return this.clearPass.enabled;\n  }\n  set clear(value) {\n    this.clearPass.enabled = value;\n  }\n  /**\n   * Returns the internal clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */\n  getClearPass() {\n    return this.clearPass;\n  }\n  /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n  /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const context = renderer.getContext();\n    const buffers = renderer.state.buffers;\n    const scene = this.scene;\n    const camera = this.camera;\n    const clearPass = this.clearPass;\n    const writeValue = this.inverted ? 0 : 1;\n    const clearValue = 1 - writeValue;\n    buffers.color.setMask(false);\n    buffers.depth.setMask(false);\n    buffers.color.setLocked(true);\n    buffers.depth.setLocked(true);\n    buffers.stencil.setTest(true);\n    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);\n    buffers.stencil.setClear(clearValue);\n    buffers.stencil.setLocked(true);\n    if (this.clearPass.enabled) {\n      if (this.renderToScreen) {\n        clearPass.render(renderer, null);\n      } else {\n        clearPass.render(renderer, inputBuffer);\n        clearPass.render(renderer, outputBuffer);\n      }\n    }\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      renderer.render(scene, camera);\n    } else {\n      renderer.setRenderTarget(inputBuffer);\n      renderer.render(scene, camera);\n      renderer.setRenderTarget(outputBuffer);\n      renderer.render(scene, camera);\n    }\n    buffers.color.setLocked(false);\n    buffers.depth.setLocked(false);\n    buffers.stencil.setLocked(false);\n    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);\n    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n    buffers.stencil.setLocked(true);\n  }\n};\n\n// src/passes/MipmapBlurPass.js\n\nvar MipmapBlurPass = class extends Pass {\n  /**\n   * Constructs a new mipmap blur pass.\n   *\n   * @param {Object} [options] - The options.\n   */\n  constructor() {\n    super(\"MipmapBlurPass\");\n    this.needsSwap = false;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"Upsampling.Mipmap0\";\n    this.downsamplingMipmaps = [];\n    this.upsamplingMipmaps = [];\n    this.downsamplingMaterial = new DownsamplingMaterial();\n    this.upsamplingMaterial = new UpsamplingMaterial();\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n  }\n  /**\n   * A texture that contains the blurred result.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * The MIP levels. Default is 8.\n   *\n   * @type {Number}\n   */\n  get levels() {\n    return this.downsamplingMipmaps.length;\n  }\n  set levels(value) {\n    if (this.levels !== value) {\n      const renderTarget = this.renderTarget;\n      this.dispose();\n      this.downsamplingMipmaps = [];\n      this.upsamplingMipmaps = [];\n      for (let i = 0; i < value; ++i) {\n        const mipmap = renderTarget.clone();\n        mipmap.texture.name = \"Downsampling.Mipmap\" + i;\n        this.downsamplingMipmaps.push(mipmap);\n      }\n      this.upsamplingMipmaps.push(renderTarget);\n      for (let i = 1, l = value - 1; i < l; ++i) {\n        const mipmap = renderTarget.clone();\n        mipmap.texture.name = \"Upsampling.Mipmap\" + i;\n        this.upsamplingMipmaps.push(mipmap);\n      }\n      this.setSize(this.resolution.x, this.resolution.y);\n    }\n  }\n  /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */\n  get radius() {\n    return this.upsamplingMaterial.radius;\n  }\n  set radius(value) {\n    this.upsamplingMaterial.radius = value;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const { scene, camera } = this;\n    const { downsamplingMaterial, upsamplingMaterial } = this;\n    const { downsamplingMipmaps, upsamplingMipmaps } = this;\n    let previousBuffer = inputBuffer;\n    this.fullscreenMaterial = downsamplingMaterial;\n    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {\n      const mipmap = downsamplingMipmaps[i];\n      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n      downsamplingMaterial.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(mipmap);\n      renderer.render(scene, camera);\n      previousBuffer = mipmap;\n    }\n    this.fullscreenMaterial = upsamplingMaterial;\n    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {\n      const mipmap = upsamplingMipmaps[i];\n      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n      upsamplingMaterial.inputBuffer = previousBuffer.texture;\n      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;\n      renderer.setRenderTarget(mipmap);\n      renderer.render(scene, camera);\n      previousBuffer = mipmap;\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.set(width, height);\n    let w = resolution.width, h = resolution.height;\n    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {\n      w = Math.round(w * 0.5);\n      h = Math.round(h * 0.5);\n      this.downsamplingMipmaps[i].setSize(w, h);\n      if (i < this.upsamplingMipmaps.length) {\n        this.upsamplingMipmaps[i].setSize(w, h);\n      }\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);\n      for (const mipmap of mipmaps) {\n        mipmap.texture.type = frameBufferType;\n      }\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        for (const mipmap of mipmaps) {\n          setTextureColorSpace(mipmap.texture, SRGBColorSpace);\n        }\n      }\n    }\n  }\n  /**\n   * Deletes internal render targets and textures.\n   */\n  dispose() {\n    super.dispose();\n    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {\n      mipmap.dispose();\n    }\n  }\n};\n\n// src/passes/NormalPass.js\n\nvar NormalPass = class extends Pass {\n  /**\n   * Constructs a new normal pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(scene, camera, {\n    renderTarget,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"NormalPass\");\n    this.needsSwap = false;\n    this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshNormalMaterial());\n    const renderPass = this.renderPass;\n    renderPass.ignoreBackground = true;\n    renderPass.skipShadowMapUpdate = true;\n    const clearPass = renderPass.getClearPass();\n    clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(7829503);\n    clearPass.overrideClearAlpha = 1;\n    this.renderTarget = renderTarget;\n    if (this.renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n        minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n        magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n      });\n      this.renderTarget.texture.name = \"NormalPass.Target\";\n    }\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  set mainScene(value) {\n    this.renderPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.renderPass.mainCamera = value;\n  }\n  /**\n   * The normal texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * The normal texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const renderTarget = this.renderToScreen ? null : this.renderTarget;\n    this.renderPass.render(renderer, renderTarget, renderTarget);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n  }\n};\n\n// src/passes/ShaderPass.js\n\nvar ShaderPass = class extends Pass {\n  /**\n   * Constructs a new shader pass.\n   *\n   * @param {ShaderMaterial} material - A shader material.\n   * @param {String} [input=\"inputBuffer\"] - The name of the input buffer uniform.\n   */\n  constructor(material, input = \"inputBuffer\") {\n    super(\"ShaderPass\");\n    this.fullscreenMaterial = material;\n    this.input = input;\n  }\n  /**\n   * Sets the name of the input buffer uniform.\n   *\n   * @param {String} input - The name of the input buffer uniform.\n   * @deprecated Use input instead.\n   */\n  setInput(input) {\n    this.input = input;\n  }\n  /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const uniforms = this.fullscreenMaterial.uniforms;\n    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {\n      uniforms[this.input].value = inputBuffer.texture;\n    }\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n    }\n  }\n};\n\n// src/passes/TiltShiftBlurPass.js\nvar TiltShiftBlurPass = class extends KawaseBlurPass {\n  /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    offset = 0,\n    rotation = 0,\n    focusArea = 0.4,\n    feather = 0.3,\n    kernelSize = KernelSize.MEDIUM,\n    resolutionScale = 0.5,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super({ kernelSize, resolutionScale, resolutionX, resolutionY });\n    this.blurMaterial = new TiltShiftBlurMaterial({ kernelSize, offset, rotation, focusArea, feather });\n  }\n};\n\n// src/core/Timer.js\nvar MILLISECONDS_TO_SECONDS = 1 / 1e3;\nvar SECONDS_TO_MILLISECONDS = 1e3;\nvar Timer = class {\n  /**\n   * Constructs a new timer.\n   */\n  constructor() {\n    this.startTime = performance.now();\n    this.previousTime = 0;\n    this.currentTime = 0;\n    this._delta = 0;\n    this._elapsed = 0;\n    this._fixedDelta = 1e3 / 60;\n    this.timescale = 1;\n    this.useFixedDelta = false;\n    this._autoReset = false;\n  }\n  /**\n   * Enables or disables auto reset based on page visibility.\n   *\n   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page\n   * is hidden. Has no effect if the API is not supported.\n   *\n   * @type {Boolean}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n   */\n  get autoReset() {\n    return this._autoReset;\n  }\n  set autoReset(value) {\n    if (typeof document !== \"undefined\" && document.hidden !== void 0) {\n      if (value) {\n        document.addEventListener(\"visibilitychange\", this);\n      } else {\n        document.removeEventListener(\"visibilitychange\", this);\n      }\n      this._autoReset = value;\n    }\n  }\n  get delta() {\n    return this._delta * MILLISECONDS_TO_SECONDS;\n  }\n  get fixedDelta() {\n    return this._fixedDelta * MILLISECONDS_TO_SECONDS;\n  }\n  set fixedDelta(value) {\n    this._fixedDelta = value * SECONDS_TO_MILLISECONDS;\n  }\n  get elapsed() {\n    return this._elapsed * MILLISECONDS_TO_SECONDS;\n  }\n  /**\n   * Updates this timer.\n   *\n   * @param {Boolean} [timestamp] - The current time in milliseconds.\n   */\n  update(timestamp) {\n    if (this.useFixedDelta) {\n      this._delta = this.fixedDelta;\n    } else {\n      this.previousTime = this.currentTime;\n      this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;\n      this._delta = this.currentTime - this.previousTime;\n    }\n    this._delta *= this.timescale;\n    this._elapsed += this._delta;\n  }\n  /**\n   * Resets this timer.\n   */\n  reset() {\n    this._delta = 0;\n    this._elapsed = 0;\n    this.currentTime = performance.now() - this.startTime;\n  }\n  handleEvent(e) {\n    if (!document.hidden) {\n      this.currentTime = performance.now() - this.startTime;\n    }\n  }\n  dispose() {\n    this.autoReset = false;\n  }\n};\n\n// src/core/EffectComposer.js\nvar EffectComposer = class {\n  /**\n   * Constructs a new effect composer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer that should be used.\n   * @param {Object} [options] - The options.\n   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.\n   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.\n   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.\n   */\n  constructor(renderer = null, {\n    depthBuffer = true,\n    stencilBuffer = false,\n    multisampling = 0,\n    frameBufferType\n  } = {}) {\n    this.renderer = null;\n    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);\n    this.outputBuffer = this.inputBuffer.clone();\n    this.copyPass = new CopyPass();\n    this.depthTexture = null;\n    this.passes = [];\n    this.timer = new Timer();\n    this.autoRenderToScreen = true;\n    this.setRenderer(renderer);\n  }\n  /**\n   * The current amount of samples used for multisample anti-aliasing.\n   *\n   * @type {Number}\n   */\n  get multisampling() {\n    return this.inputBuffer.samples || 0;\n  }\n  /**\n   * Sets the amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @type {Number}\n   */\n  set multisampling(value) {\n    const buffer = this.inputBuffer;\n    const multisampling = this.multisampling;\n    if (multisampling > 0 && value > 0) {\n      this.inputBuffer.samples = value;\n      this.outputBuffer.samples = value;\n      this.inputBuffer.dispose();\n      this.outputBuffer.dispose();\n    } else if (multisampling !== value) {\n      this.inputBuffer.dispose();\n      this.outputBuffer.dispose();\n      this.inputBuffer = this.createBuffer(\n        buffer.depthBuffer,\n        buffer.stencilBuffer,\n        buffer.texture.type,\n        value\n      );\n      this.inputBuffer.depthTexture = this.depthTexture;\n      this.outputBuffer = this.inputBuffer.clone();\n    }\n  }\n  /**\n   * Returns the internal timer.\n   *\n   * @return {Timer} The timer.\n   */\n  getTimer() {\n    return this.timer;\n  }\n  /**\n   * Returns the renderer.\n   *\n   * @return {WebGLRenderer} The renderer.\n   */\n  getRenderer() {\n    return this.renderer;\n  }\n  /**\n   * Sets the renderer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   */\n  setRenderer(renderer) {\n    this.renderer = renderer;\n    if (renderer !== null) {\n      const size = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n      const alpha = renderer.getContext().getContextAttributes().alpha;\n      const frameBufferType = this.inputBuffer.texture.type;\n      if (frameBufferType === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.inputBuffer.texture, SRGBColorSpace);\n        setTextureColorSpace(this.outputBuffer.texture, SRGBColorSpace);\n        this.inputBuffer.dispose();\n        this.outputBuffer.dispose();\n      }\n      renderer.autoClear = false;\n      this.setSize(size.width, size.height);\n      for (const pass of this.passes) {\n        pass.initialize(renderer, alpha, frameBufferType);\n      }\n    }\n  }\n  /**\n   * Replaces the current renderer with the given one.\n   *\n   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the\n   * previous one, all passes will be updated.\n   *\n   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM\n   * element of the new renderer will take its place.\n   *\n   * @deprecated Use setRenderer instead.\n   * @param {WebGLRenderer} renderer - The new renderer.\n   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.\n   * @return {WebGLRenderer} The old renderer.\n   */\n  replaceRenderer(renderer, updateDOM = true) {\n    const oldRenderer = this.renderer;\n    const parent = oldRenderer.domElement.parentNode;\n    this.setRenderer(renderer);\n    if (updateDOM && parent !== null) {\n      parent.removeChild(oldRenderer.domElement);\n      parent.appendChild(renderer.domElement);\n    }\n    return oldRenderer;\n  }\n  /**\n   * Creates a depth texture attachment that will be provided to all passes.\n   *\n   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture\n   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.\n   *\n   * @private\n   * @return {DepthTexture} The depth texture.\n   */\n  createDepthTexture() {\n    const depthTexture = this.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n    this.inputBuffer.depthTexture = depthTexture;\n    this.inputBuffer.dispose();\n    if (this.inputBuffer.stencilBuffer) {\n      depthTexture.format = three__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat;\n      depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type;\n    } else {\n      depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType;\n    }\n    return depthTexture;\n  }\n  /**\n   * Deletes the current depth texture.\n   *\n   * @private\n   */\n  deleteDepthTexture() {\n    if (this.depthTexture !== null) {\n      this.depthTexture.dispose();\n      this.depthTexture = null;\n      this.inputBuffer.depthTexture = null;\n      this.inputBuffer.dispose();\n      for (const pass of this.passes) {\n        pass.setDepthTexture(null);\n      }\n    }\n  }\n  /**\n   * Creates a new render target.\n   *\n   * @deprecated Create buffers manually via WebGLRenderTarget instead.\n   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.\n   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.\n   * @param {Number} type - The frame buffer type.\n   * @param {Number} multisampling - The number of samples to use for antialiasing.\n   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.\n   */\n  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {\n    const renderer = this.renderer;\n    const size = renderer === null ? new three__WEBPACK_IMPORTED_MODULE_0__.Vector2() : renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    const options = {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n      stencilBuffer,\n      depthBuffer,\n      type\n    };\n    const renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(size.width, size.height, options);\n    if (multisampling > 0) {\n      renderTarget.ignoreDepthForMultisampleCopy = false;\n      renderTarget.samples = multisampling;\n    }\n    if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && getOutputColorSpace(renderer) === SRGBColorSpace) {\n      setTextureColorSpace(renderTarget.texture, SRGBColorSpace);\n    }\n    renderTarget.texture.name = \"EffectComposer.Buffer\";\n    renderTarget.texture.generateMipmaps = false;\n    return renderTarget;\n  }\n  /**\n   * Can be used to change the main scene for all registered passes and effects.\n   *\n   * @param {Scene} scene - The scene.\n   */\n  setMainScene(scene) {\n    for (const pass of this.passes) {\n      pass.mainScene = scene;\n    }\n  }\n  /**\n   * Can be used to change the main camera for all registered passes and effects.\n   *\n   * @param {Camera} camera - The camera.\n   */\n  setMainCamera(camera) {\n    for (const pass of this.passes) {\n      pass.mainCamera = camera;\n    }\n  }\n  /**\n   * Adds a pass, optionally at a specific index.\n   *\n   * @param {Pass} pass - A new pass.\n   * @param {Number} [index] - An index at which the pass should be inserted.\n   */\n  addPass(pass, index) {\n    const passes = this.passes;\n    const renderer = this.renderer;\n    const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    const alpha = renderer.getContext().getContextAttributes().alpha;\n    const frameBufferType = this.inputBuffer.texture.type;\n    pass.setRenderer(renderer);\n    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    pass.initialize(renderer, alpha, frameBufferType);\n    if (this.autoRenderToScreen) {\n      if (passes.length > 0) {\n        passes[passes.length - 1].renderToScreen = false;\n      }\n      if (pass.renderToScreen) {\n        this.autoRenderToScreen = false;\n      }\n    }\n    if (index !== void 0) {\n      passes.splice(index, 0, pass);\n    } else {\n      passes.push(pass);\n    }\n    if (this.autoRenderToScreen) {\n      passes[passes.length - 1].renderToScreen = true;\n    }\n    if (pass.needsDepthTexture || this.depthTexture !== null) {\n      if (this.depthTexture === null) {\n        const depthTexture = this.createDepthTexture();\n        for (pass of passes) {\n          pass.setDepthTexture(depthTexture);\n        }\n      } else {\n        pass.setDepthTexture(this.depthTexture);\n      }\n    }\n  }\n  /**\n   * Removes a pass.\n   *\n   * @param {Pass} pass - The pass.\n   */\n  removePass(pass) {\n    const passes = this.passes;\n    const index = passes.indexOf(pass);\n    const exists = index !== -1;\n    const removed = exists && passes.splice(index, 1).length > 0;\n    if (removed) {\n      if (this.depthTexture !== null) {\n        const reducer = (a, b) => a || b.needsDepthTexture;\n        const depthTextureRequired = passes.reduce(reducer, false);\n        if (!depthTextureRequired) {\n          if (pass.getDepthTexture() === this.depthTexture) {\n            pass.setDepthTexture(null);\n          }\n          this.deleteDepthTexture();\n        }\n      }\n      if (this.autoRenderToScreen) {\n        if (index === passes.length) {\n          pass.renderToScreen = false;\n          if (passes.length > 0) {\n            passes[passes.length - 1].renderToScreen = true;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Removes all passes.\n   */\n  removeAllPasses() {\n    const passes = this.passes;\n    this.deleteDepthTexture();\n    if (passes.length > 0) {\n      if (this.autoRenderToScreen) {\n        passes[passes.length - 1].renderToScreen = false;\n      }\n      this.passes = [];\n    }\n  }\n  /**\n   * Renders all enabled passes in the order in which they were added.\n   *\n   * @param {Number} [deltaTime] - The time since the last frame in seconds.\n   */\n  render(deltaTime) {\n    const renderer = this.renderer;\n    const copyPass = this.copyPass;\n    let inputBuffer = this.inputBuffer;\n    let outputBuffer = this.outputBuffer;\n    let stencilTest = false;\n    let context, stencil, buffer;\n    if (deltaTime === void 0) {\n      this.timer.update();\n      deltaTime = this.timer.delta;\n    }\n    for (const pass of this.passes) {\n      if (pass.enabled) {\n        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n        if (pass.needsSwap) {\n          if (stencilTest) {\n            copyPass.renderToScreen = pass.renderToScreen;\n            context = renderer.getContext();\n            stencil = renderer.state.buffers.stencil;\n            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);\n            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n            stencil.setFunc(context.EQUAL, 1, 4294967295);\n          }\n          buffer = inputBuffer;\n          inputBuffer = outputBuffer;\n          outputBuffer = buffer;\n        }\n        if (pass instanceof MaskPass) {\n          stencilTest = true;\n        } else if (pass instanceof ClearMaskPass) {\n          stencilTest = false;\n        }\n      }\n    }\n  }\n  /**\n   * Sets the size of the buffers, passes and the renderer.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.\n   */\n  setSize(width, height, updateStyle) {\n    const renderer = this.renderer;\n    const currentSize = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    if (width === void 0 || height === void 0) {\n      width = currentSize.width;\n      height = currentSize.height;\n    }\n    if (currentSize.width !== width || currentSize.height !== height) {\n      renderer.setSize(width, height, updateStyle);\n    }\n    const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    for (const pass of this.passes) {\n      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    }\n  }\n  /**\n   * Resets this composer by deleting all passes and creating new buffers.\n   */\n  reset() {\n    const autoReset = this.timer.autoReset;\n    this.dispose();\n    this.autoRenderToScreen = true;\n    this.timer.autoReset = autoReset;\n  }\n  /**\n   * Disposes this composer and all passes.\n   */\n  dispose() {\n    for (const pass of this.passes) {\n      pass.dispose();\n    }\n    this.passes = [];\n    if (this.inputBuffer !== null) {\n      this.inputBuffer.dispose();\n    }\n    if (this.outputBuffer !== null) {\n      this.outputBuffer.dispose();\n    }\n    this.deleteDepthTexture();\n    this.copyPass.dispose();\n    this.timer.dispose();\n  }\n};\n\n// src/core/EffectShaderData.js\nvar EffectShaderData = class {\n  /**\n   * Constructs new shader data.\n   */\n  constructor() {\n    this.shaderParts = /* @__PURE__ */ new Map([\n      [EffectShaderSection.FRAGMENT_HEAD, null],\n      [EffectShaderSection.FRAGMENT_MAIN_UV, null],\n      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],\n      [EffectShaderSection.VERTEX_HEAD, null],\n      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]\n    ]);\n    this.defines = /* @__PURE__ */ new Map();\n    this.uniforms = /* @__PURE__ */ new Map();\n    this.blendModes = /* @__PURE__ */ new Map();\n    this.extensions = /* @__PURE__ */ new Set();\n    this.attributes = EffectAttribute.NONE;\n    this.varyings = /* @__PURE__ */ new Set();\n    this.uvTransformation = false;\n    this.readDepth = false;\n    this.colorSpace = LinearSRGBColorSpace;\n  }\n};\n\n// src/core/GaussKernel.js\nfunction getCoefficients(n) {\n  let result;\n  if (n === 0) {\n    result = new Float64Array(0);\n  } else if (n === 1) {\n    result = new Float64Array([1]);\n  } else if (n > 1) {\n    let row0 = new Float64Array(n);\n    let row1 = new Float64Array(n);\n    for (let y = 1; y <= n; ++y) {\n      for (let x = 0; x < y; ++x) {\n        row1[x] = x === 0 || x === y - 1 ? 1 : row0[x - 1] + row0[x];\n      }\n      result = row1;\n      row1 = row0;\n      row0 = result;\n    }\n  }\n  return result;\n}\nvar GaussKernel = class {\n  /**\n   * Constructs a new Gauss kernel.\n   *\n   * @param {Number} kernelSize - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [edgeBias=2] - Determines how many edge coefficients should be cut off for increased accuracy.\n   */\n  constructor(kernelSize, edgeBias = 2) {\n    this.weights = null;\n    this.offsets = null;\n    this.linearWeights = null;\n    this.linearOffsets = null;\n    this.generate(kernelSize, edgeBias);\n  }\n  /**\n   * The number of steps for discrete sampling.\n   *\n   * @type {Number}\n   */\n  get steps() {\n    return this.offsets === null ? 0 : this.offsets.length;\n  }\n  /**\n   * The number of steps for linear sampling.\n   *\n   * @type {Number}\n   */\n  get linearSteps() {\n    return this.linearOffsets === null ? 0 : this.linearOffsets.length;\n  }\n  /**\n   * Generates the kernel.\n   *\n   * @private\n   * @param {Number} kernelSize - The kernel size.\n   * @param {Number} edgeBias - The amount of edge coefficients to ignore.\n   */\n  generate(kernelSize, edgeBias) {\n    if (kernelSize < 3 || kernelSize > 1020) {\n      throw new Error(\"The kernel size must be in the range [3, 1020]\");\n    }\n    const n = kernelSize + edgeBias * 2;\n    const coefficients = edgeBias > 0 ? getCoefficients(n).slice(edgeBias, -edgeBias) : getCoefficients(n);\n    const mid = Math.floor((coefficients.length - 1) / 2);\n    const sum = coefficients.reduce((a, b) => a + b, 0);\n    const weights = coefficients.slice(mid);\n    const offsets = [...Array(mid + 1).keys()];\n    const linearWeights = new Float64Array(Math.floor(offsets.length / 2));\n    const linearOffsets = new Float64Array(linearWeights.length);\n    linearWeights[0] = weights[0] / sum;\n    for (let i = 1, j = 1, l = offsets.length - 1; i < l; i += 2, ++j) {\n      const offset0 = offsets[i], offset1 = offsets[i + 1];\n      const weight0 = weights[i], weight1 = weights[i + 1];\n      const w = weight0 + weight1;\n      const o = (offset0 * weight0 + offset1 * weight1) / w;\n      linearWeights[j] = w / sum;\n      linearOffsets[j] = o;\n    }\n    for (let i = 0, l = weights.length, s = 1 / sum; i < l; ++i) {\n      weights[i] *= s;\n    }\n    const linearWeightSum = (linearWeights.reduce((a, b) => a + b, 0) - linearWeights[0] * 0.5) * 2;\n    if (linearWeightSum !== 0) {\n      for (let i = 0, l = linearWeights.length, s = 1 / linearWeightSum; i < l; ++i) {\n        linearWeights[i] *= s;\n      }\n    }\n    this.offsets = offsets;\n    this.weights = weights;\n    this.linearOffsets = linearOffsets;\n    this.linearWeights = linearWeights;\n  }\n};\n\n// src/core/ImmutableTimer.js\nvar ImmutableTimer = class {\n  /**\n   * The current delta time in seconds.\n   *\n   * @type {Number}\n   */\n  get delta() {\n    return NaN;\n  }\n  /**\n   * The fixed delta time in seconds.\n   *\n   * @type {Number}\n   */\n  get fixedDelta() {\n    return NaN;\n  }\n  /**\n   * The elapsed time in seconds.\n   *\n   * @type {Number}\n   */\n  get elapsed() {\n    return NaN;\n  }\n};\n\n// src/core/Initializable.js\nvar Initializable = class {\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n  }\n};\n\n// src/core/OverrideMaterialManager.js\n\nvar workaroundEnabled = false;\nvar OverrideMaterialManager = class {\n  /**\n   * Constructs a new override material manager.\n   *\n   * @param {Material} [material=null] - An override material.\n   */\n  constructor(material = null) {\n    this.originalMaterials = /* @__PURE__ */ new Map();\n    this.material = null;\n    this.materials = null;\n    this.materialsBackSide = null;\n    this.materialsDoubleSide = null;\n    this.materialsFlatShaded = null;\n    this.materialsFlatShadedBackSide = null;\n    this.materialsFlatShadedDoubleSide = null;\n    this.setMaterial(material);\n    this.meshCount = 0;\n    this.replaceMaterial = (node) => {\n      if (node.isMesh) {\n        let materials;\n        if (node.material.flatShading) {\n          switch (node.material.side) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n              materials = this.materialsFlatShadedDoubleSide;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n              materials = this.materialsFlatShadedBackSide;\n              break;\n            default:\n              materials = this.materialsFlatShaded;\n              break;\n          }\n        } else {\n          switch (node.material.side) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n              materials = this.materialsDoubleSide;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n              materials = this.materialsBackSide;\n              break;\n            default:\n              materials = this.materials;\n              break;\n          }\n        }\n        this.originalMaterials.set(node, node.material);\n        if (node.isSkinnedMesh) {\n          node.material = materials[2];\n        } else if (node.isInstancedMesh) {\n          node.material = materials[1];\n        } else {\n          node.material = materials[0];\n        }\n        ++this.meshCount;\n      }\n    };\n  }\n  /**\n   * Clones the given material.\n   *\n   * @private\n   * @param {Material} material - The material.\n   * @return {Material} The cloned material.\n   */\n  cloneMaterial(material) {\n    if (!(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial)) {\n      return material.clone();\n    }\n    const uniforms = material.uniforms;\n    const textureUniforms = /* @__PURE__ */ new Map();\n    for (const key in uniforms) {\n      const value = uniforms[key].value;\n      if (value.isRenderTargetTexture) {\n        uniforms[key].value = null;\n        textureUniforms.set(key, value);\n      }\n    }\n    const clone = material.clone();\n    for (const entry of textureUniforms) {\n      uniforms[entry[0]].value = entry[1];\n      clone.uniforms[entry[0]].value = entry[1];\n    }\n    return clone;\n  }\n  /**\n   * Sets the override material.\n   *\n   * @param {Material} material - The material.\n   */\n  setMaterial(material) {\n    this.disposeMaterials();\n    this.material = material;\n    if (material !== null) {\n      const materials = this.materials = [\n        this.cloneMaterial(material),\n        this.cloneMaterial(material),\n        this.cloneMaterial(material)\n      ];\n      for (const m2 of materials) {\n        m2.uniforms = Object.assign({}, material.uniforms);\n        m2.side = three__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n      }\n      materials[2].skinning = true;\n      this.materialsBackSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n        return c2;\n      });\n      this.materialsDoubleSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        return c2;\n      });\n      this.materialsFlatShaded = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.flatShading = true;\n        return c2;\n      });\n      this.materialsFlatShadedBackSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.flatShading = true;\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n        return c2;\n      });\n      this.materialsFlatShadedDoubleSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.flatShading = true;\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        return c2;\n      });\n    }\n  }\n  /**\n   * Renders the scene with the override material.\n   *\n   * @private\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Scene} scene - A scene.\n   * @param {Camera} camera - A camera.\n   */\n  render(renderer, scene, camera) {\n    const shadowMapEnabled = renderer.shadowMap.enabled;\n    renderer.shadowMap.enabled = false;\n    if (workaroundEnabled) {\n      const originalMaterials = this.originalMaterials;\n      this.meshCount = 0;\n      scene.traverse(this.replaceMaterial);\n      renderer.render(scene, camera);\n      for (const entry of originalMaterials) {\n        entry[0].material = entry[1];\n      }\n      if (this.meshCount !== originalMaterials.size) {\n        originalMaterials.clear();\n      }\n    } else {\n      const overrideMaterial = scene.overrideMaterial;\n      scene.overrideMaterial = this.material;\n      renderer.render(scene, camera);\n      scene.overrideMaterial = overrideMaterial;\n    }\n    renderer.shadowMap.enabled = shadowMapEnabled;\n  }\n  /**\n   * Deletes cloned override materials.\n   *\n   * @private\n   */\n  disposeMaterials() {\n    if (this.material !== null) {\n      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);\n      for (const m2 of materials) {\n        m2.dispose();\n      }\n    }\n  }\n  /**\n   * Performs cleanup tasks.\n   */\n  dispose() {\n    this.originalMaterials.clear();\n    this.disposeMaterials();\n  }\n  /**\n   * Indicates whether the override material workaround is enabled.\n   *\n   * @type {Boolean}\n   */\n  static get workaroundEnabled() {\n    return workaroundEnabled;\n  }\n  /**\n   * Enables or disables the override material workaround globally.\n   *\n   * This only affects post processing passes and effects.\n   *\n   * @type {Boolean}\n   */\n  static set workaroundEnabled(value) {\n    workaroundEnabled = value;\n  }\n};\n\n// src/core/Resizable.js\nvar Resizable = class {\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n  }\n};\n\n// src/core/Resolution.js\n\nvar AUTO_SIZE = -1;\nvar Resolution = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n  /**\n   * Constructs a new resolution.\n   *\n   * TODO Remove resizable param.\n   * @param {Resizable} resizable - A resizable object.\n   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.\n   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.\n   * @param {Number} [scale=1.0] - A resolution scale.\n   */\n  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {\n    super();\n    this.resizable = resizable;\n    this.baseSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n    this.preferredSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(width, height);\n    this.target = this.preferredSize;\n    this.s = scale;\n    this.effectiveSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.addEventListener(\"change\", () => this.updateEffectiveSize());\n    this.updateEffectiveSize();\n  }\n  /**\n   * Calculates the effective size.\n   *\n   * @private\n   */\n  updateEffectiveSize() {\n    const base = this.baseSize;\n    const preferred = this.preferredSize;\n    const effective = this.effectiveSize;\n    const scale = this.scale;\n    if (preferred.width !== AUTO_SIZE) {\n      effective.width = preferred.width;\n    } else if (preferred.height !== AUTO_SIZE) {\n      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));\n    } else {\n      effective.width = Math.round(base.width * scale);\n    }\n    if (preferred.height !== AUTO_SIZE) {\n      effective.height = preferred.height;\n    } else if (preferred.width !== AUTO_SIZE) {\n      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));\n    } else {\n      effective.height = Math.round(base.height * scale);\n    }\n  }\n  /**\n   * The effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @type {Number}\n   */\n  get width() {\n    return this.effectiveSize.width;\n  }\n  set width(value) {\n    this.preferredWidth = value;\n  }\n  /**\n   * The effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @type {Number}\n   */\n  get height() {\n    return this.effectiveSize.height;\n  }\n  set height(value) {\n    this.preferredHeight = value;\n  }\n  /**\n   * Returns the effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @deprecated Use width instead.\n   * @return {Number} The effective width.\n   */\n  getWidth() {\n    return this.width;\n  }\n  /**\n   * Returns the effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @deprecated Use height instead.\n   * @return {Number} The effective height.\n   */\n  getHeight() {\n    return this.height;\n  }\n  /**\n   * The resolution scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.s;\n  }\n  set scale(value) {\n    if (this.s !== value) {\n      this.s = value;\n      this.preferredSize.setScalar(AUTO_SIZE);\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */\n  getScale() {\n    return this.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */\n  setScale(value) {\n    this.scale = value;\n  }\n  /**\n   * The base width.\n   *\n   * @type {Number}\n   */\n  get baseWidth() {\n    return this.baseSize.width;\n  }\n  set baseWidth(value) {\n    if (this.baseSize.width !== value) {\n      this.baseSize.width = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @return {Number} The base width.\n   */\n  getBaseWidth() {\n    return this.baseWidth;\n  }\n  /**\n   * Sets the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @param {Number} value - The width.\n   */\n  setBaseWidth(value) {\n    this.baseWidth = value;\n  }\n  /**\n   * The base height.\n   *\n   * @type {Number}\n   */\n  get baseHeight() {\n    return this.baseSize.height;\n  }\n  set baseHeight(value) {\n    if (this.baseSize.height !== value) {\n      this.baseSize.height = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @return {Number} The base height.\n   */\n  getBaseHeight() {\n    return this.baseHeight;\n  }\n  /**\n   * Sets the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @param {Number} value - The height.\n   */\n  setBaseHeight(value) {\n    this.baseHeight = value;\n  }\n  /**\n   * Sets the base size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setBaseSize(width, height) {\n    if (this.baseSize.width !== width || this.baseSize.height !== height) {\n      this.baseSize.set(width, height);\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * The preferred width.\n   *\n   * @type {Number}\n   */\n  get preferredWidth() {\n    return this.preferredSize.width;\n  }\n  set preferredWidth(value) {\n    if (this.preferredSize.width !== value) {\n      this.preferredSize.width = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the preferred width.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @return {Number} The preferred width.\n   */\n  getPreferredWidth() {\n    return this.preferredWidth;\n  }\n  /**\n   * Sets the preferred width.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @param {Number} value - The width.\n   */\n  setPreferredWidth(value) {\n    this.preferredWidth = value;\n  }\n  /**\n   * The preferred height.\n   *\n   * @type {Number}\n   */\n  get preferredHeight() {\n    return this.preferredSize.height;\n  }\n  set preferredHeight(value) {\n    if (this.preferredSize.height !== value) {\n      this.preferredSize.height = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the preferred height.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @return {Number} The preferred height.\n   */\n  getPreferredHeight() {\n    return this.preferredHeight;\n  }\n  /**\n   * Sets the preferred height.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @param {Number} value - The height.\n   */\n  setPreferredHeight(value) {\n    this.preferredHeight = value;\n  }\n  /**\n   * Sets the preferred size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setPreferredSize(width, height) {\n    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {\n      this.preferredSize.set(width, height);\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Copies the given resolution.\n   *\n   * @param {Resolution} resolution - The resolution.\n   */\n  copy(resolution) {\n    this.s = resolution.scale;\n    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);\n    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);\n    this.dispatchEvent({ type: \"change\" });\n    this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n  }\n  /**\n   * An auto sizing constant.\n   *\n   * Can be used to automatically calculate the width or height based on the original aspect ratio.\n   *\n   * @type {Number}\n   */\n  static get AUTO_SIZE() {\n    return AUTO_SIZE;\n  }\n};\n\n// src/core/Selection.js\nvar Selection = class extends Set {\n  /**\n   * Constructs a new selection.\n   *\n   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.\n   * @param {Number} [layer=10] - A dedicated render layer for selected objects.\n   */\n  constructor(iterable, layer = 10) {\n    super();\n    this.l = layer;\n    this.exclusive = false;\n    if (iterable !== void 0) {\n      this.set(iterable);\n    }\n  }\n  /**\n   * The render layer for selected objects.\n   *\n   * @type {Number}\n   */\n  get layer() {\n    return this.l;\n  }\n  set layer(value) {\n    const currentLayer = this.l;\n    for (const object of this) {\n      object.layers.disable(currentLayer);\n      object.layers.enable(value);\n    }\n    this.l = value;\n  }\n  /**\n   * Returns the current render layer for selected objects.\n   *\n   * The default layer is 10. If this collides with your own custom layers, please change it before rendering!\n   *\n   * @deprecated Use layer instead.\n   * @return {Number} The layer.\n   */\n  getLayer() {\n    return this.layer;\n  }\n  /**\n   * Sets the render layer for selected objects.\n   *\n   * The current selection will be updated accordingly.\n   *\n   * @deprecated Use layer instead.\n   * @param {Number} value - The layer. Range is [0, 31].\n   */\n  setLayer(value) {\n    this.layer = value;\n  }\n  /**\n   * Indicates whether objects that are added to this selection will be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @return {Number} Whether this selection is exclusive. Default is false.\n   */\n  isExclusive() {\n    return this.exclusive;\n  }\n  /**\n   * Controls whether objects that are added to this selection should be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @param {Number} value - Whether this selection should be exclusive.\n   */\n  setExclusive(value) {\n    this.exclusive = value;\n  }\n  /**\n   * Clears this selection.\n   *\n   * @return {Selection} This selection.\n   */\n  clear() {\n    const layer = this.layer;\n    for (const object of this) {\n      object.layers.disable(layer);\n    }\n    return super.clear();\n  }\n  /**\n   * Clears this selection and adds the given objects.\n   *\n   * @param {Iterable<Object3D>} objects - The objects that should be selected.\n   * @return {Selection} This selection.\n   */\n  set(objects) {\n    this.clear();\n    for (const object of objects) {\n      this.add(object);\n    }\n    return this;\n  }\n  /**\n   * An alias for {@link has}.\n   *\n   * @param {Object3D} object - An object.\n   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.\n   * @deprecated Added for backward-compatibility.\n   */\n  indexOf(object) {\n    return this.has(object) ? 0 : -1;\n  }\n  /**\n   * Adds an object to this selection.\n   *\n   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.\n   *\n   * @param {Object3D} object - The object that should be selected.\n   * @return {Selection} This selection.\n   */\n  add(object) {\n    if (this.exclusive) {\n      object.layers.set(this.layer);\n    } else {\n      object.layers.enable(this.layer);\n    }\n    return super.add(object);\n  }\n  /**\n   * Removes an object from this selection.\n   *\n   * @param {Object3D} object - The object that should be deselected.\n   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.\n   */\n  delete(object) {\n    if (this.has(object)) {\n      object.layers.disable(this.layer);\n    }\n    return super.delete(object);\n  }\n  /**\n   * Removes an existing object from the selection. If the object doesn't exist it's added instead.\n   *\n   * @param {Object3D} object - The object.\n   * @return {Boolean} Returns true if the object is added, false otherwise.\n   */\n  toggle(object) {\n    let result;\n    if (this.has(object)) {\n      this.delete(object);\n      result = false;\n    } else {\n      this.add(object);\n      result = true;\n    }\n    return result;\n  }\n  /**\n   * Sets the visibility of all selected objects.\n   *\n   * This method enables or disables render layer 0 of all selected objects.\n   *\n   * @param {Boolean} visible - Whether the selected objects should be visible.\n   * @return {Selection} This selection.\n   */\n  setVisible(visible) {\n    for (const object of this) {\n      if (visible) {\n        object.layers.enable(0);\n      } else {\n        object.layers.disable(0);\n      }\n    }\n    return this;\n  }\n};\n\n// src/effects/blending/BlendMode.js\n\n\n// src/effects/blending/glsl/add.frag\nvar add_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}\";\n\n// src/effects/blending/glsl/alpha.frag\nvar alpha_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}\";\n\n// src/effects/blending/glsl/average.frag\nvar average_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}\";\n\n// src/effects/blending/glsl/color.frag\nvar color_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n\n// src/effects/blending/glsl/color-burn.frag\nvar color_burn_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}\";\n\n// src/effects/blending/glsl/color-dodge.frag\nvar color_dodge_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}\";\n\n// src/effects/blending/glsl/darken.frag\nvar darken_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}\";\n\n// src/effects/blending/glsl/difference.frag\nvar difference_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}\";\n\n// src/effects/blending/glsl/divide.frag\nvar divide_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}\";\n\n// src/effects/blending/glsl/exclusion.frag\nvar exclusion_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}\";\n\n// src/effects/blending/glsl/hard-light.frag\nvar hard_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}\";\n\n// src/effects/blending/glsl/hard-mix.frag\nvar hard_mix_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}\";\n\n// src/effects/blending/glsl/hue.frag\nvar hue_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n\n// src/effects/blending/glsl/invert.frag\nvar invert_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}\";\n\n// src/effects/blending/glsl/invert-rgb.frag\nvar invert_rgb_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}\";\n\n// src/effects/blending/glsl/lighten.frag\nvar lighten_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}\";\n\n// src/effects/blending/glsl/linear-burn.frag\nvar linear_burn_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}\";\n\n// src/effects/blending/glsl/linear-dodge.frag\nvar linear_dodge_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}\";\n\n// src/effects/blending/glsl/linear-light.frag\nvar linear_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}\";\n\n// src/effects/blending/glsl/luminosity.frag\nvar luminosity_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n\n// src/effects/blending/glsl/multiply.frag\nvar multiply_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}\";\n\n// src/effects/blending/glsl/negation.frag\nvar negation_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}\";\n\n// src/effects/blending/glsl/normal.frag\nvar normal_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}\";\n\n// src/effects/blending/glsl/overlay.frag\nvar overlay_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}\";\n\n// src/effects/blending/glsl/pin-light.frag\nvar pin_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}\";\n\n// src/effects/blending/glsl/reflect.frag\nvar reflect_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}\";\n\n// src/effects/blending/glsl/saturation.frag\nvar saturation_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n\n// src/effects/blending/glsl/screen.frag\nvar screen_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}\";\n\n// src/effects/blending/glsl/soft-light.frag\nvar soft_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}\";\n\n// src/effects/blending/glsl/src.frag\nvar src_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}\";\n\n// src/effects/blending/glsl/subtract.frag\nvar subtract_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}\";\n\n// src/effects/blending/glsl/vivid-light.frag\nvar vivid_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}\";\n\n// src/effects/blending/BlendMode.js\nvar blendFunctions = /* @__PURE__ */ new Map([\n  [BlendFunction.ADD, add_default],\n  [BlendFunction.ALPHA, alpha_default],\n  [BlendFunction.AVERAGE, average_default],\n  [BlendFunction.COLOR, color_default],\n  [BlendFunction.COLOR_BURN, color_burn_default],\n  [BlendFunction.COLOR_DODGE, color_dodge_default],\n  [BlendFunction.DARKEN, darken_default],\n  [BlendFunction.DIFFERENCE, difference_default],\n  [BlendFunction.DIVIDE, divide_default],\n  [BlendFunction.DST, null],\n  [BlendFunction.EXCLUSION, exclusion_default],\n  [BlendFunction.HARD_LIGHT, hard_light_default],\n  [BlendFunction.HARD_MIX, hard_mix_default],\n  [BlendFunction.HUE, hue_default],\n  [BlendFunction.INVERT, invert_default],\n  [BlendFunction.INVERT_RGB, invert_rgb_default],\n  [BlendFunction.LIGHTEN, lighten_default],\n  [BlendFunction.LINEAR_BURN, linear_burn_default],\n  [BlendFunction.LINEAR_DODGE, linear_dodge_default],\n  [BlendFunction.LINEAR_LIGHT, linear_light_default],\n  [BlendFunction.LUMINOSITY, luminosity_default],\n  [BlendFunction.MULTIPLY, multiply_default],\n  [BlendFunction.NEGATION, negation_default],\n  [BlendFunction.NORMAL, normal_default],\n  [BlendFunction.OVERLAY, overlay_default],\n  [BlendFunction.PIN_LIGHT, pin_light_default],\n  [BlendFunction.REFLECT, reflect_default],\n  [BlendFunction.SATURATION, saturation_default],\n  [BlendFunction.SCREEN, screen_default],\n  [BlendFunction.SOFT_LIGHT, soft_light_default],\n  [BlendFunction.SRC, src_default],\n  [BlendFunction.SUBTRACT, subtract_default],\n  [BlendFunction.VIVID_LIGHT, vivid_light_default]\n]);\nvar BlendMode = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n  /**\n   * Constructs a new blend mode.\n   *\n   * @param {BlendFunction} blendFunction - The blend function.\n   * @param {Number} opacity - The opacity of the color that will be blended with the base color.\n   */\n  constructor(blendFunction, opacity = 1) {\n    super();\n    this._blendFunction = blendFunction;\n    this.opacity = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(opacity);\n  }\n  /**\n   * Returns the opacity.\n   *\n   * @return {Number} The opacity.\n   */\n  getOpacity() {\n    return this.opacity.value;\n  }\n  /**\n   * Sets the opacity.\n   *\n   * @param {Number} value - The opacity.\n   */\n  setOpacity(value) {\n    this.opacity.value = value;\n  }\n  /**\n   * The blend function.\n   *\n   * @type {BlendFunction}\n   */\n  get blendFunction() {\n    return this._blendFunction;\n  }\n  set blendFunction(value) {\n    this._blendFunction = value;\n    this.dispatchEvent({ type: \"change\" });\n  }\n  /**\n   * Returns the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @return {BlendFunction} The blend function.\n   */\n  getBlendFunction() {\n    return this.blendFunction;\n  }\n  /**\n   * Sets the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @param {BlendFunction} value - The blend function.\n   */\n  setBlendFunction(value) {\n    this.blendFunction = value;\n  }\n  /**\n   * Returns the blend function shader code.\n   *\n   * @return {String} The blend function shader code.\n   */\n  getShaderCode() {\n    return blendFunctions.get(this.blendFunction);\n  }\n};\n\n// src/effects/BloomEffect.js\n\n\n// src/effects/Effect.js\n\nvar Effect = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n  /**\n   * Constructs a new effect.\n   *\n   * @param {String} name - The name of this effect. Doesn't have to be unique.\n   * @param {String} fragmentShader - The fragment shader. This shader is required.\n   * @param {Object} [options] - Additional options.\n   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.\n   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.\n   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.\n   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.\n   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.\n   */\n  constructor(name, fragmentShader, {\n    attributes = EffectAttribute.NONE,\n    blendFunction = BlendFunction.NORMAL,\n    defines = /* @__PURE__ */ new Map(),\n    uniforms = /* @__PURE__ */ new Map(),\n    extensions = null,\n    vertexShader = null\n  } = {}) {\n    super();\n    this.name = name;\n    this.renderer = null;\n    this.attributes = attributes;\n    this.fragmentShader = fragmentShader;\n    this.vertexShader = vertexShader;\n    this.defines = defines;\n    this.uniforms = uniforms;\n    this.extensions = extensions;\n    this.blendMode = new BlendMode(blendFunction);\n    this.blendMode.addEventListener(\"change\", (event) => this.setChanged());\n    this._inputColorSpace = LinearSRGBColorSpace;\n    this._outputColorSpace = NoColorSpace;\n  }\n  /**\n   * The input color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */\n  get inputColorSpace() {\n    return this._inputColorSpace;\n  }\n  /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */\n  set inputColorSpace(value) {\n    this._inputColorSpace = value;\n    this.setChanged();\n  }\n  /**\n   * The output color space.\n   *\n   * Should only be changed if this effect converts the input colors to a different color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */\n  get outputColorSpace() {\n    return this._outputColorSpace;\n  }\n  /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */\n  set outputColorSpace(value) {\n    this._outputColorSpace = value;\n    this.setChanged();\n  }\n  /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */\n  set mainScene(value) {\n  }\n  /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */\n  set mainCamera(value) {\n  }\n  /**\n   * Returns the name of this effect.\n   *\n   * @deprecated Use name instead.\n   * @return {String} The name.\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Sets the renderer.\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */\n  setRenderer(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * Returns the preprocessor macro definitions.\n   *\n   * @deprecated Use defines instead.\n   * @return {Map<String, String>} The extensions.\n   */\n  getDefines() {\n    return this.defines;\n  }\n  /**\n   * Returns the uniforms of this effect.\n   *\n   * @deprecated Use uniforms instead.\n   * @return {Map<String, Uniform>} The extensions.\n   */\n  getUniforms() {\n    return this.uniforms;\n  }\n  /**\n   * Returns the WebGL extensions that are required by this effect.\n   *\n   * @deprecated Use extensions instead.\n   * @return {Set<WebGLExtension>} The extensions.\n   */\n  getExtensions() {\n    return this.extensions;\n  }\n  /**\n   * Returns the blend mode.\n   *\n   * The result of this effect will be blended with the result of the previous effect using this blend mode.\n   *\n   * @deprecated Use blendMode instead.\n   * @return {BlendMode} The blend mode.\n   */\n  getBlendMode() {\n    return this.blendMode;\n  }\n  /**\n   * Returns the effect attributes.\n   *\n   * @return {EffectAttribute} The attributes.\n   */\n  getAttributes() {\n    return this.attributes;\n  }\n  /**\n   * Sets the effect attributes.\n   *\n   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes\n   * imply a higher priority.\n   *\n   * @protected\n   * @param {EffectAttribute} attributes - The attributes.\n   */\n  setAttributes(attributes) {\n    this.attributes = attributes;\n    this.setChanged();\n  }\n  /**\n   * Returns the fragment shader.\n   *\n   * @return {String} The fragment shader.\n   */\n  getFragmentShader() {\n    return this.fragmentShader;\n  }\n  /**\n   * Sets the fragment shader.\n   *\n   * @protected\n   * @param {String} fragmentShader - The fragment shader.\n   */\n  setFragmentShader(fragmentShader) {\n    this.fragmentShader = fragmentShader;\n    this.setChanged();\n  }\n  /**\n   * Returns the vertex shader.\n   *\n   * @return {String} The vertex shader.\n   */\n  getVertexShader() {\n    return this.vertexShader;\n  }\n  /**\n   * Sets the vertex shader.\n   *\n   * @protected\n   * @param {String} vertexShader - The vertex shader.\n   */\n  setVertexShader(vertexShader) {\n    this.vertexShader = vertexShader;\n    this.setChanged();\n  }\n  /**\n   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.\n   *\n   * Should be called after changing macros or extensions and after adding/removing uniforms.\n   *\n   * @protected\n   */\n  setChanged() {\n    this.dispatchEvent({ type: \"change\" });\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * You may override this method if your effect requires direct access to the depth texture that is bound to the\n   * associated {@link EffectPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n  }\n  /**\n   * Updates this effect by performing supporting operations.\n   *\n   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the\n   * blend function is set to `SKIP`.\n   *\n   * You may override this method if you need to update custom uniforms or render additional off-screen textures.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n  }\n  /**\n   * Updates the size of this effect.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }\n   */\n  initialize(renderer, alpha, frameBufferType) {\n  }\n  /**\n   * Performs a shallow search for properties that define a dispose method and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed.\n   */\n  dispose() {\n    for (const key of Object.keys(this)) {\n      const property = this[key];\n      const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof Pass;\n      if (isDisposable) {\n        this[key].dispose();\n      }\n    }\n  }\n};\n\n// src/effects/glsl/bloom.frag\nvar bloom_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}\";\n\n// src/effects/BloomEffect.js\nvar BloomEffect = class extends Effect {\n  /**\n   * Constructs a new bloom effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.\n   * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.\n   * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.\n   * @param {Number} [options.intensity=1.0] - The bloom intensity.\n   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.\n   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.\n   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   */\n  constructor({\n    blendFunction = BlendFunction.SCREEN,\n    luminanceThreshold = 0.9,\n    luminanceSmoothing = 0.025,\n    mipmapBlur = false,\n    intensity = 1,\n    radius = 0.85,\n    levels = 8,\n    kernelSize = KernelSize.LARGE,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"BloomEffect\", bloom_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"intensity\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)]\n      ])\n    });\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"Bloom.Target\";\n    this.blurPass = new KawaseBlurPass({ kernelSize });\n    this.luminancePass = new LuminancePass({ colorOutput: true });\n    this.luminanceMaterial.threshold = luminanceThreshold;\n    this.luminanceMaterial.smoothing = luminanceSmoothing;\n    this.mipmapBlurPass = new MipmapBlurPass();\n    this.mipmapBlurPass.enabled = mipmapBlur;\n    this.mipmapBlurPass.radius = radius;\n    this.mipmapBlurPass.levels = levels;\n    this.uniforms.get(\"map\").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n  }\n  /**\n   * Returns the generated bloom texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Returns the blur pass.\n   *\n   * @deprecated\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * Returns the luminance pass.\n   *\n   * @deprecated Use luminancePass instead.\n   * @return {LuminancePass} The luminance pass.\n   */\n  getLuminancePass() {\n    return this.luminancePass;\n  }\n  /**\n   * The luminance material.\n   *\n   * @type {LuminanceMaterial}\n   */\n  get luminanceMaterial() {\n    return this.luminancePass.fullscreenMaterial;\n  }\n  /**\n   * Returns the luminance material.\n   *\n   * @deprecated Use luminanceMaterial instead.\n   * @return {LuminanceMaterial} The material.\n   */\n  getLuminanceMaterial() {\n    return this.luminancePass.fullscreenMaterial;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use EffectPass.dithering instead.\n   */\n  get dithering() {\n    return this.blurPass.dithering;\n  }\n  set dithering(value) {\n    this.blurPass.dithering = value;\n  }\n  /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated\n   */\n  get kernelSize() {\n    return this.blurPass.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurPass.kernelSize = value;\n  }\n  /**\n   * @type {Number}\n   * @deprecated\n   */\n  get distinction() {\n    console.warn(this.name, \"distinction was removed\");\n    return 1;\n  }\n  set distinction(value) {\n    console.warn(this.name, \"distinction was removed\");\n  }\n  /**\n   * The bloom intensity.\n   *\n   * @type {Number}\n   */\n  get intensity() {\n    return this.uniforms.get(\"intensity\").value;\n  }\n  set intensity(value) {\n    this.uniforms.get(\"intensity\").value = value;\n  }\n  /**\n   * The bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @return {Number} The intensity.\n   */\n  getIntensity() {\n    return this.intensity;\n  }\n  /**\n   * Sets the bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @param {Number} value - The intensity.\n   */\n  setIntensity(value) {\n    this.intensity = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const renderTarget = this.renderTarget;\n    const luminancePass = this.luminancePass;\n    if (luminancePass.enabled) {\n      luminancePass.render(renderer, inputBuffer);\n      if (this.mipmapBlurPass.enabled) {\n        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);\n      } else {\n        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);\n      }\n    } else {\n      if (this.mipmapBlurPass.enabled) {\n        this.mipmapBlurPass.render(renderer, inputBuffer);\n      } else {\n        this.blurPass.render(renderer, inputBuffer, renderTarget);\n      }\n    }\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n    this.blurPass.resolution.copy(resolution);\n    this.luminancePass.setSize(width, height);\n    this.mipmapBlurPass.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, frameBufferType);\n    this.luminancePass.initialize(renderer, alpha, frameBufferType);\n    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/effects/BokehEffect.js\n\n\n// src/effects/glsl/bokeh.frag\nvar bokeh_default = \"uniform float focus;uniform float dof;uniform float aperture;uniform float maxBlur;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec2 aspectCorrection=vec2(1.0,aspect);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\\n#else\\nfloat linearDepth=depth;\\n#endif\\nfloat focusNear=clamp(focus-dof,0.0,1.0);float focusFar=clamp(focus+dof,0.0,1.0);float low=step(linearDepth,focusNear);float high=step(focusFar,linearDepth);float factor=(linearDepth-focusNear)*low+(linearDepth-focusFar)*high;vec2 dofBlur=vec2(clamp(factor*aperture,-maxBlur,maxBlur));vec2 dofblur9=dofBlur*0.9;vec2 dofblur7=dofBlur*0.7;vec2 dofblur4=dofBlur*0.4;vec4 color=inputColor;color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur4);outputColor=color/41.0;}\";\n\n// src/effects/BokehEffect.js\nvar BokehEffect = class extends Effect {\n  /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=0.5] - The focus distance ratio, ranging from 0.0 to 1.0.\n   * @param {Number} [options.dof=0.02] - Depth of field. An area in front of and behind the focal point that still appears sharp.\n   * @param {Number} [options.aperture=0.015] - Camera aperture scale. Bigger values for stronger blur and shallower depth of field.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   */\n  constructor({\n    blendFunction,\n    focus = 0.5,\n    dof = 0.02,\n    aperture = 0.015,\n    maxBlur = 1\n  } = {}) {\n    super(\"BokehEffect\", bokeh_default, {\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"focus\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)],\n        [\"dof\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(dof)],\n        [\"aperture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(aperture)],\n        [\"maxBlur\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)]\n      ])\n    });\n  }\n};\n\n// src/effects/BrightnessContrastEffect.js\n\n\n// src/effects/glsl/brightness-contrast.frag\nvar brightness_contrast_default = \"uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}\";\n\n// src/effects/BrightnessContrastEffect.js\nvar BrightnessContrastEffect = class extends Effect {\n  /**\n   * Constructs a new brightness/contrast effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.brightness=0.0] - The brightness factor, ranging from -1 to 1, where 0 means no change.\n   * @param {Number} [options.contrast=0.0] - The contrast factor, ranging from -1 to 1, where 0 means no change.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, brightness = 0, contrast = 0 } = {}) {\n    super(\"BrightnessContrastEffect\", brightness_contrast_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"brightness\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(brightness)],\n        [\"contrast\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(contrast)]\n      ])\n    });\n    this.inputColorSpace = SRGBColorSpace;\n  }\n  /**\n   * The brightness.\n   *\n   * @type {Number}\n   */\n  get brightness() {\n    return this.uniforms.get(\"brightness\").value;\n  }\n  set brightness(value) {\n    this.uniforms.get(\"brightness\").value = value;\n  }\n  /**\n   * Returns the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @return {Number} The brightness.\n   */\n  getBrightness() {\n    return this.brightness;\n  }\n  /**\n   * Sets the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @param {Number} value - The brightness.\n   */\n  setBrightness(value) {\n    this.brightness = value;\n  }\n  /**\n   * The contrast.\n   *\n   * @type {Number}\n   */\n  get contrast() {\n    return this.uniforms.get(\"contrast\").value;\n  }\n  set contrast(value) {\n    this.uniforms.get(\"contrast\").value = value;\n  }\n  /**\n   * Returns the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @return {Number} The contrast.\n   */\n  getContrast() {\n    return this.contrast;\n  }\n  /**\n   * Sets the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @param {Number} value - The contrast.\n   */\n  setContrast(value) {\n    this.contrast = value;\n  }\n};\n\n// src/effects/glsl/color-average.frag\nvar color_average_default = \"void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}\";\n\n// src/effects/ColorAverageEffect.js\nvar ColorAverageEffect = class extends Effect {\n  /**\n   * Constructs a new color average effect.\n   *\n   * @param {BlendFunction} [blendFunction] - The blend function of this effect.\n   */\n  constructor(blendFunction) {\n    super(\"ColorAverageEffect\", color_average_default, { blendFunction });\n  }\n};\n\n// src/effects/ColorDepthEffect.js\n\n\n// src/effects/glsl/color-depth.frag\nvar color_depth_default = \"uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}\";\n\n// src/effects/ColorDepthEffect.js\nvar ColorDepthEffect = class extends Effect {\n  /**\n   * Constructs a new color depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.bits=16] - The color bit depth.\n   */\n  constructor({ blendFunction, bits = 16 } = {}) {\n    super(\"ColorDepthEffect\", color_depth_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"factor\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)]\n      ])\n    });\n    this.bits = 0;\n    this.bitDepth = bits;\n  }\n  /**\n   * The virtual amount of color bits.\n   *\n   * Each color channel effectively uses a fourth of the total amount of bits. Alpha remains unaffected.\n   *\n   * @type {Number}\n   */\n  get bitDepth() {\n    return this.bits;\n  }\n  set bitDepth(value) {\n    this.bits = value;\n    this.uniforms.get(\"factor\").value = Math.pow(2, value / 3);\n  }\n  /**\n   * Returns the current color bit depth.\n   *\n   * @return {Number} The bit depth.\n   */\n  getBitDepth() {\n    return this.bitDepth;\n  }\n  /**\n   * Sets the virtual amount of color bits.\n   *\n   * @param {Number} value - The bit depth.\n   */\n  setBitDepth(value) {\n    this.bitDepth = value;\n  }\n};\n\n// src/effects/ChromaticAberrationEffect.js\n\n\n// src/effects/glsl/chromatic-aberration.frag\nvar chromatic_aberration_default = \"#ifdef RADIAL_MODULATION\\nuniform float modulationOffset;\\n#endif\\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\\n#ifdef RADIAL_MODULATION\\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\\n#else\\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\\n#endif\\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}\";\n\n// src/effects/glsl/chromatic-aberration.vert\nvar chromatic_aberration_default2 = \"uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}\";\n\n// src/effects/ChromaticAberrationEffect.js\nvar ChromaticAberrationEffect = class extends Effect {\n  /**\n   * Constructs a new chromatic aberration effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.offset] - The color offset.\n   * @param {Boolean} [options.radialModulation=false] - Whether the effect should be modulated with a radial gradient.\n   * @param {Number} [options.modulationOffset=0.15] - The modulation offset. Only applies if `radialModulation` is enabled.\n   */\n  constructor({\n    offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1e-3, 5e-4),\n    radialModulation = false,\n    modulationOffset = 0.15\n  } = {}) {\n    super(\"ChromaticAberrationEffect\", chromatic_aberration_default, {\n      vertexShader: chromatic_aberration_default2,\n      attributes: EffectAttribute.CONVOLUTION,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"offset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)],\n        [\"modulationOffset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(modulationOffset)]\n      ])\n    });\n    this.radialModulation = radialModulation;\n  }\n  /**\n   * The color offset.\n   *\n   * @type {Vector2}\n   */\n  get offset() {\n    return this.uniforms.get(\"offset\").value;\n  }\n  set offset(value) {\n    this.uniforms.get(\"offset\").value = value;\n  }\n  /**\n   * Indicates whether radial modulation is enabled.\n   *\n   * When enabled, the effect will be weaker in the middle and stronger towards the screen edges.\n   *\n   * @type {Boolean}\n   */\n  get radialModulation() {\n    return this.defines.has(\"RADIAL_MODULATION\");\n  }\n  set radialModulation(value) {\n    if (value) {\n      this.defines.set(\"RADIAL_MODULATION\", \"1\");\n    } else {\n      this.defines.delete(\"RADIAL_MODULATION\");\n    }\n    this.setChanged();\n  }\n  /**\n   * The modulation offset.\n   *\n   * @type {Number}\n   */\n  get modulationOffset() {\n    return this.uniforms.get(\"modulationOffset\").value;\n  }\n  set modulationOffset(value) {\n    this.uniforms.get(\"modulationOffset\").value = value;\n  }\n  /**\n   * Returns the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @return {Vector2} The offset.\n   */\n  getOffset() {\n    return this.offset;\n  }\n  /**\n   * Sets the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @param {Vector2} value - The offset.\n   */\n  setOffset(value) {\n    this.offset = value;\n  }\n};\n\n// src/effects/glsl/depth.frag\nvar depth_default = \"void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\\n#ifdef INVERTED\\nvec3 color=vec3(1.0-depth);\\n#else\\nvec3 color=vec3(depth);\\n#endif\\noutputColor=vec4(color,inputColor.a);}\";\n\n// src/effects/DepthEffect.js\nvar DepthEffect = class extends Effect {\n  /**\n   * Constructs a new depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.inverted=false] - Whether the depth should be inverted.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, inverted = false } = {}) {\n    super(\"DepthEffect\", depth_default, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH\n    });\n    this.inverted = inverted;\n  }\n  /**\n   * Indicates whether depth should be inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this.defines.has(\"INVERTED\");\n  }\n  set inverted(value) {\n    if (this.inverted !== value) {\n      if (value) {\n        this.defines.set(\"INVERTED\", \"1\");\n      } else {\n        this.defines.delete(\"INVERTED\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the rendered depth is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the rendered depth is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Enables or disables depth inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether depth should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n};\n\n// src/effects/DepthOfFieldEffect.js\n\n\n// src/effects/glsl/depth-of-field.frag\nvar depth_of_field_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\\n#else\\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\\n#endif\\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\\n#if MASK_FUNCTION == 1\\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\\n#else\\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\\n#endif\\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}\";\n\n// src/effects/DepthOfFieldEffect.js\nvar DepthOfFieldEffect = class extends Effect {\n  /**\n   * Constructs a new depth of field effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.worldFocusDistance] - The focus distance in world units.\n   * @param {Number} [options.worldFocusRange] - The focus distance in world units.\n   * @param {Number} [options.focusDistance=0.0] - The normalized focus distance. Range is [0.0, 1.0].\n   * @param {Number} [options.focusRange=0.1] - The focus range. Range is [0.0, 1.0].\n   * @param {Number} [options.focalLength=0.1] - Deprecated.\n   * @param {Number} [options.bokehScale=1.0] - The scale of the bokeh blur.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(camera, {\n    blendFunction,\n    worldFocusDistance,\n    worldFocusRange,\n    focusDistance = 0,\n    focalLength = 0.1,\n    focusRange = focalLength,\n    bokehScale = 1,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"DepthOfFieldEffect\", depth_of_field_default, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"nearColorBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"farColorBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"nearCoCBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"farCoCBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)]\n      ])\n    });\n    this.camera = camera;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"DoF.Intermediate\";\n    this.renderTargetMasked = this.renderTarget.clone();\n    this.renderTargetMasked.texture.name = \"DoF.Masked.Far\";\n    this.renderTargetNear = this.renderTarget.clone();\n    this.renderTargetNear.texture.name = \"DoF.Bokeh.Near\";\n    this.uniforms.get(\"nearColorBuffer\").value = this.renderTargetNear.texture;\n    this.renderTargetFar = this.renderTarget.clone();\n    this.renderTargetFar.texture.name = \"DoF.Bokeh.Far\";\n    this.uniforms.get(\"farColorBuffer\").value = this.renderTargetFar.texture;\n    this.renderTargetCoC = this.renderTarget.clone();\n    this.renderTargetCoC.texture.name = \"DoF.CoC\";\n    this.uniforms.get(\"farCoCBuffer\").value = this.renderTargetCoC.texture;\n    this.renderTargetCoCBlurred = this.renderTargetCoC.clone();\n    this.renderTargetCoCBlurred.texture.name = \"DoF.CoC.Blurred\";\n    this.uniforms.get(\"nearCoCBuffer\").value = this.renderTargetCoCBlurred.texture;\n    this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));\n    const cocMaterial = this.cocMaterial;\n    cocMaterial.focusDistance = focusDistance;\n    cocMaterial.focusRange = focusRange;\n    if (worldFocusDistance !== void 0) {\n      cocMaterial.worldFocusDistance = worldFocusDistance;\n    }\n    if (worldFocusRange !== void 0) {\n      cocMaterial.worldFocusRange = worldFocusRange;\n    }\n    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize: KernelSize.MEDIUM });\n    this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture));\n    const maskMaterial = this.maskPass.fullscreenMaterial;\n    maskMaterial.colorChannel = ColorChannel.GREEN;\n    this.maskFunction = MaskFunction.MULTIPLY_RGB;\n    this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));\n    this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n    this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));\n    this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n    this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));\n    this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n    this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));\n    this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n    this.target = null;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.bokehScale = bokehScale;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.cocMaterial.copyCameraSettings(value);\n  }\n  /**\n   * The circle of confusion texture.\n   *\n   * @type {Texture}\n   */\n  get cocTexture() {\n    return this.renderTargetCoC.texture;\n  }\n  /**\n   * The mask function. Default is `MULTIPLY_RGB`.\n   *\n   * @type {MaskFunction}\n   */\n  get maskFunction() {\n    return this.maskPass.fullscreenMaterial.maskFunction;\n  }\n  set maskFunction(value) {\n    if (this.maskFunction !== value) {\n      this.defines.set(\"MASK_FUNCTION\", value.toFixed(0));\n      this.maskPass.fullscreenMaterial.maskFunction = value;\n      this.setChanged();\n    }\n  }\n  /**\n   * The circle of confusion material.\n   *\n   * @type {CircleOfConfusionMaterial}\n   */\n  get cocMaterial() {\n    return this.cocPass.fullscreenMaterial;\n  }\n  /**\n   * The circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @type {CircleOfConfusionMaterial}\n   */\n  get circleOfConfusionMaterial() {\n    return this.cocMaterial;\n  }\n  /**\n   * Returns the circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @return {CircleOfConfusionMaterial} The material.\n   */\n  getCircleOfConfusionMaterial() {\n    return this.cocMaterial;\n  }\n  /**\n   * Returns the pass that blurs the foreground CoC buffer to soften edges.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The current bokeh scale.\n   *\n   * @type {Number}\n   */\n  get bokehScale() {\n    return this.uniforms.get(\"scale\").value;\n  }\n  set bokehScale(value) {\n    this.bokehNearBasePass.fullscreenMaterial.scale = value;\n    this.bokehNearFillPass.fullscreenMaterial.scale = value;\n    this.bokehFarBasePass.fullscreenMaterial.scale = value;\n    this.bokehFarFillPass.fullscreenMaterial.scale = value;\n    this.maskPass.fullscreenMaterial.strength = value;\n    this.uniforms.get(\"scale\").value = value;\n  }\n  /**\n   * Returns the current bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @return {Number} The scale.\n   */\n  getBokehScale() {\n    return this.bokehScale;\n  }\n  /**\n   * Sets the bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @param {Number} value - The scale.\n   */\n  setBokehScale(value) {\n    this.bokehScale = value;\n  }\n  /**\n   * Returns the current auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @return {Vector3} The target.\n   */\n  getTarget() {\n    return this.target;\n  }\n  /**\n   * Sets the auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @param {Vector3} value - The target.\n   */\n  setTarget(value) {\n    this.target = value;\n  }\n  /**\n   * Calculates the focus distance from the camera to the given position.\n   *\n   * @param {Vector3} target - The target.\n   * @return {Number} The normalized focus distance.\n   */\n  calculateFocusDistance(target) {\n    const camera = this.camera;\n    const distance = camera.position.distanceTo(target);\n    return viewZToOrthographicDepth(-distance, camera.near, camera.far);\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.cocMaterial.depthBuffer = depthTexture;\n    this.cocMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const renderTarget = this.renderTarget;\n    const renderTargetCoC = this.renderTargetCoC;\n    const renderTargetCoCBlurred = this.renderTargetCoCBlurred;\n    const renderTargetMasked = this.renderTargetMasked;\n    if (this.target !== null) {\n      const distance = this.calculateFocusDistance(this.target);\n      this.cocMaterial.focusDistance = distance;\n    }\n    this.cocPass.render(renderer, null, renderTargetCoC);\n    this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);\n    this.maskPass.render(renderer, inputBuffer, renderTargetMasked);\n    this.bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget);\n    this.bokehFarFillPass.render(renderer, renderTarget, this.renderTargetFar);\n    this.bokehNearBasePass.render(renderer, inputBuffer, renderTarget);\n    this.bokehNearFillPass.render(renderer, renderTarget, this.renderTargetNear);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.cocPass.setSize(width, height);\n    this.blurPass.setSize(width, height);\n    this.maskPass.setSize(width, height);\n    this.renderTargetFar.setSize(width, height);\n    this.renderTargetCoC.setSize(width, height);\n    this.renderTargetMasked.setSize(width, height);\n    this.renderTarget.setSize(w, h);\n    this.renderTargetNear.setSize(w, h);\n    this.renderTargetCoCBlurred.setSize(w, h);\n    this.bokehNearBasePass.fullscreenMaterial.setSize(width, height);\n    this.bokehNearFillPass.fullscreenMaterial.setSize(width, height);\n    this.bokehFarBasePass.fullscreenMaterial.setSize(width, height);\n    this.bokehFarFillPass.fullscreenMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.cocPass.initialize(renderer, alpha, frameBufferType);\n    this.maskPass.initialize(renderer, alpha, frameBufferType);\n    this.bokehNearBasePass.initialize(renderer, alpha, frameBufferType);\n    this.bokehNearFillPass.initialize(renderer, alpha, frameBufferType);\n    this.bokehFarBasePass.initialize(renderer, alpha, frameBufferType);\n    this.bokehFarFillPass.initialize(renderer, alpha, frameBufferType);\n    this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n    if (renderer.capabilities.logarithmicDepthBuffer) {\n      this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n    }\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      this.renderTargetNear.texture.type = frameBufferType;\n      this.renderTargetFar.texture.type = frameBufferType;\n      this.renderTargetMasked.texture.type = frameBufferType;\n      if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetNear.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetFar.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetMasked.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/effects/DotScreenEffect.js\n\n\n// src/effects/glsl/dot-screen.frag\nvar dot_screen_default = \"uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}\";\n\n// src/effects/DotScreenEffect.js\nvar DotScreenEffect = class extends Effect {\n  /**\n   * Constructs a new dot screen effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.angle=1.57] - The angle of the dot pattern.\n   * @param {Number} [options.scale=1.0] - The scale of the dot pattern.\n   */\n  constructor({ blendFunction, angle = Math.PI * 0.5, scale = 1 } = {}) {\n    super(\"DotScreenEffect\", dot_screen_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"angle\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(scale)]\n      ])\n    });\n    this.angle = angle;\n  }\n  /**\n   * The angle.\n   *\n   * @type {Number}\n   */\n  get angle() {\n    return Math.acos(this.uniforms.get(\"angle\").value.y);\n  }\n  set angle(value) {\n    this.uniforms.get(\"angle\").value.set(Math.sin(value), Math.cos(value));\n  }\n  /**\n   * Returns the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @return {Number} The angle in radians.\n   */\n  getAngle() {\n    return this.angle;\n  }\n  /**\n   * Sets the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @param {Number} value - The angle in radians.\n   */\n  setAngle(value) {\n    this.angle = value;\n  }\n  /**\n   * The scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.get(\"scale\").value;\n  }\n  set scale(value) {\n    this.uniforms.get(\"scale\").value = value;\n  }\n};\n\n// src/effects/glsl/fxaa.frag\nvar fxaa_default = \"#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\\n#define ONE_OVER_TWELVE 0.08333333333333333\\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}\";\n\n// src/effects/glsl/fxaa.vert\nvar fxaa_default2 = \"varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}\";\n\n// src/effects/FXAAEffect.js\nvar FXAAEffect = class extends Effect {\n  /**\n   * Constructs a new FXAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */\n  constructor({ blendFunction = BlendFunction.SRC } = {}) {\n    super(\"FXAAEffect\", fxaa_default, {\n      vertexShader: fxaa_default2,\n      blendFunction,\n      defines: /* @__PURE__ */ new Map([\n        [\"EDGE_THRESHOLD_MIN\", \"0.0312\"],\n        [\"EDGE_THRESHOLD_MAX\", \"0.125\"],\n        [\"SUBPIXEL_QUALITY\", \"0.75\"],\n        [\"SAMPLES\", \"12\"]\n      ])\n    });\n  }\n  /**\n   * The minimum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get minEdgeThreshold() {\n    return Number(this.defines.get(\"EDGE_THRESHOLD_MIN\"));\n  }\n  set minEdgeThreshold(value) {\n    this.defines.set(\"EDGE_THRESHOLD_MIN\", value.toFixed(12));\n    this.setChanged();\n  }\n  /**\n   * The maximum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get maxEdgeThreshold() {\n    return Number(this.defines.get(\"EDGE_THRESHOLD_MAX\"));\n  }\n  set maxEdgeThreshold(value) {\n    this.defines.set(\"EDGE_THRESHOLD_MAX\", value.toFixed(12));\n    this.setChanged();\n  }\n  /**\n   * The subpixel blend quality. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get subpixelQuality() {\n    return Number(this.defines.get(\"SUBPIXEL_QUALITY\"));\n  }\n  set subpixelQuality(value) {\n    this.defines.set(\"SUBPIXEL_QUALITY\", value.toFixed(12));\n    this.setChanged();\n  }\n  /**\n   * The maximum amount of edge detection samples.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number(this.defines.get(\"SAMPLES\"));\n  }\n  set samples(value) {\n    this.defines.set(\"SAMPLES\", value.toFixed(0));\n    this.setChanged();\n  }\n};\n\n// src/effects/GammaCorrectionEffect.js\n\n\n// src/effects/glsl/gamma-correction.frag\nvar gamma_correction_default = \"uniform float gamma;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=LinearToGamma(max(inputColor,0.0),gamma);}\";\n\n// src/effects/GammaCorrectionEffect.js\nvar GammaCorrectionEffect = class extends Effect {\n  /**\n   * Constructs a new gamma correction effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.gamma=2.0] - The gamma factor.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, gamma = 2 } = {}) {\n    super(\"GammaCorrectionEffect\", gamma_correction_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"gamma\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(gamma)]\n      ])\n    });\n  }\n};\n\n// src/effects/GlitchEffect.js\n\n\n// src/textures/lut/LookupTexture.js\n\n\n// src/textures/RawImageData.js\nfunction createCanvas(width, height, data) {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = height;\n  if (data instanceof Image) {\n    context.drawImage(data, 0, 0);\n  } else {\n    const imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    context.putImageData(imageData, 0, 0);\n  }\n  return canvas;\n}\nvar RawImageData = class _RawImageData {\n  /**\n   * Constructs a new image data container.\n   *\n   * @param {Number} [width=0] - The width of the image.\n   * @param {Number} [height=0] - The height of the image.\n   * @param {Uint8ClampedArray} [data=null] - The image data.\n   */\n  constructor(width = 0, height = 0, data = null) {\n    this.width = width;\n    this.height = height;\n    this.data = data;\n  }\n  /**\n   * Creates a canvas from this image data.\n   *\n   * @return {Canvas} The canvas, or null if it couldn't be created.\n   */\n  toCanvas() {\n    return typeof document === \"undefined\" ? null : createCanvas(this.width, this.height, this.data);\n  }\n  /**\n   * Creates a new image data container.\n   *\n   * @param {ImageData|Image} image - An image or plain image data.\n   * @return {RawImageData} The image data.\n   */\n  static from(image) {\n    const { width, height } = image;\n    let data;\n    if (image instanceof Image) {\n      const canvas = createCanvas(width, height, image);\n      if (canvas !== null) {\n        const context = canvas.getContext(\"2d\");\n        data = context.getImageData(0, 0, width, height).data;\n      }\n    } else {\n      data = image.data;\n    }\n    return new _RawImageData(width, height, data);\n  }\n};\n\n// tmp/lut/worker.txt\nvar worker_default = '\"use strict\";(()=>{var O={SCALE_UP:\"lut.scaleup\"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener(\"message\",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\\n';\n\n// src/textures/lut/LookupTexture.js\nvar c = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar LookupTexture = class _LookupTexture extends three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture {\n  /**\n   * Constructs a cubic 3D lookup texture.\n   *\n   * @param {TypedArray} data - The pixel data. The default format is RGBA.\n   * @param {Number} size - The sidelength.\n   */\n  constructor(data, size) {\n    super(data, size, size, size);\n    this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n    this.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n    this.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    this.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    this.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n    this.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n    this.wrapR = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n    setTextureColorSpace(this, LinearSRGBColorSpace);\n    this.domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    this.domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n  }\n  /**\n   * Indicates that this is an instance of LookupTexture3D.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get isLookupTexture3D() {\n    return true;\n  }\n  /**\n   * Scales this LUT up to a given target size using tetrahedral interpolation.\n   *\n   * @param {Number} size - The target sidelength.\n   * @param {Boolean} [transferData=true] - Extra fast mode. Set to false to keep the original data intact.\n   * @return {Promise<LookupTexture>} A promise that resolves with a new LUT upon completion.\n   */\n  scaleUp(size, transferData = true) {\n    const image = this.image;\n    let promise;\n    if (size <= image.width) {\n      promise = Promise.reject(new Error(\"The target size must be greater than the current size\"));\n    } else {\n      promise = new Promise((resolve, reject) => {\n        const workerURL = URL.createObjectURL(new Blob([worker_default], {\n          type: \"text/javascript\"\n        }));\n        const worker = new Worker(workerURL);\n        worker.addEventListener(\"error\", (event) => reject(event.error));\n        worker.addEventListener(\"message\", (event) => {\n          const lut = new _LookupTexture(event.data, size);\n          copyTextureColorSpace(this, lut);\n          lut.type = this.type;\n          lut.name = this.name;\n          URL.revokeObjectURL(workerURL);\n          resolve(lut);\n        });\n        const transferList = transferData ? [image.data.buffer] : [];\n        worker.postMessage({\n          operation: LUTOperation.SCALE_UP,\n          data: image.data,\n          size\n        }, transferList);\n      });\n    }\n    return promise;\n  }\n  /**\n   * Applies the given LUT to this one.\n   *\n   * @param {LookupTexture} lut - A LUT. Must have the same dimensions, type and format as this LUT.\n   * @return {LookupTexture} This texture.\n   */\n  applyLUT(lut) {\n    const img0 = this.image;\n    const img1 = lut.image;\n    const size0 = Math.min(img0.width, img0.height, img0.depth);\n    const size1 = Math.min(img1.width, img1.height, img1.depth);\n    if (size0 !== size1) {\n      console.error(\"Size mismatch\");\n    } else if (lut.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType || this.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      console.error(\"Both LUTs must be FloatType textures\");\n    } else if (lut.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat || this.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat) {\n      console.error(\"Both LUTs must be RGBA textures\");\n    } else {\n      const data0 = img0.data;\n      const data1 = img1.data;\n      const size = size0;\n      const sizeSq = size ** 2;\n      const s = size - 1;\n      for (let i = 0, l = size ** 3; i < l; ++i) {\n        const i4 = i * 4;\n        const r = data0[i4 + 0] * s;\n        const g = data0[i4 + 1] * s;\n        const b = data0[i4 + 2] * s;\n        const iRGB = Math.round(r + g * size + b * sizeSq) * 4;\n        data0[i4 + 0] = data1[iRGB + 0];\n        data0[i4 + 1] = data1[iRGB + 1];\n        data0[i4 + 2] = data1[iRGB + 2];\n      }\n      this.needsUpdate = true;\n    }\n    return this;\n  }\n  /**\n   * Converts the LUT data into unsigned byte data.\n   *\n   * This is a lossy operation which should only be performed after all other transformations have been applied.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertToUint8() {\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      const floatData = this.image.data;\n      const uint8Data = new Uint8Array(floatData.length);\n      for (let i = 0, l = floatData.length; i < l; ++i) {\n        uint8Data[i] = floatData[i] * 255 + 0.5;\n      }\n      this.image.data = uint8Data;\n      this.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType;\n      this.needsUpdate = true;\n    }\n    return this;\n  }\n  /**\n   * Converts the LUT data into float data.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertToFloat() {\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      const uint8Data = this.image.data;\n      const floatData = new Float32Array(uint8Data.length);\n      for (let i = 0, l = uint8Data.length; i < l; ++i) {\n        floatData[i] = uint8Data[i] / 255;\n      }\n      this.image.data = floatData;\n      this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n      this.needsUpdate = true;\n    }\n    return this;\n  }\n  /**\n   * Converts this LUT into RGBA data.\n   *\n   * @deprecated LUTs are RGBA by default since three r137.\n   * @return {LookupTexture} This texture.\n   */\n  convertToRGBA() {\n    console.warn(\"LookupTexture\", \"convertToRGBA() is deprecated, LUTs are now RGBA by default\");\n    return this;\n  }\n  /**\n   * Converts the output of this LUT into sRGB color space.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertLinearToSRGB() {\n    const data = this.image.data;\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      for (let i = 0, l = data.length; i < l; i += 4) {\n        c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);\n      }\n      setTextureColorSpace(this, SRGBColorSpace);\n      this.needsUpdate = true;\n    } else {\n      console.error(\"Color space conversion requires FloatType data\");\n    }\n    return this;\n  }\n  /**\n   * Converts the output of this LUT into linear color space.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertSRGBToLinear() {\n    const data = this.image.data;\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      for (let i = 0, l = data.length; i < l; i += 4) {\n        c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);\n      }\n      setTextureColorSpace(this, LinearSRGBColorSpace);\n      this.needsUpdate = true;\n    } else {\n      console.error(\"Color space conversion requires FloatType data\");\n    }\n    return this;\n  }\n  /**\n   * Converts this LUT into a 2D data texture.\n   *\n   * Please note that custom input domains are not carried over to 2D textures.\n   *\n   * @return {DataTexture} The texture.\n   */\n  toDataTexture() {\n    const width = this.image.width;\n    const height = this.image.height * this.image.depth;\n    const texture = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(this.image.data, width, height);\n    texture.name = this.name;\n    texture.type = this.type;\n    texture.format = this.format;\n    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    texture.wrapS = this.wrapS;\n    texture.wrapT = this.wrapT;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    copyTextureColorSpace(this, texture);\n    return texture;\n  }\n  /**\n   * Creates a new 3D LUT by copying a given LUT.\n   *\n   * Common image-based textures will be converted into 3D data textures.\n   *\n   * @param {Texture} texture - The LUT. Assumed to be cubic.\n   * @return {LookupTexture} A new 3D LUT.\n   */\n  static from(texture) {\n    const image = texture.image;\n    const { width, height } = image;\n    const size = Math.min(width, height);\n    let data;\n    if (image instanceof Image) {\n      const rawImageData = RawImageData.from(image);\n      const src = rawImageData.data;\n      if (width > height) {\n        data = new Uint8Array(src.length);\n        for (let z = 0; z < size; ++z) {\n          for (let y = 0; y < size; ++y) {\n            for (let x = 0; x < size; ++x) {\n              const i4 = (x + z * size + y * size * size) * 4;\n              const j4 = (x + y * size + z * size * size) * 4;\n              data[j4 + 0] = src[i4 + 0];\n              data[j4 + 1] = src[i4 + 1];\n              data[j4 + 2] = src[i4 + 2];\n              data[j4 + 3] = src[i4 + 3];\n            }\n          }\n        }\n      } else {\n        data = new Uint8Array(src.buffer);\n      }\n    } else {\n      data = image.data.slice();\n    }\n    const lut = new _LookupTexture(data, size);\n    lut.type = texture.type;\n    lut.name = texture.name;\n    copyTextureColorSpace(texture, lut);\n    return lut;\n  }\n  /**\n   * Creates a neutral 3D LUT.\n   *\n   * @param {Number} size - The sidelength.\n   * @return {LookupTexture} A neutral 3D LUT.\n   */\n  static createNeutral(size) {\n    const data = new Float32Array(size ** 3 * 4);\n    const sizeSq = size ** 2;\n    const s = 1 / (size - 1);\n    for (let r = 0; r < size; ++r) {\n      for (let g = 0; g < size; ++g) {\n        for (let b = 0; b < size; ++b) {\n          const i4 = (r + g * size + b * sizeSq) * 4;\n          data[i4 + 0] = r * s;\n          data[i4 + 1] = g * s;\n          data[i4 + 2] = b * s;\n          data[i4 + 3] = 1;\n        }\n      }\n    }\n    const lut = new _LookupTexture(data, size);\n    lut.name = \"neutral\";\n    return lut;\n  }\n};\n\n// src/textures/lut/TetrahedralUpscaler.js\nvar P = [\n  new Float32Array(3),\n  new Float32Array(3)\n];\nvar C = [\n  new Float32Array(3),\n  new Float32Array(3),\n  new Float32Array(3),\n  new Float32Array(3)\n];\nvar T = [\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([1, 0, 0]),\n    new Float32Array([1, 1, 0]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([1, 0, 0]),\n    new Float32Array([1, 0, 1]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 0, 1]),\n    new Float32Array([1, 0, 1]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 1, 0]),\n    new Float32Array([1, 1, 0]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 1, 0]),\n    new Float32Array([0, 1, 1]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 0, 1]),\n    new Float32Array([0, 1, 1]),\n    new Float32Array([1, 1, 1])\n  ]\n];\nfunction calculateTetrahedronVolume(a, b, c2, d) {\n  const bcX = c2[0] - b[0];\n  const bcY = c2[1] - b[1];\n  const bcZ = c2[2] - b[2];\n  const baX = a[0] - b[0];\n  const baY = a[1] - b[1];\n  const baZ = a[2] - b[2];\n  const crossX = bcY * baZ - bcZ * baY;\n  const crossY = bcZ * baX - bcX * baZ;\n  const crossZ = bcX * baY - bcY * baX;\n  const length = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n  const triangleArea = length * 0.5;\n  const normalX = crossX / length;\n  const normalY = crossY / length;\n  const normalZ = crossZ / length;\n  const constant = -(a[0] * normalX + a[1] * normalY + a[2] * normalZ);\n  const dot = d[0] * normalX + d[1] * normalY + d[2] * normalZ;\n  const height = Math.abs(dot + constant);\n  return height * triangleArea / 3;\n}\nfunction sample(data, size, x, y, z, color2) {\n  const i4 = (x + y * size + z * size * size) * 4;\n  color2[0] = data[i4 + 0];\n  color2[1] = data[i4 + 1];\n  color2[2] = data[i4 + 2];\n}\nfunction tetrahedralSample(data, size, u, v3, w, color2) {\n  const px = u * (size - 1);\n  const py = v3 * (size - 1);\n  const pz = w * (size - 1);\n  const minX = Math.floor(px);\n  const minY = Math.floor(py);\n  const minZ = Math.floor(pz);\n  const maxX = Math.ceil(px);\n  const maxY = Math.ceil(py);\n  const maxZ = Math.ceil(pz);\n  const su = px - minX;\n  const sv = py - minY;\n  const sw = pz - minZ;\n  if (minX === px && minY === py && minZ === pz) {\n    sample(data, size, px, py, pz, color2);\n  } else {\n    let vertices;\n    if (su >= sv && sv >= sw) {\n      vertices = T[0];\n    } else if (su >= sw && sw >= sv) {\n      vertices = T[1];\n    } else if (sw >= su && su >= sv) {\n      vertices = T[2];\n    } else if (sv >= su && su >= sw) {\n      vertices = T[3];\n    } else if (sv >= sw && sw >= su) {\n      vertices = T[4];\n    } else if (sw >= sv && sv >= su) {\n      vertices = T[5];\n    }\n    const [P0, P1, P2, P3] = vertices;\n    const coords = P[0];\n    coords[0] = su;\n    coords[1] = sv;\n    coords[2] = sw;\n    const tmp = P[1];\n    const diffX = maxX - minX;\n    const diffY = maxY - minY;\n    const diffZ = maxZ - minZ;\n    tmp[0] = diffX * P0[0] + minX;\n    tmp[1] = diffY * P0[1] + minY;\n    tmp[2] = diffZ * P0[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[0]);\n    tmp[0] = diffX * P1[0] + minX;\n    tmp[1] = diffY * P1[1] + minY;\n    tmp[2] = diffZ * P1[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[1]);\n    tmp[0] = diffX * P2[0] + minX;\n    tmp[1] = diffY * P2[1] + minY;\n    tmp[2] = diffZ * P2[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[2]);\n    tmp[0] = diffX * P3[0] + minX;\n    tmp[1] = diffY * P3[1] + minY;\n    tmp[2] = diffZ * P3[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[3]);\n    const V0 = calculateTetrahedronVolume(P1, P2, P3, coords) * 6;\n    const V1 = calculateTetrahedronVolume(P0, P2, P3, coords) * 6;\n    const V2 = calculateTetrahedronVolume(P0, P1, P3, coords) * 6;\n    const V3 = calculateTetrahedronVolume(P0, P1, P2, coords) * 6;\n    C[0][0] *= V0;\n    C[0][1] *= V0;\n    C[0][2] *= V0;\n    C[1][0] *= V1;\n    C[1][1] *= V1;\n    C[1][2] *= V1;\n    C[2][0] *= V2;\n    C[2][1] *= V2;\n    C[2][2] *= V2;\n    C[3][0] *= V3;\n    C[3][1] *= V3;\n    C[3][2] *= V3;\n    color2[0] = C[0][0] + C[1][0] + C[2][0] + C[3][0];\n    color2[1] = C[0][1] + C[1][1] + C[2][1] + C[3][1];\n    color2[2] = C[0][2] + C[1][2] + C[2][2] + C[3][2];\n  }\n}\nvar TetrahedralUpscaler = class {\n  /**\n   * Expands the given data to the target size.\n   *\n   * @param {TypedArray} data - The input RGBA data. Assumed to be cubic.\n   * @param {Number} size - The target size.\n   * @return {TypedArray} The new data.\n   */\n  static expand(data, size) {\n    const originalSize = Math.cbrt(data.length / 4);\n    const rgb = new Float32Array(3);\n    const array = new data.constructor(size ** 3 * 4);\n    const maxValue = data instanceof Uint8Array ? 255 : 1;\n    const sizeSq = size ** 2;\n    const s = 1 / (size - 1);\n    for (let z = 0; z < size; ++z) {\n      for (let y = 0; y < size; ++y) {\n        for (let x = 0; x < size; ++x) {\n          const u = x * s;\n          const v3 = y * s;\n          const w = z * s;\n          const i4 = Math.round(x + y * size + z * sizeSq) * 4;\n          tetrahedralSample(data, originalSize, u, v3, w, rgb);\n          array[i4 + 0] = rgb[0];\n          array[i4 + 1] = rgb[1];\n          array[i4 + 2] = rgb[2];\n          array[i4 + 3] = maxValue;\n        }\n      }\n    }\n    return array;\n  }\n};\n\n// src/textures/smaa/SMAAAreaImageData.js\nvar area = [\n  new Float32Array(2),\n  new Float32Array(2)\n];\nvar ORTHOGONAL_SIZE = 16;\nvar DIAGONAL_SIZE = 20;\nvar DIAGONAL_SAMPLES = 30;\nvar SMOOTH_MAX_DISTANCE = 32;\nvar orthogonalSubsamplingOffsets = new Float32Array([\n  0,\n  -0.25,\n  0.25,\n  -0.125,\n  0.125,\n  -0.375,\n  0.375\n]);\nvar diagonalSubsamplingOffsets = [\n  new Float32Array([0, 0]),\n  new Float32Array([0.25, -0.25]),\n  new Float32Array([-0.25, 0.25]),\n  new Float32Array([0.125, -0.125]),\n  new Float32Array([-0.125, 0.125])\n];\nvar orthogonalEdges = [\n  new Uint8Array([0, 0]),\n  new Uint8Array([3, 0]),\n  new Uint8Array([0, 3]),\n  new Uint8Array([3, 3]),\n  new Uint8Array([1, 0]),\n  new Uint8Array([4, 0]),\n  new Uint8Array([1, 3]),\n  new Uint8Array([4, 3]),\n  new Uint8Array([0, 1]),\n  new Uint8Array([3, 1]),\n  new Uint8Array([0, 4]),\n  new Uint8Array([3, 4]),\n  new Uint8Array([1, 1]),\n  new Uint8Array([4, 1]),\n  new Uint8Array([1, 4]),\n  new Uint8Array([4, 4])\n];\nvar diagonalEdges = [\n  new Uint8Array([0, 0]),\n  new Uint8Array([1, 0]),\n  new Uint8Array([0, 2]),\n  new Uint8Array([1, 2]),\n  new Uint8Array([2, 0]),\n  new Uint8Array([3, 0]),\n  new Uint8Array([2, 2]),\n  new Uint8Array([3, 2]),\n  new Uint8Array([0, 1]),\n  new Uint8Array([1, 1]),\n  new Uint8Array([0, 3]),\n  new Uint8Array([1, 3]),\n  new Uint8Array([2, 1]),\n  new Uint8Array([3, 1]),\n  new Uint8Array([2, 3]),\n  new Uint8Array([3, 3])\n];\nfunction lerp(a, b, p) {\n  return a + (b - a) * p;\n}\nfunction saturate(a) {\n  return Math.min(Math.max(a, 0), 1);\n}\nfunction smoothArea(d) {\n  const a1 = area[0];\n  const a2 = area[1];\n  const b1X = Math.sqrt(a1[0] * 2) * 0.5;\n  const b1Y = Math.sqrt(a1[1] * 2) * 0.5;\n  const b2X = Math.sqrt(a2[0] * 2) * 0.5;\n  const b2Y = Math.sqrt(a2[1] * 2) * 0.5;\n  const p = saturate(d / SMOOTH_MAX_DISTANCE);\n  a1[0] = lerp(b1X, a1[0], p);\n  a1[1] = lerp(b1Y, a1[1], p);\n  a2[0] = lerp(b2X, a2[0], p);\n  a2[1] = lerp(b2Y, a2[1], p);\n}\nfunction getOrthArea(p1X, p1Y, p2X, p2Y, x, result) {\n  const dX = p2X - p1X;\n  const dY = p2Y - p1Y;\n  const x1 = x;\n  const x2 = x + 1;\n  const y1 = p1Y + dY * (x1 - p1X) / dX;\n  const y2 = p1Y + dY * (x2 - p1X) / dX;\n  if (x1 >= p1X && x1 < p2X || x2 > p1X && x2 <= p2X) {\n    if (Math.sign(y1) === Math.sign(y2) || Math.abs(y1) < 1e-4 || Math.abs(y2) < 1e-4) {\n      const a = (y1 + y2) / 2;\n      if (a < 0) {\n        result[0] = Math.abs(a);\n        result[1] = 0;\n      } else {\n        result[0] = 0;\n        result[1] = Math.abs(a);\n      }\n    } else {\n      const t = -p1Y * dX / dY + p1X;\n      const tInt = Math.trunc(t);\n      const a1 = t > p1X ? y1 * (t - tInt) / 2 : 0;\n      const a2 = t < p2X ? y2 * (1 - (t - tInt)) / 2 : 0;\n      const a = Math.abs(a1) > Math.abs(a2) ? a1 : -a2;\n      if (a < 0) {\n        result[0] = Math.abs(a1);\n        result[1] = Math.abs(a2);\n      } else {\n        result[0] = Math.abs(a2);\n        result[1] = Math.abs(a1);\n      }\n    }\n  } else {\n    result[0] = 0;\n    result[1] = 0;\n  }\n  return result;\n}\nfunction getOrthAreaForPattern(pattern, left, right, offset, result) {\n  const a1 = area[0];\n  const a2 = area[1];\n  const o1 = 0.5 + offset;\n  const o2 = 0.5 + offset - 1;\n  const d = left + right + 1;\n  switch (pattern) {\n    case 0: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n    case 1: {\n      if (left <= right) {\n        getOrthArea(0, o2, d / 2, 0, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 2: {\n      if (left >= right) {\n        getOrthArea(d / 2, 0, d, o2, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 3: {\n      getOrthArea(0, o2, d / 2, 0, left, a1);\n      getOrthArea(d / 2, 0, d, o2, left, a2);\n      smoothArea(d, area);\n      result[0] = a1[0] + a2[0];\n      result[1] = a1[1] + a2[1];\n      break;\n    }\n    case 4: {\n      if (left <= right) {\n        getOrthArea(0, o1, d / 2, 0, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 5: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n    case 6: {\n      if (Math.abs(offset) > 0) {\n        getOrthArea(0, o1, d, o2, left, a1);\n        getOrthArea(0, o1, d / 2, 0, left, a2);\n        getOrthArea(d / 2, 0, d, o2, left, result);\n        a2[0] = a2[0] + result[0];\n        a2[1] = a2[1] + result[1];\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n      } else {\n        getOrthArea(0, o1, d, o2, left, result);\n      }\n      break;\n    }\n    case 7: {\n      getOrthArea(0, o1, d, o2, left, result);\n      break;\n    }\n    case 8: {\n      if (left >= right) {\n        getOrthArea(d / 2, 0, d, o1, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 9: {\n      if (Math.abs(offset) > 0) {\n        getOrthArea(0, o2, d, o1, left, a1);\n        getOrthArea(0, o2, d / 2, 0, left, a2);\n        getOrthArea(d / 2, 0, d, o1, left, result);\n        a2[0] = a2[0] + result[0];\n        a2[1] = a2[1] + result[1];\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n      } else {\n        getOrthArea(0, o2, d, o1, left, result);\n      }\n      break;\n    }\n    case 10: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n    case 11: {\n      getOrthArea(0, o2, d, o1, left, result);\n      break;\n    }\n    case 12: {\n      getOrthArea(0, o1, d / 2, 0, left, a1);\n      getOrthArea(d / 2, 0, d, o1, left, a2);\n      smoothArea(d, area);\n      result[0] = a1[0] + a2[0];\n      result[1] = a1[1] + a2[1];\n      break;\n    }\n    case 13: {\n      getOrthArea(0, o2, d, o1, left, result);\n      break;\n    }\n    case 14: {\n      getOrthArea(0, o1, d, o2, left, result);\n      break;\n    }\n    case 15: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n  }\n  return result;\n}\nfunction isInsideArea(a1X, a1Y, a2X, a2Y, x, y) {\n  let result = a1X === a2X && a1Y === a2Y;\n  if (!result) {\n    const xm = (a1X + a2X) / 2;\n    const ym = (a1Y + a2Y) / 2;\n    const a = a2Y - a1Y;\n    const b = a1X - a2X;\n    const c2 = a * (x - xm) + b * (y - ym);\n    result = c2 > 0;\n  }\n  return result;\n}\nfunction getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, pX, pY) {\n  let n = 0;\n  for (let y = 0; y < DIAGONAL_SAMPLES; ++y) {\n    for (let x = 0; x < DIAGONAL_SAMPLES; ++x) {\n      const offsetX = x / (DIAGONAL_SAMPLES - 1);\n      const offsetY = y / (DIAGONAL_SAMPLES - 1);\n      if (isInsideArea(a1X, a1Y, a2X, a2Y, pX + offsetX, pY + offsetY)) {\n        ++n;\n      }\n    }\n  }\n  return n / (DIAGONAL_SAMPLES * DIAGONAL_SAMPLES);\n}\nfunction getDiagArea(pattern, a1X, a1Y, a2X, a2Y, left, offset, result) {\n  const e = diagonalEdges[pattern];\n  const e1 = e[0];\n  const e2 = e[1];\n  if (e1 > 0) {\n    a1X += offset[0];\n    a1Y += offset[1];\n  }\n  if (e2 > 0) {\n    a2X += offset[0];\n    a2Y += offset[1];\n  }\n  result[0] = 1 - getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 0 + left);\n  result[1] = getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 1 + left);\n  return result;\n}\nfunction getDiagAreaForPattern(pattern, left, right, offset, result) {\n  const a1 = area[0];\n  const a2 = area[1];\n  const d = left + right + 1;\n  switch (pattern) {\n    case 0: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 1: {\n      getDiagArea(pattern, 1, 0, 0 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 2: {\n      getDiagArea(pattern, 0, 0, 1 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 3: {\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, result);\n      break;\n    }\n    case 4: {\n      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 5: {\n      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 6: {\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, result);\n      break;\n    }\n    case 7: {\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 8: {\n      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 9: {\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n      break;\n    }\n    case 10: {\n      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 11: {\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 12: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, result);\n      break;\n    }\n    case 13: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 14: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 15: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n  }\n  return result;\n}\nfunction generatePatterns(patterns, offset, orthogonal) {\n  const result = new Float32Array(2);\n  for (let i = 0, l = patterns.length; i < l; ++i) {\n    const pattern = patterns[i];\n    const data = pattern.data;\n    const size = pattern.width;\n    for (let y = 0; y < size; ++y) {\n      for (let x = 0; x < size; ++x) {\n        if (orthogonal) {\n          getOrthAreaForPattern(i, x, y, offset, result);\n        } else {\n          getDiagAreaForPattern(i, x, y, offset, result);\n        }\n        const c2 = (y * size + x) * 2;\n        data[c2] = result[0] * 255;\n        data[c2 + 1] = result[1] * 255;\n      }\n    }\n  }\n}\nfunction assemble(baseX, baseY, patterns, edges2, size, orthogonal, target) {\n  const dstData = target.data;\n  const dstWidth = target.width;\n  for (let i = 0, l = patterns.length; i < l; ++i) {\n    const edge = edges2[i];\n    const pattern = patterns[i];\n    const srcData = pattern.data;\n    const srcWidth = pattern.width;\n    for (let y = 0; y < size; ++y) {\n      for (let x = 0; x < size; ++x) {\n        const pX = edge[0] * size + baseX + x;\n        const pY = edge[1] * size + baseY + y;\n        const c2 = (pY * dstWidth + pX) * 4;\n        const d = orthogonal ? (y * y * srcWidth + x * x) * 2 : (y * srcWidth + x) * 2;\n        dstData[c2] = srcData[d];\n        dstData[c2 + 1] = srcData[d + 1];\n        dstData[c2 + 2] = 0;\n        dstData[c2 + 3] = 255;\n      }\n    }\n  }\n}\nvar SMAAAreaImageData = class {\n  /**\n   * Creates a new area image.\n   *\n   * @return {RawImageData} The generated image data.\n   */\n  static generate() {\n    const width = 2 * 5 * ORTHOGONAL_SIZE;\n    const height = orthogonalSubsamplingOffsets.length * 5 * ORTHOGONAL_SIZE;\n    const data = new Uint8ClampedArray(width * height * 4);\n    const result = new RawImageData(width, height, data);\n    const orthPatternSize = Math.pow(ORTHOGONAL_SIZE - 1, 2) + 1;\n    const diagPatternSize = DIAGONAL_SIZE;\n    const orthogonalPatterns = [];\n    const diagonalPatterns = [];\n    for (let i = 3, l = data.length; i < l; i += 4) {\n      data[i] = 255;\n    }\n    for (let i = 0; i < 16; ++i) {\n      orthogonalPatterns.push(new RawImageData(\n        orthPatternSize,\n        orthPatternSize,\n        new Uint8ClampedArray(orthPatternSize * orthPatternSize * 2),\n        2\n      ));\n      diagonalPatterns.push(new RawImageData(\n        diagPatternSize,\n        diagPatternSize,\n        new Uint8ClampedArray(diagPatternSize * diagPatternSize * 2),\n        2\n      ));\n    }\n    for (let i = 0, l = orthogonalSubsamplingOffsets.length; i < l; ++i) {\n      generatePatterns(orthogonalPatterns, orthogonalSubsamplingOffsets[i], true);\n      assemble(\n        0,\n        5 * ORTHOGONAL_SIZE * i,\n        orthogonalPatterns,\n        orthogonalEdges,\n        ORTHOGONAL_SIZE,\n        true,\n        result\n      );\n    }\n    for (let i = 0, l = diagonalSubsamplingOffsets.length; i < l; ++i) {\n      generatePatterns(diagonalPatterns, diagonalSubsamplingOffsets[i], false);\n      assemble(\n        5 * ORTHOGONAL_SIZE,\n        4 * DIAGONAL_SIZE * i,\n        diagonalPatterns,\n        diagonalEdges,\n        DIAGONAL_SIZE,\n        false,\n        result\n      );\n    }\n    return result;\n  }\n};\n\n// src/textures/smaa/SMAAImageGenerator.js\n\n\n// tmp/smaa/worker.txt\nvar worker_default2 = '\"use strict\";(()=>{function q(t,a,s){let e=document.createElement(\"canvas\"),n=e.getContext(\"2d\");if(e.width=t,e.height=a,s instanceof Image)n.drawImage(s,0,0);else{let r=n.createImageData(t,a);r.data.set(s),n.putImageData(r,0,0)}return e}var F=class t{constructor(a=0,s=0,e=null){this.width=a,this.height=s,this.data=e}toCanvas(){return typeof document==\"undefined\"?null:q(this.width,this.height,this.data)}static from(a){let{width:s,height:e}=a,n;if(a instanceof Image){let r=q(s,e,a);r!==null&&(n=r.getContext(\"2d\").getImageData(0,0,s,e).data)}else n=a.data;return new t(s,e,n)}};var M=[new Float32Array(2),new Float32Array(2)],D=16,W=20,I=30,j=32,v=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),N=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],z=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],p=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function C(t,a,s){return t+(a-t)*s}function B(t){return Math.min(Math.max(t,0),1)}function _(t){let a=M[0],s=M[1],e=Math.sqrt(a[0]*2)*.5,n=Math.sqrt(a[1]*2)*.5,r=Math.sqrt(s[0]*2)*.5,o=Math.sqrt(s[1]*2)*.5,c=B(t/j);a[0]=C(e,a[0],c),a[1]=C(n,a[1],c),s[0]=C(r,s[0],c),s[1]=C(o,s[1],c)}function d(t,a,s,e,n,r){let o=s-t,c=e-a,h=n,i=n+1,w=a+c*(h-t)/o,b=a+c*(i-t)/o;if(h>=t&&h<s||i>t&&i<=s)if(Math.sign(w)===Math.sign(b)||Math.abs(w)<1e-4||Math.abs(b)<1e-4){let g=(w+b)/2;g<0?(r[0]=Math.abs(g),r[1]=0):(r[0]=0,r[1]=Math.abs(g))}else{let g=-a*o/c+t,k=Math.trunc(g),m=g>t?w*(g-k)/2:0,U=g<s?b*(1-(g-k))/2:0;(Math.abs(m)>Math.abs(U)?m:-U)<0?(r[0]=Math.abs(m),r[1]=Math.abs(U)):(r[0]=Math.abs(U),r[1]=Math.abs(m))}else r[0]=0,r[1]=0;return r}function J(t,a,s,e,n){let r=M[0],o=M[1],c=.5+e,h=.5+e-1,i=a+s+1;switch(t){case 0:{n[0]=0,n[1]=0;break}case 1:{a<=s?d(0,h,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 2:{a>=s?d(i/2,0,i,h,a,n):(n[0]=0,n[1]=0);break}case 3:{d(0,h,i/2,0,a,r),d(i/2,0,i,h,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 4:{a<=s?d(0,c,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 5:{n[0]=0,n[1]=0;break}case 6:{Math.abs(e)>0?(d(0,c,i,h,a,r),d(0,c,i/2,0,a,o),d(i/2,0,i,h,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,c,i,h,a,n);break}case 7:{d(0,c,i,h,a,n);break}case 8:{a>=s?d(i/2,0,i,c,a,n):(n[0]=0,n[1]=0);break}case 9:{Math.abs(e)>0?(d(0,h,i,c,a,r),d(0,h,i/2,0,a,o),d(i/2,0,i,c,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,h,i,c,a,n);break}case 10:{n[0]=0,n[1]=0;break}case 11:{d(0,h,i,c,a,n);break}case 12:{d(0,c,i/2,0,a,r),d(i/2,0,i,c,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 13:{d(0,h,i,c,a,n);break}case 14:{d(0,c,i,h,a,n);break}case 15:{n[0]=0,n[1]=0;break}}return n}function K(t,a,s,e,n,r){let o=t===s&&a===e;if(!o){let c=(t+s)/2,h=(a+e)/2,i=e-a,w=t-s;o=i*(n-c)+w*(r-h)>0}return o}function G(t,a,s,e,n,r){let o=0;for(let c=0;c<I;++c)for(let h=0;h<I;++h){let i=h/(I-1),w=c/(I-1);K(t,a,s,e,n+i,r+w)&&++o}return o/(I*I)}function A(t,a,s,e,n,r,o,c){let h=p[t],i=h[0],w=h[1];return i>0&&(a+=o[0],s+=o[1]),w>0&&(e+=o[0],n+=o[1]),c[0]=1-G(a,s,e,n,1+r,0+r),c[1]=G(a,s,e,n,1+r,1+r),c}function Q(t,a,s,e,n){let r=M[0],o=M[1],c=a+s+1;switch(t){case 0:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 1:{A(t,1,0,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 2:{A(t,0,0,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 3:{A(t,1,0,1+c,0+c,a,e,n);break}case 4:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 5:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 6:{A(t,1,1,1+c,0+c,a,e,n);break}case 7:{A(t,1,1,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 8:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 9:{A(t,1,0,1+c,1+c,a,e,n),A(t,1,0,1+c,1+c,a,e,n);break}case 10:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 11:{A(t,1,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 12:{A(t,1,1,1+c,1+c,a,e,n);break}case 13:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 14:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 15:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}}return n}function R(t,a,s){let e=new Float32Array(2);for(let n=0,r=t.length;n<r;++n){let o=t[n],c=o.data,h=o.width;for(let i=0;i<h;++i)for(let w=0;w<h;++w){s?J(n,w,i,a,e):Q(n,w,i,a,e);let b=(i*h+w)*2;c[b]=e[0]*255,c[b+1]=e[1]*255}}}function T(t,a,s,e,n,r,o){let c=o.data,h=o.width;for(let i=0,w=s.length;i<w;++i){let b=e[i],g=s[i],k=g.data,m=g.width;for(let U=0;U<n;++U)for(let x=0;x<n;++x){let Z=b[0]*n+t+x,O=((b[1]*n+a+U)*h+Z)*4,L=r?(U*U*m+x*x)*2:(U*m+x)*2;c[O]=k[L],c[O+1]=k[L+1],c[O+2]=0,c[O+3]=255}}}var S=class{static generate(){let a=10*D,s=v.length*5*D,e=new Uint8ClampedArray(a*s*4),n=new F(a,s,e),r=Math.pow(D-1,2)+1,o=W,c=[],h=[];for(let i=3,w=e.length;i<w;i+=4)e[i]=255;for(let i=0;i<16;++i)c.push(new F(r,r,new Uint8ClampedArray(r*r*2),2)),h.push(new F(o,o,new Uint8ClampedArray(o*o*2),2));for(let i=0,w=v.length;i<w;++i)R(c,v[i],!0),T(0,5*D*i,c,z,D,!0,n);for(let i=0,w=N.length;i<w;++i)R(h,N[i],!1),T(5*D,4*W*i,h,p,W,!1,n);return n}};var P=new Map([[y(0,0,0,0),new Float32Array([0,0,0,0])],[y(0,0,0,1),new Float32Array([0,0,0,1])],[y(0,0,1,0),new Float32Array([0,0,1,0])],[y(0,0,1,1),new Float32Array([0,0,1,1])],[y(0,1,0,0),new Float32Array([0,1,0,0])],[y(0,1,0,1),new Float32Array([0,1,0,1])],[y(0,1,1,0),new Float32Array([0,1,1,0])],[y(0,1,1,1),new Float32Array([0,1,1,1])],[y(1,0,0,0),new Float32Array([1,0,0,0])],[y(1,0,0,1),new Float32Array([1,0,0,1])],[y(1,0,1,0),new Float32Array([1,0,1,0])],[y(1,0,1,1),new Float32Array([1,0,1,1])],[y(1,1,0,0),new Float32Array([1,1,0,0])],[y(1,1,0,1),new Float32Array([1,1,0,1])],[y(1,1,1,0),new Float32Array([1,1,1,0])],[y(1,1,1,1),new Float32Array([1,1,1,1])]]);function H(t,a,s){return t+(a-t)*s}function y(t,a,s,e){let n=H(t,a,.75),r=H(s,e,1-.25);return H(n,r,1-.125)}function V(t,a){let s=0;return a[3]===1&&(s+=1),s===1&&a[2]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s}function $(t,a){let s=0;return a[3]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s===1&&a[2]===1&&t[0]!==1&&t[2]!==1&&(s+=1),s}var E=class{static generate(){let o=new Uint8ClampedArray(2178),c=new Uint8ClampedArray(64*16*4);for(let h=0;h<33;++h)for(let i=0;i<66;++i){let w=.03125*i,b=.03125*h;if(P.has(w)&&P.has(b)){let g=P.get(w),k=P.get(b),m=h*66+i;o[m]=127*V(g,k),o[m+33]=127*$(g,k)}}for(let h=0,i=17;i<33;++i)for(let w=0;w<64;++w,h+=4)c[h]=o[i*66+w],c[h+3]=255;return new F(64,16,c)}};self.addEventListener(\"message\",t=>{let a=S.generate(),s=E.generate();postMessage({areaImageData:a,searchImageData:s},[a.data.buffer,s.data.buffer]),close()});})();\\n';\n\n// src/textures/smaa/SMAAImageGenerator.js\nfunction generate(useCache = true) {\n  const workerURL = URL.createObjectURL(new Blob([worker_default2], {\n    type: \"text/javascript\"\n  }));\n  const worker = new Worker(workerURL);\n  URL.revokeObjectURL(workerURL);\n  return new Promise((resolve, reject) => {\n    worker.addEventListener(\"error\", (event) => reject(event.error));\n    worker.addEventListener(\"message\", (event) => {\n      const searchImageData = RawImageData.from(event.data.searchImageData);\n      const areaImageData = RawImageData.from(event.data.areaImageData);\n      const urls = [\n        searchImageData.toCanvas().toDataURL(\"image/png\", 1),\n        areaImageData.toCanvas().toDataURL(\"image/png\", 1)\n      ];\n      if (useCache) {\n        localStorage.setItem(\"smaa-search\", urls[0]);\n        localStorage.setItem(\"smaa-area\", urls[1]);\n      }\n      resolve(urls);\n    });\n    worker.postMessage(null);\n  });\n}\nvar SMAAImageGenerator = class {\n  /**\n   * Constructs a new SMAA image generator.\n   */\n  constructor() {\n    this.disableCache = false;\n  }\n  /**\n   * Enables or disables caching via localStorage.\n   *\n   * @param {Boolean} value - Whether the cache should be enabled.\n   */\n  setCacheEnabled(value) {\n    this.disableCache = !value;\n  }\n  /**\n   * Generates the SMAA data images.\n   *\n   * @example\n   * SMAAImageGenerator.generate().then(([search, area]) => {\n   *   const smaaEffect = new SMAAEffect(search, area);\n   * });\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */\n  generate() {\n    const useCache = !this.disableCache && window.localStorage !== void 0;\n    const cachedURLs = useCache ? [\n      localStorage.getItem(\"smaa-search\"),\n      localStorage.getItem(\"smaa-area\")\n    ] : [null, null];\n    const promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : generate(useCache);\n    return promise.then((urls) => {\n      return new Promise((resolve, reject) => {\n        const searchImage = new Image();\n        const areaImage = new Image();\n        const manager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        manager.onLoad = () => resolve([searchImage, areaImage]);\n        manager.onError = reject;\n        searchImage.addEventListener(\"error\", (e) => manager.itemError(\"smaa-search\"));\n        areaImage.addEventListener(\"error\", (e) => manager.itemError(\"smaa-area\"));\n        searchImage.addEventListener(\"load\", () => manager.itemEnd(\"smaa-search\"));\n        areaImage.addEventListener(\"load\", () => manager.itemEnd(\"smaa-area\"));\n        manager.itemStart(\"smaa-search\");\n        manager.itemStart(\"smaa-area\");\n        searchImage.src = urls[0];\n        areaImage.src = urls[1];\n      });\n    });\n  }\n};\n\n// src/textures/smaa/SMAASearchImageData.js\nvar edges = /* @__PURE__ */ new Map([\n  [bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],\n  [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],\n  [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],\n  [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],\n  [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],\n  [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],\n  [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],\n  [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],\n  [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],\n  [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],\n  [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],\n  [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],\n  [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],\n  [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],\n  [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],\n  [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]\n]);\nfunction lerp2(a, b, p) {\n  return a + (b - a) * p;\n}\nfunction bilinear(e0, e1, e2, e3) {\n  const a = lerp2(e0, e1, 1 - 0.25);\n  const b = lerp2(e2, e3, 1 - 0.25);\n  return lerp2(a, b, 1 - 0.125);\n}\nfunction deltaLeft(left, top) {\n  let d = 0;\n  if (top[3] === 1) {\n    d += 1;\n  }\n  if (d === 1 && top[2] === 1 && left[1] !== 1 && left[3] !== 1) {\n    d += 1;\n  }\n  return d;\n}\nfunction deltaRight(left, top) {\n  let d = 0;\n  if (top[3] === 1 && left[1] !== 1 && left[3] !== 1) {\n    d += 1;\n  }\n  if (d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {\n    d += 1;\n  }\n  return d;\n}\nvar SMAASearchImageData = class {\n  /**\n   * Creates a new search image.\n   *\n   * @return {RawImageData} The generated image data.\n   */\n  static generate() {\n    const width = 66;\n    const height = 33;\n    const halfWidth = width / 2;\n    const croppedWidth = 64;\n    const croppedHeight = 16;\n    const data = new Uint8ClampedArray(width * height);\n    const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        const s = 0.03125 * x;\n        const t = 0.03125 * y;\n        if (edges.has(s) && edges.has(t)) {\n          const e1 = edges.get(s);\n          const e2 = edges.get(t);\n          const i = y * width + x;\n          data[i] = 127 * deltaLeft(e1, e2);\n          data[i + halfWidth] = 127 * deltaRight(e1, e2);\n        }\n      }\n    }\n    for (let i = 0, y = height - croppedHeight; y < height; ++y) {\n      for (let x = 0; x < croppedWidth; ++x, i += 4) {\n        croppedData[i] = data[y * width + x];\n        croppedData[i + 3] = 255;\n      }\n    }\n    return new RawImageData(croppedWidth, croppedHeight, croppedData);\n  }\n};\n\n// src/textures/NoiseTexture.js\n\nfunction getNoise(size, format, type) {\n  const channels = /* @__PURE__ */ new Map([\n    [three__WEBPACK_IMPORTED_MODULE_0__.LuminanceFormat, 1],\n    [three__WEBPACK_IMPORTED_MODULE_0__.RedFormat, 1],\n    [three__WEBPACK_IMPORTED_MODULE_0__.RGFormat, 2],\n    [three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, 4]\n  ]);\n  let data;\n  if (!channels.has(format)) {\n    console.error(\"Invalid noise texture format\");\n  }\n  if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n    data = new Uint8Array(size * channels.get(format));\n    for (let i = 0, l = data.length; i < l; ++i) {\n      data[i] = Math.random() * 255 + 0.5;\n    }\n  } else {\n    data = new Float32Array(size * channels.get(format));\n    for (let i = 0, l = data.length; i < l; ++i) {\n      data[i] = Math.random();\n    }\n  }\n  return data;\n}\nvar NoiseTexture = class extends three__WEBPACK_IMPORTED_MODULE_0__.DataTexture {\n  /**\n   * Constructs a new noise texture.\n   *\n   * The texture format can be either `LuminanceFormat` or `RGBAFormat`. Additionally, the formats `RedFormat` and\n   * `RGFormat` can be used in a WebGL 2 context.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Number} [format=LuminanceFormat] - The texture format.\n   * @param {Number} [type=UnsignedByteType] - The texture type.\n   */\n  constructor(width, height, format = three__WEBPACK_IMPORTED_MODULE_0__.LuminanceFormat, type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n    super(getNoise(width * height, format, type), width, height, format, type);\n    this.needsUpdate = true;\n  }\n};\n\n// src/effects/glsl/glitch.frag\nvar glitch_default = \"uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}\";\n\n// src/effects/GlitchEffect.js\nvar textureTag = \"Glitch.Generated\";\nfunction randomFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\nvar GlitchEffect = class extends Effect {\n  /**\n   * Constructs a new glitch effect.\n   *\n   * TODO Change ratio to 0.15.\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.chromaticAberrationOffset] - A chromatic aberration offset. If provided, the glitch effect will influence this offset.\n   * @param {Vector2} [options.delay] - The minimum and maximum delay between glitch activations in seconds.\n   * @param {Vector2} [options.duration] - The minimum and maximum duration of a glitch in seconds.\n   * @param {Vector2} [options.strength] - The strength of weak and strong glitches.\n   * @param {Texture} [options.perturbationMap] - A perturbation map. If none is provided, a noise texture will be created.\n   * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.\n   * @param {Number} [options.columns=0.05] - The scale of the blocky glitch columns.\n   * @param {Number} [options.ratio=0.85] - The threshold for strong glitches.\n   */\n  constructor({\n    chromaticAberrationOffset = null,\n    delay = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1.5, 3.5),\n    duration = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.6, 1),\n    strength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.3, 1),\n    columns = 0.05,\n    ratio = 0.85,\n    perturbationMap = null,\n    dtSize = 64\n  } = {}) {\n    super(\"GlitchEffect\", glitch_default, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"perturbationMap\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"columns\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(columns)],\n        [\"active\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)],\n        [\"random\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"seeds\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"distortion\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())]\n      ])\n    });\n    if (perturbationMap === null) {\n      const map = new NoiseTexture(dtSize, dtSize, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n      map.name = textureTag;\n      this.perturbationMap = map;\n    } else {\n      this.perturbationMap = perturbationMap;\n    }\n    this.time = 0;\n    this.distortion = this.uniforms.get(\"distortion\").value;\n    this.delay = delay;\n    this.duration = duration;\n    this.breakPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(\n      randomFloat(this.delay.x, this.delay.y),\n      randomFloat(this.duration.x, this.duration.y)\n    );\n    this.strength = strength;\n    this.mode = GlitchMode.SPORADIC;\n    this.ratio = ratio;\n    this.chromaticAberrationOffset = chromaticAberrationOffset;\n  }\n  /**\n   * Random number seeds.\n   *\n   * @type {Vector2}\n   * @private\n   */\n  get seeds() {\n    return this.uniforms.get(\"seeds\").value;\n  }\n  /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @type {Boolean}\n   */\n  get active() {\n    return this.uniforms.get(\"active\").value;\n  }\n  /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @deprecated Use active instead.\n   * @return {Boolean} Whether the glitch effect is active.\n   */\n  isActive() {\n    return this.active;\n  }\n  /**\n   * The minimum delay between glitch activations.\n   *\n   * @type {Number}\n   */\n  get minDelay() {\n    return this.delay.x;\n  }\n  set minDelay(value) {\n    this.delay.x = value;\n  }\n  /**\n   * Returns the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @return {Number} The minimum delay in seconds.\n   */\n  getMinDelay() {\n    return this.delay.x;\n  }\n  /**\n   * Sets the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @param {Number} value - The minimum delay in seconds.\n   */\n  setMinDelay(value) {\n    this.delay.x = value;\n  }\n  /**\n   * The maximum delay between glitch activations.\n   *\n   * @type {Number}\n   */\n  get maxDelay() {\n    return this.delay.y;\n  }\n  set maxDelay(value) {\n    this.delay.y = value;\n  }\n  /**\n   * Returns the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @return {Number} The maximum delay in seconds.\n   */\n  getMaxDelay() {\n    return this.delay.y;\n  }\n  /**\n   * Sets the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @param {Number} value - The maximum delay in seconds.\n   */\n  setMaxDelay(value) {\n    this.delay.y = value;\n  }\n  /**\n   * The minimum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */\n  get minDuration() {\n    return this.duration.x;\n  }\n  set minDuration(value) {\n    this.duration.x = value;\n  }\n  /**\n   * Returns the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @return {Number} The minimum duration in seconds.\n   */\n  getMinDuration() {\n    return this.duration.x;\n  }\n  /**\n   * Sets the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @param {Number} value - The minimum duration in seconds.\n   */\n  setMinDuration(value) {\n    this.duration.x = value;\n  }\n  /**\n   * The maximum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */\n  get maxDuration() {\n    return this.duration.y;\n  }\n  set maxDuration(value) {\n    this.duration.y = value;\n  }\n  /**\n   * Returns the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @return {Number} The maximum duration in seconds.\n   */\n  getMaxDuration() {\n    return this.duration.y;\n  }\n  /**\n   * Sets the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @param {Number} value - The maximum duration in seconds.\n   */\n  setMaxDuration(value) {\n    this.duration.y = value;\n  }\n  /**\n   * The strength of weak glitches.\n   *\n   * @type {Number}\n   */\n  get minStrength() {\n    return this.strength.x;\n  }\n  set minStrength(value) {\n    this.strength.x = value;\n  }\n  /**\n   * Returns the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @return {Number} The strength.\n   */\n  getMinStrength() {\n    return this.strength.x;\n  }\n  /**\n   * Sets the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @param {Number} value - The strength.\n   */\n  setMinStrength(value) {\n    this.strength.x = value;\n  }\n  /**\n   * The strength of strong glitches.\n   *\n   * @type {Number}\n   */\n  get maxStrength() {\n    return this.strength.y;\n  }\n  set maxStrength(value) {\n    this.strength.y = value;\n  }\n  /**\n   * Returns the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @return {Number} The strength.\n   */\n  getMaxStrength() {\n    return this.strength.y;\n  }\n  /**\n   * Sets the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @param {Number} value - The strength.\n   */\n  setMaxStrength(value) {\n    this.strength.y = value;\n  }\n  /**\n   * Returns the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {GlitchMode} The mode.\n   */\n  getMode() {\n    return this.mode;\n  }\n  /**\n   * Sets the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {GlitchMode} value - The mode.\n   */\n  setMode(value) {\n    this.mode = value;\n  }\n  /**\n   * Returns the glitch ratio.\n   *\n   * @deprecated Use ratio instead.\n   * @return {Number} The ratio.\n   */\n  getGlitchRatio() {\n    return 1 - this.ratio;\n  }\n  /**\n   * Sets the ratio of weak (0.0) and strong (1.0) glitches.\n   *\n   * @deprecated Use ratio instead.\n   * @param {Number} value - The ratio. Range is [0.0, 1.0].\n   */\n  setGlitchRatio(value) {\n    this.ratio = Math.min(Math.max(1 - value, 0), 1);\n  }\n  /**\n   * The glitch column size.\n   *\n   * @type {Number}\n   */\n  get columns() {\n    return this.uniforms.get(\"columns\").value;\n  }\n  set columns(value) {\n    this.uniforms.get(\"columns\").value = value;\n  }\n  /**\n   * Returns the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @return {Number} The glitch column size.\n   */\n  getGlitchColumns() {\n    return this.columns;\n  }\n  /**\n   * Sets the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @param {Number} value - The glitch column size.\n   */\n  setGlitchColumns(value) {\n    this.columns = value;\n  }\n  /**\n   * Returns the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @return {Vector2} The offset.\n   */\n  getChromaticAberrationOffset() {\n    return this.chromaticAberrationOffset;\n  }\n  /**\n   * Sets the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @param {Vector2} value - The offset.\n   */\n  setChromaticAberrationOffset(value) {\n    this.chromaticAberrationOffset = value;\n  }\n  /**\n   * The perturbation map.\n   *\n   * @type {Texture}\n   */\n  get perturbationMap() {\n    return this.uniforms.get(\"perturbationMap\").value;\n  }\n  set perturbationMap(value) {\n    const currentMap = this.perturbationMap;\n    if (currentMap !== null && currentMap.name === textureTag) {\n      currentMap.dispose();\n    }\n    value.minFilter = value.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n    value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n    value.generateMipmaps = false;\n    this.uniforms.get(\"perturbationMap\").value = value;\n  }\n  /**\n   * Returns the current perturbation map.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @return {Texture} The current perturbation map.\n   */\n  getPerturbationMap() {\n    return this.perturbationMap;\n  }\n  /**\n   * Replaces the current perturbation map with the given one.\n   *\n   * The current map will be disposed if it was generated by this effect.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @param {Texture} value - The new perturbation map.\n   */\n  setPerturbationMap(value) {\n    this.perturbationMap = value;\n  }\n  /**\n   * Generates a perturbation map.\n   *\n   * @deprecated Use NoiseTexture instead.\n   * @param {Number} [value=64] - The texture size.\n   * @return {DataTexture} The perturbation map.\n   */\n  generatePerturbationMap(value = 64) {\n    const map = new NoiseTexture(value, value, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n    map.name = textureTag;\n    return map;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const mode = this.mode;\n    const breakPoint = this.breakPoint;\n    const offset = this.chromaticAberrationOffset;\n    const s = this.strength;\n    let time = this.time;\n    let active = false;\n    let r = 0, a = 0;\n    let trigger;\n    if (mode !== GlitchMode.DISABLED) {\n      if (mode === GlitchMode.SPORADIC) {\n        time += deltaTime;\n        trigger = time > breakPoint.x;\n        if (time >= breakPoint.x + breakPoint.y) {\n          breakPoint.set(\n            randomFloat(this.delay.x, this.delay.y),\n            randomFloat(this.duration.x, this.duration.y)\n          );\n          time = 0;\n        }\n      }\n      r = Math.random();\n      this.uniforms.get(\"random\").value = r;\n      if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {\n        active = true;\n        r *= s.y * 0.03;\n        a = randomFloat(-Math.PI, Math.PI);\n        this.seeds.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));\n        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n      } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {\n        active = true;\n        r *= s.x * 0.03;\n        a = randomFloat(-Math.PI, Math.PI);\n        this.seeds.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));\n        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n      }\n      this.time = time;\n    }\n    if (offset !== null) {\n      if (active) {\n        offset.set(Math.cos(a), Math.sin(a)).multiplyScalar(r);\n      } else {\n        offset.set(0, 0);\n      }\n    }\n    this.uniforms.get(\"active\").value = active;\n  }\n  /**\n   * Deletes generated resources.\n   */\n  dispose() {\n    const map = this.perturbationMap;\n    if (map !== null && map.name === textureTag) {\n      map.dispose();\n    }\n  }\n};\n\n// src/effects/GodRaysEffect.js\n\n\n// src/effects/glsl/god-rays.frag\nvar god_rays_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}\";\n\n// src/effects/GodRaysEffect.js\nvar v = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar m = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nvar GodRaysEffect = class extends Effect {\n  /**\n   * Constructs a new god rays effect.\n   *\n   * @param {Camera} [camera] - The main camera.\n   * @param {Mesh|Points} [lightSource] - The light source. Must not write depth and has to be flagged as transparent.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.samples=60.0] - The number of samples per pixel.\n   * @param {Number} [options.density=0.96] - The density of the light rays.\n   * @param {Number} [options.decay=0.9] - An illumination decay factor.\n   * @param {Number} [options.weight=0.4] - A light ray weight factor.\n   * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.\n   * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   * @param {KernelSize} [options.kernelSize=KernelSize.SMALL] - The blur kernel size. Has no effect if blur is disabled.\n   * @param {Boolean} [options.blur=true] - Whether the god rays should be blurred to reduce artifacts.\n   */\n  constructor(camera, lightSource, {\n    blendFunction = BlendFunction.SCREEN,\n    samples = 60,\n    density = 0.96,\n    decay = 0.9,\n    weight = 0.4,\n    exposure = 0.6,\n    clampMax = 1,\n    blur = true,\n    kernelSize = KernelSize.SMALL,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"GodRaysEffect\", god_rays_default, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.camera = camera;\n    this._lightSource = lightSource;\n    this.lightSource = lightSource;\n    this.lightScene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n    this.screenPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"GodRays.Target.A\";\n    this.renderTargetB = this.renderTargetA.clone();\n    this.renderTargetB.texture.name = \"GodRays.Target.B\";\n    this.uniforms.get(\"map\").value = this.renderTargetB.texture;\n    this.renderTargetLight = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n    this.renderTargetLight.texture.name = \"GodRays.Light\";\n    this.renderTargetLight.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n    this.renderPassLight = new RenderPass(this.lightScene, camera);\n    this.renderPassLight.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.clearPass = new ClearPass(true, false, false);\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.blurPass = new KawaseBlurPass({ kernelSize });\n    this.blurPass.enabled = blur;\n    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n    const depthMaskMaterial = this.depthMaskMaterial;\n    depthMaskMaterial.depthBuffer1 = this.renderTargetLight.depthTexture;\n    depthMaskMaterial.copyCameraSettings(camera);\n    this.godRaysPass = new ShaderPass(new GodRaysMaterial(this.screenPosition));\n    const godRaysMaterial = this.godRaysMaterial;\n    godRaysMaterial.density = density;\n    godRaysMaterial.decay = decay;\n    godRaysMaterial.weight = weight;\n    godRaysMaterial.exposure = exposure;\n    godRaysMaterial.maxIntensity = clampMax;\n    godRaysMaterial.samples = samples;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.renderPassLight.mainCamera = value;\n    this.depthMaskMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Sets the light source.\n   *\n   * @type {Mesh|Points}\n   */\n  get lightSource() {\n    return this._lightSource;\n  }\n  set lightSource(value) {\n    this._lightSource = value;\n    if (value !== null) {\n      value.material.depthWrite = false;\n      value.material.transparent = true;\n    }\n  }\n  /**\n   * Returns the blur pass that reduces aliasing artifacts and makes the light softer.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTargetB.texture;\n  }\n  /**\n   * Returns the god rays texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.texture;\n  }\n  /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */\n  get depthMaskMaterial() {\n    return this.depthMaskPass.fullscreenMaterial;\n  }\n  /**\n   * The internal god rays material.\n   *\n   * @type {GodRaysMaterial}\n   */\n  get godRaysMaterial() {\n    return this.godRaysPass.fullscreenMaterial;\n  }\n  /**\n   * Returns the god rays material.\n   *\n   * @deprecated Use godRaysMaterial instead.\n   * @return {GodRaysMaterial} The material.\n   */\n  getGodRaysMaterial() {\n    return this.godRaysMaterial;\n  }\n  /**\n   * Returns the resolution of this effect.\n   *\n   * @deprecated Use resolution instead.\n   * @return {GodRaysMaterial} The material.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get dithering() {\n    return this.godRaysMaterial.dithering;\n  }\n  set dithering(value) {\n    const material = this.godRaysMaterial;\n    material.dithering = value;\n    material.needsUpdate = true;\n  }\n  /**\n   * Indicates whether the god rays should be blurred to reduce artifacts.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */\n  get blur() {\n    return this.blurPass.enabled;\n  }\n  set blur(value) {\n    this.blurPass.enabled = value;\n  }\n  /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */\n  get kernelSize() {\n    return this.blurPass.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurPass.kernelSize = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * The number of samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */\n  get samples() {\n    return this.godRaysMaterial.samples;\n  }\n  /**\n   * A higher sample count improves quality at the cost of performance.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */\n  set samples(value) {\n    this.godRaysMaterial.samples = value;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {Number} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthMaskPass.fullscreenMaterial.depthBuffer0 = depthTexture;\n    this.depthMaskPass.fullscreenMaterial.depthPacking0 = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const lightSource = this.lightSource;\n    const parent = lightSource.parent;\n    const matrixAutoUpdate = lightSource.matrixAutoUpdate;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetLight = this.renderTargetLight;\n    lightSource.material.depthWrite = true;\n    lightSource.matrixAutoUpdate = false;\n    lightSource.updateWorldMatrix(true, false);\n    if (parent !== null) {\n      if (!matrixAutoUpdate) {\n        m.copy(lightSource.matrix);\n      }\n      lightSource.matrix.copy(lightSource.matrixWorld);\n    }\n    this.lightScene.add(lightSource);\n    this.renderPassLight.render(renderer, renderTargetLight);\n    this.clearPass.render(renderer, renderTargetA);\n    this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);\n    lightSource.material.depthWrite = false;\n    lightSource.matrixAutoUpdate = matrixAutoUpdate;\n    if (parent !== null) {\n      if (!matrixAutoUpdate) {\n        lightSource.matrix.copy(m);\n      }\n      parent.add(lightSource);\n    }\n    v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);\n    this.screenPosition.set(\n      Math.min(Math.max((v.x + 1) * 0.5, -1), 2),\n      Math.min(Math.max((v.y + 1) * 0.5, -1), 2)\n    );\n    if (this.blurPass.enabled) {\n      this.blurPass.render(renderer, renderTargetA, renderTargetA);\n    }\n    this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.renderTargetLight.setSize(w, h);\n    this.blurPass.resolution.copy(resolution);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, frameBufferType);\n    this.renderPassLight.initialize(renderer, alpha, frameBufferType);\n    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n    this.godRaysPass.initialize(renderer, alpha, frameBufferType);\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      this.renderTargetLight.texture.type = frameBufferType;\n      if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n        setTextureColorSpace(this.renderTargetLight.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/effects/GridEffect.js\n\n\n// src/effects/glsl/grid.frag\nvar grid_default = \"uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}\";\n\n// src/effects/GridEffect.js\nvar GridEffect = class extends Effect {\n  /**\n   * Constructs a new grid effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.scale=1.0] - The scale of the grid pattern.\n   * @param {Number} [options.lineWidth=0.0] - The line width of the grid pattern.\n   */\n  constructor({ blendFunction = BlendFunction.OVERLAY, scale = 1, lineWidth = 0 } = {}) {\n    super(\"GridEffect\", grid_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"lineWidth\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lineWidth)]\n      ])\n    });\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.s = 0;\n    this.scale = scale;\n    this.l = 0;\n    this.lineWidth = lineWidth;\n  }\n  /**\n   * The scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.s;\n  }\n  set scale(value) {\n    this.s = Math.max(value, 1e-6);\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the current grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The grid scale.\n   */\n  getScale() {\n    return this.scale;\n  }\n  /**\n   * Sets the grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The new grid scale.\n   */\n  setScale(value) {\n    this.scale = value;\n  }\n  /**\n   * The line width.\n   *\n   * @type {Number}\n   */\n  get lineWidth() {\n    return this.l;\n  }\n  set lineWidth(value) {\n    this.l = value;\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the current grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @return {Number} The grid line width.\n   */\n  getLineWidth() {\n    return this.lineWidth;\n  }\n  /**\n   * Sets the grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @param {Number} value - The new grid line width.\n   */\n  setLineWidth(value) {\n    this.lineWidth = value;\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.resolution.set(width, height);\n    const aspect = width / height;\n    const scale = this.scale * (height * 0.125);\n    this.uniforms.get(\"scale\").value.set(aspect * scale, scale);\n    this.uniforms.get(\"lineWidth\").value = scale / height + this.lineWidth;\n  }\n};\n\n// src/effects/HueSaturationEffect.js\n\n\n// src/effects/glsl/hue-saturation.frag\nvar hue_saturation_default = \"uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}\";\n\n// src/effects/HueSaturationEffect.js\nvar HueSaturationEffect = class extends Effect {\n  /**\n   * Constructs a new hue/saturation effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.hue=0.0] - The hue in radians.\n   * @param {Number} [options.saturation=0.0] - The saturation factor, ranging from -1 to 1, where 0 means no change.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, hue = 0, saturation = 0 } = {}) {\n    super(\"HueSaturationEffect\", hue_saturation_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"hue\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())],\n        [\"saturation\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(saturation)]\n      ])\n    });\n    this.hue = hue;\n  }\n  /**\n   * The saturation.\n   *\n   * @type {Number}\n   */\n  get saturation() {\n    return this.uniforms.get(\"saturation\").value;\n  }\n  set saturation(value) {\n    this.uniforms.get(\"saturation\").value = value;\n  }\n  /**\n   * Returns the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @return {Number} The saturation.\n   */\n  getSaturation() {\n    return this.saturation;\n  }\n  /**\n   * Sets the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @param {Number} value - The saturation.\n   */\n  setSaturation(value) {\n    this.saturation = value;\n  }\n  /**\n   * The hue.\n   *\n   * @type {Number}\n   */\n  get hue() {\n    const hue = this.uniforms.get(\"hue\").value;\n    return Math.acos((hue.x * 3 - 1) / 2);\n  }\n  set hue(value) {\n    const s = Math.sin(value), c2 = Math.cos(value);\n    this.uniforms.get(\"hue\").value.set(\n      (2 * c2 + 1) / 3,\n      (-Math.sqrt(3) * s - c2 + 1) / 3,\n      (Math.sqrt(3) * s - c2 + 1) / 3\n    );\n  }\n  /**\n   * Returns the hue.\n   *\n   * @deprecated Use hue instead.\n   * @return {Number} The hue in radians.\n   */\n  getHue() {\n    return this.hue;\n  }\n  /**\n   * Sets the hue.\n   *\n   * @deprecated Use hue instead.\n   * @param {Number} value - The hue in radians.\n   */\n  setHue(value) {\n    this.hue = value;\n  }\n};\n\n// src/effects/LensDistortionEffect.js\n\n\n// src/effects/glsl/lens-distortion.frag\nvar lens_distortion_default = \"uniform vec2 distortion;uniform vec2 principalPoint;uniform vec2 focalLength;uniform float skew;float mask(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void mainUv(inout vec2 uv){vec2 xn=2.0*(uv.st-0.5);vec3 xDistorted=vec3((1.0+distortion*dot(xn,xn))*xn,1.0);mat3 kk=mat3(vec3(focalLength.x,0.0,0.0),vec3(skew*focalLength.x,focalLength.y,0.0),vec3(principalPoint.x,principalPoint.y,1.0));uv=(kk*xDistorted).xy*0.5+0.5;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=mask(uv)*inputColor;}\";\n\n// src/effects/LensDistortionEffect.js\nvar LensDistortionEffect = class extends Effect {\n  /**\n   * Constructs a new lens distortion effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.distortion] - The distortion value.\n   * @param {Vector2} [options.principalPoint] - The center point.\n   * @param {Vector2} [options.focalLength] - The focal length.\n   * @param {Number} [options.skew=0] - The skew value.\n   */\n  constructor({\n    distortion = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    principalPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    focalLength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),\n    skew = 0\n  } = {}) {\n    super(\"LensDistortionEffect\", lens_distortion_default, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"distortion\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(distortion)],\n        [\"principalPoint\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(principalPoint)],\n        [\"focalLength\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)],\n        [\"skew\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(skew)]\n      ])\n    });\n  }\n  /**\n   * The radial distortion coefficients. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */\n  get distortion() {\n    return this.uniforms.get(\"distortion\").value;\n  }\n  set distortion(value) {\n    this.uniforms.get(\"distortion\").value = value;\n  }\n  /**\n   * The principal point. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */\n  get principalPoint() {\n    return this.uniforms.get(\"principalPoint\").value;\n  }\n  set principalPoint(value) {\n    this.uniforms.get(\"principalPoint\").value = value;\n  }\n  /**\n   * The focal length. Default is (1, 1).\n   *\n   * @type {Vector2}\n   */\n  get focalLength() {\n    return this.uniforms.get(\"focalLength\").value;\n  }\n  set focalLength(value) {\n    this.uniforms.get(\"focalLength\").value = value;\n  }\n  /**\n   * The skew factor in radians.\n   *\n   * @type {Number}\n   */\n  get skew() {\n    return this.uniforms.get(\"skew\").value;\n  }\n  set skew(value) {\n    this.uniforms.get(\"skew\").value = value;\n  }\n};\n\n// src/effects/LUT1DEffect.js\n\n\n// src/effects/glsl/lut-1d.frag\nvar lut_1d_default = \"#ifdef LUT_PRECISION_HIGH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D lut;\\n#else\\nuniform mediump sampler2D lut;\\n#endif\\n#else\\nuniform lowp sampler2D lut;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(texture2D(lut,vec2(inputColor.r,0.5)).r,texture2D(lut,vec2(inputColor.g,0.5)).r,texture2D(lut,vec2(inputColor.b,0.5)).r,inputColor.a);}\";\n\n// src/effects/LUT1DEffect.js\nvar LUT1DEffect = class extends Effect {\n  /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */\n  constructor(lut, { blendFunction = BlendFunction.SRC } = {}) {\n    super(\"LUT1DEffect\", lut_1d_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([[\"lut\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]])\n    });\n    this.lut = lut;\n  }\n  /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */\n  get lut() {\n    return this.uniforms.get(\"lut\").value;\n  }\n  set lut(value) {\n    this.uniforms.get(\"lut\").value = value;\n    if (value !== null && (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType)) {\n      this.defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n    }\n  }\n};\n\n// src/effects/LUT3DEffect.js\n\n\n// src/effects/glsl/lut-3d.frag\nvar lut_3d_default = \"uniform vec3 scale;uniform vec3 offset;\\n#ifdef CUSTOM_INPUT_DOMAIN\\nuniform vec3 domainMin;uniform vec3 domainMax;\\n#endif\\n#ifdef LUT_3D\\n#ifdef LUT_PRECISION_HIGH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler3D lut;\\n#else\\nuniform mediump sampler3D lut;\\n#endif\\n#else\\nuniform lowp sampler3D lut;\\n#endif\\nvec4 applyLUT(const in vec3 rgb){\\n#ifdef TETRAHEDRAL_INTERPOLATION\\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\\n#else\\nreturn texture(lut,rgb);\\n#endif\\n}\\n#else\\n#ifdef LUT_PRECISION_HIGH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D lut;\\n#else\\nuniform mediump sampler2D lut;\\n#endif\\n#else\\nuniform lowp sampler2D lut;\\n#endif\\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\\n#ifdef LUT_STRIP_HORIZONTAL\\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\\n#else\\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\\n#endif\\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;\\n#ifdef CUSTOM_INPUT_DOMAIN\\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}\\n#else\\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\\nc=clamp(c,0.0,1.0);\\n#endif\\nc=applyLUT(scale*c+offset).rgb;\\n#endif\\noutputColor=vec4(c,inputColor.a);}\";\n\n// src/effects/LUT3DEffect.js\nvar LUT3DEffect = class extends Effect {\n  /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.tetrahedralInterpolation=false] - Enables or disables tetrahedral interpolation.\n   * @param {TextureEncoding} [options.inputEncoding=sRGBEncoding] - Deprecated.\n   * @param {ColorSpace} [options.inputColorSpace=SRGBColorSpace] - The input color space.\n   */\n  constructor(lut, {\n    blendFunction = BlendFunction.SRC,\n    tetrahedralInterpolation = false,\n    inputEncoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding,\n    inputColorSpace\n  } = {}) {\n    super(\"LUT3DEffect\", lut_3d_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"lut\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())],\n        [\"offset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())],\n        [\"domainMin\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"domainMax\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.tetrahedralInterpolation = tetrahedralInterpolation;\n    this.inputColorSpace = inputColorSpace || encodingToColorSpace.get(inputEncoding);\n    this.lut = lut;\n  }\n  /**\n   * The input encoding. Default is `sRGBEncoding`.\n   *\n   * Set this to `LinearEncoding` if your LUT expects linear color input.\n   *\n   * @deprecated Use inputColorSpace instead.\n   * @type {TextureEncoding}\n   */\n  get inputEncoding() {\n    return this.inputColorSpace;\n  }\n  set inputEncoding(value) {\n    this.inputColorSpace = value;\n  }\n  /**\n   * Returns the input encoding.\n   *\n   * @deprecated Use inputColorSpace instead.\n   * @return {TextureEncoding} The encoding.\n   */\n  getInputEncoding() {\n    return this.inputColorSpace;\n  }\n  /**\n   * Sets the input encoding.\n   *\n   * @deprecated Use inputColorSpace instead.\n   * @param {TextureEncoding} value - The encoding.\n   */\n  setInputEncoding(value) {\n    this.inputColorSpace = value;\n  }\n  /**\n   * Returns the output encoding.\n   *\n   * @deprecated Use outputColorSpace instead.\n   * @return {TextureEncoding} The encoding.\n   */\n  getOutputEncoding() {\n    return this.outputColorSpace;\n  }\n  /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */\n  get lut() {\n    return this.uniforms.get(\"lut\").value;\n  }\n  set lut(value) {\n    const defines = this.defines;\n    const uniforms = this.uniforms;\n    if (this.lut !== value) {\n      uniforms.get(\"lut\").value = value;\n      if (value !== null) {\n        const image = value.image;\n        const tetrahedralInterpolation = this.tetrahedralInterpolation;\n        defines.clear();\n        defines.set(\"LUT_SIZE\", Math.min(image.width, image.height).toFixed(16));\n        defines.set(\"LUT_TEXEL_WIDTH\", (1 / image.width).toFixed(16));\n        defines.set(\"LUT_TEXEL_HEIGHT\", (1 / image.height).toFixed(16));\n        uniforms.get(\"domainMin\").value = null;\n        uniforms.get(\"domainMax\").value = null;\n        if (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType) {\n          defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n        }\n        if (image.width > image.height) {\n          defines.set(\"LUT_STRIP_HORIZONTAL\", \"1\");\n        } else if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n          defines.set(\"LUT_3D\", \"1\");\n        }\n        if (value instanceof LookupTexture) {\n          const min = value.domainMin;\n          const max = value.domainMax;\n          if (min.x !== 0 || min.y !== 0 || min.z !== 0 || max.x !== 1 || max.y !== 1 || max.z !== 1) {\n            defines.set(\"CUSTOM_INPUT_DOMAIN\", \"1\");\n            uniforms.get(\"domainMin\").value = min.clone();\n            uniforms.get(\"domainMax\").value = max.clone();\n          }\n        }\n        this.tetrahedralInterpolation = tetrahedralInterpolation;\n      }\n    }\n  }\n  /**\n   * Returns the current LUT.\n   *\n   * @deprecated Use lut instead.\n   * @return {Texture} The LUT.\n   */\n  getLUT() {\n    return this.lut;\n  }\n  /**\n   * Sets the LUT.\n   *\n   * @deprecated Use lut instead.\n   * @param {Texture} value - The LUT.\n   */\n  setLUT(value) {\n    this.lut = value;\n  }\n  /**\n   * Updates the scale and offset for the LUT sampling coordinates.\n   *\n   * @private\n   */\n  updateScaleOffset() {\n    const lut = this.lut;\n    if (lut !== null) {\n      const size = Math.min(lut.image.width, lut.image.height);\n      const scale = this.uniforms.get(\"scale\").value;\n      const offset = this.uniforms.get(\"offset\").value;\n      if (this.tetrahedralInterpolation && lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n        if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n          const domainScale = lut.domainMax.clone().sub(lut.domainMin);\n          scale.setScalar(size - 1).divide(domainScale);\n          offset.copy(lut.domainMin).negate().multiply(scale);\n        } else {\n          scale.setScalar(size - 1);\n          offset.setScalar(0);\n        }\n      } else {\n        if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n          const domainScale = lut.domainMax.clone().sub(lut.domainMin).multiplyScalar(size);\n          scale.setScalar(size - 1).divide(domainScale);\n          offset.copy(lut.domainMin).negate().multiply(scale).addScalar(1 / (2 * size));\n        } else {\n          scale.setScalar((size - 1) / size);\n          offset.setScalar(1 / (2 * size));\n        }\n      }\n    }\n  }\n  /**\n   * Configures parameters for tetrahedral interpolation.\n   *\n   * @private\n   */\n  configureTetrahedralInterpolation() {\n    const lut = this.lut;\n    if (lut !== null) {\n      lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      if (this.tetrahedralInterpolation) {\n        if (lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n          lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n          lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        } else {\n          console.warn(\"Tetrahedral interpolation requires a 3D texture\");\n        }\n      }\n      if (lut.source === void 0) {\n        lut.needsUpdate = true;\n      }\n    }\n  }\n  /**\n   * Indicates whether tetrahedral interpolation is enabled. Requires a 3D LUT, disabled by default.\n   *\n   * Tetrahedral interpolation produces highly accurate results but is slower than hardware interpolation.\n   *\n   * @type {Boolean}\n   */\n  get tetrahedralInterpolation() {\n    return this.defines.has(\"TETRAHEDRAL_INTERPOLATION\");\n  }\n  set tetrahedralInterpolation(value) {\n    if (value) {\n      this.defines.set(\"TETRAHEDRAL_INTERPOLATION\", \"1\");\n    } else {\n      this.defines.delete(\"TETRAHEDRAL_INTERPOLATION\");\n    }\n    this.configureTetrahedralInterpolation();\n    this.updateScaleOffset();\n    this.setChanged();\n  }\n  /**\n   * Enables or disables tetrahedral interpolation.\n   *\n   * @deprecated Use tetrahedralInterpolation instead.\n   * @param {Boolean} value - Whether tetrahedral interpolation should be enabled.\n   */\n  setTetrahedralInterpolationEnabled(value) {\n    this.tetrahedralInterpolation = value;\n  }\n};\n\n// src/effects/glsl/noise.frag\nvar noise_default = \"void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\\n#ifdef PREMULTIPLY\\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\\n#else\\noutputColor=vec4(noise,inputColor.a);\\n#endif\\n}\";\n\n// src/effects/NoiseEffect.js\nvar NoiseEffect = class extends Effect {\n  /**\n   * Constructs a new noise effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Boolean} [options.premultiply=false] - Whether the noise should be multiplied with the input colors prior to blending.\n   */\n  constructor({ blendFunction = BlendFunction.SCREEN, premultiply = false } = {}) {\n    super(\"NoiseEffect\", noise_default, { blendFunction });\n    this.premultiply = premultiply;\n  }\n  /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @type {Boolean}\n   */\n  get premultiply() {\n    return this.defines.has(\"PREMULTIPLY\");\n  }\n  set premultiply(value) {\n    if (this.premultiply !== value) {\n      if (value) {\n        this.defines.set(\"PREMULTIPLY\", \"1\");\n      } else {\n        this.defines.delete(\"PREMULTIPLY\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @return {Boolean} Whether noise is premultiplied.\n   */\n  isPremultiplied() {\n    return this.premultiply;\n  }\n  /**\n   * Controls whether noise should be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @param {Boolean} value - Whether noise should be premultiplied.\n   */\n  setPremultiplied(value) {\n    this.premultiply = value;\n  }\n};\n\n// src/effects/OutlineEffect.js\n\n\n// src/effects/glsl/outline.frag\nvar outline_default3 = \"uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\\n#ifdef USE_PATTERN\\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\\n#ifndef X_RAY\\nedge.y=0.0;\\n#endif\\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\\n#ifdef USE_PATTERN\\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\\n#ifdef X_RAY\\nfloat hiddenFactor=0.5;\\n#else\\nfloat hiddenFactor=0.0;\\n#endif\\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\\n#endif\\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\\n#ifdef ALPHA\\noutputColor=vec4(color,alpha);\\n#else\\noutputColor=vec4(color,max(alpha,inputColor.a));\\n#endif\\n}\";\n\n// src/effects/glsl/outline.vert\nvar outline_default4 = \"uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}\";\n\n// src/effects/OutlineEffect.js\nvar OutlineEffect = class extends Effect {\n  /**\n   * Constructs a new outline effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.\n   * @param {Texture} [options.patternTexture=null] - A pattern texture.\n   * @param {Number} [options.patternScale=1.0] - The pattern scale.\n   * @param {Number} [options.edgeStrength=1.0] - The edge strength.\n   * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.\n   * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.\n   * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.\n   * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.\n   * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(scene, camera, {\n    blendFunction = BlendFunction.SCREEN,\n    patternTexture = null,\n    patternScale = 1,\n    edgeStrength = 1,\n    pulseSpeed = 0,\n    visibleEdgeColor = 16777215,\n    hiddenEdgeColor = 2230538,\n    kernelSize = KernelSize.VERY_SMALL,\n    blur = false,\n    xRay = true,\n    multisampling = 0,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"OutlineEffect\", outline_default3, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"maskTexture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"edgeTexture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"edgeStrength\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(edgeStrength)],\n        [\"visibleEdgeColor\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(visibleEdgeColor))],\n        [\"hiddenEdgeColor\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(hiddenEdgeColor))],\n        [\"pulse\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"patternScale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(patternScale)],\n        [\"patternTexture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.blendMode.addEventListener(\"change\", (event) => {\n      if (this.blendMode.blendFunction === BlendFunction.ALPHA) {\n        this.defines.set(\"ALPHA\", \"1\");\n      } else {\n        this.defines.delete(\"ALPHA\");\n      }\n      this.setChanged();\n    });\n    this.blendMode.blendFunction = blendFunction;\n    this.patternTexture = patternTexture;\n    this.xRay = xRay;\n    this.scene = scene;\n    this.camera = camera;\n    this.renderTargetMask = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n    this.renderTargetMask.samples = multisampling;\n    this.renderTargetMask.texture.name = \"Outline.Mask\";\n    this.uniforms.get(\"maskTexture\").value = this.renderTargetMask.texture;\n    this.renderTargetOutline = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetOutline.texture.name = \"Outline.Edges\";\n    this.uniforms.get(\"edgeTexture\").value = this.renderTargetOutline.texture;\n    this.clearPass = new ClearPass();\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.clearPass.overrideClearAlpha = 1;\n    this.depthPass = new DepthPass(scene, camera);\n    this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));\n    const clearPass = this.maskPass.clearPass;\n    clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    clearPass.overrideClearAlpha = 1;\n    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize });\n    this.blurPass.enabled = blur;\n    const resolution = this.blurPass.resolution;\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.outlinePass = new ShaderPass(new OutlineMaterial());\n    const outlineMaterial = this.outlinePass.fullscreenMaterial;\n    outlineMaterial.inputBuffer = this.renderTargetMask.texture;\n    this.time = 0;\n    this.forceUpdate = true;\n    this.selection = new Selection();\n    this.selection.layer = 10;\n    this.pulseSpeed = pulseSpeed;\n  }\n  set mainScene(value) {\n    this.scene = value;\n    this.depthPass.mainScene = value;\n    this.maskPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.depthPass.mainCamera = value;\n    this.maskPass.mainCamera = value;\n    this.maskPass.overrideMaterial.copyCameraSettings(value);\n  }\n  /**\n   * The resolution of this effect.\n   *\n   * @type {Resolution}\n   */\n  get resolution() {\n    return this.blurPass.resolution;\n  }\n  /**\n   * Returns the resolution.\n   *\n   * @return {Resizer} The resolution.\n   */\n  getResolution() {\n    return this.blurPass.getResolution();\n  }\n  /**\n   * The amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @experimental Requires three >= r138.\n   * @type {Number}\n   */\n  get multisampling() {\n    return this.renderTargetMask.samples;\n  }\n  set multisampling(value) {\n    this.renderTargetMask.samples = value;\n    this.renderTargetMask.dispose();\n  }\n  /**\n   * The pattern scale.\n   *\n   * @type {Number}\n   */\n  get patternScale() {\n    return this.uniforms.get(\"patternScale\").value;\n  }\n  set patternScale(value) {\n    this.uniforms.get(\"patternScale\").value = value;\n  }\n  /**\n   * The edge strength.\n   *\n   * @type {Number}\n   */\n  get edgeStrength() {\n    return this.uniforms.get(\"edgeStrength\").value;\n  }\n  set edgeStrength(value) {\n    this.uniforms.get(\"edgeStrength\").value = value;\n  }\n  /**\n   * The visible edge color.\n   *\n   * @type {Color}\n   */\n  get visibleEdgeColor() {\n    return this.uniforms.get(\"visibleEdgeColor\").value;\n  }\n  set visibleEdgeColor(value) {\n    this.uniforms.get(\"visibleEdgeColor\").value = value;\n  }\n  /**\n   * The hidden edge color.\n   *\n   * @type {Color}\n   */\n  get hiddenEdgeColor() {\n    return this.uniforms.get(\"hiddenEdgeColor\").value;\n  }\n  set hiddenEdgeColor(value) {\n    this.uniforms.get(\"hiddenEdgeColor\").value = value;\n  }\n  /**\n   * Returns the blur pass.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */\n  getSelection() {\n    return this.selection;\n  }\n  /**\n   * Returns the pulse speed.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @return {Number} The speed.\n   */\n  getPulseSpeed() {\n    return this.pulseSpeed;\n  }\n  /**\n   * Sets the pulse speed. Set to zero to disable.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @param {Number} value - The speed.\n   */\n  setPulseSpeed(value) {\n    this.pulseSpeed = value;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * The selection layer.\n   *\n   * @type {Number}\n   * @deprecated Use selection.layer instead.\n   */\n  get selectionLayer() {\n    return this.selection.layer;\n  }\n  set selectionLayer(value) {\n    this.selection.layer = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get dithering() {\n    return this.blurPass.dithering;\n  }\n  set dithering(value) {\n    this.blurPass.dithering = value;\n  }\n  /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */\n  get kernelSize() {\n    return this.blurPass.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurPass.kernelSize = value;\n  }\n  /**\n   * Indicates whether the outlines should be blurred.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */\n  get blur() {\n    return this.blurPass.enabled;\n  }\n  set blur(value) {\n    this.blurPass.enabled = value;\n  }\n  /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @type {Boolean}\n   */\n  get xRay() {\n    return this.defines.has(\"X_RAY\");\n  }\n  set xRay(value) {\n    if (this.xRay !== value) {\n      if (value) {\n        this.defines.set(\"X_RAY\", \"1\");\n      } else {\n        this.defines.delete(\"X_RAY\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @deprecated Use xRay instead.\n   * @return {Boolean} Whether X-ray mode is enabled.\n   */\n  isXRayEnabled() {\n    return this.xRay;\n  }\n  /**\n   * Enables or disables X-ray outlines.\n   *\n   * @deprecated Use xRay instead.\n   * @param {Boolean} value - Whether X-ray should be enabled.\n   */\n  setXRayEnabled(value) {\n    this.xRay = value;\n  }\n  /**\n   * The pattern texture. Set to `null` to disable.\n   *\n   * @type {Texture}\n   */\n  get patternTexture() {\n    return this.uniforms.get(\"patternTexture\").value;\n  }\n  set patternTexture(value) {\n    if (value !== null) {\n      value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      this.defines.set(\"USE_PATTERN\", \"1\");\n      this.setVertexShader(outline_default4);\n    } else {\n      this.defines.delete(\"USE_PATTERN\");\n      this.setVertexShader(null);\n    }\n    this.uniforms.get(\"patternTexture\").value = value;\n    this.setChanged();\n  }\n  /**\n   * Sets the pattern texture.\n   *\n   * @deprecated Use patternTexture instead.\n   * @param {Texture} value - The new texture.\n   */\n  setPatternTexture(value) {\n    this.patternTexture = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Clears the current selection and selects a list of objects.\n   *\n   * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.set() instead.\n   */\n  setSelection(objects) {\n    this.selection.set(objects);\n    return this;\n  }\n  /**\n   * Clears the list of selected objects.\n   *\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.clear() instead.\n   */\n  clearSelection() {\n    this.selection.clear();\n    return this;\n  }\n  /**\n   * Selects an object.\n   *\n   * @param {Object3D} object - The object that should be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.add() instead.\n   */\n  selectObject(object) {\n    this.selection.add(object);\n    return this;\n  }\n  /**\n   * Deselects an object.\n   *\n   * @param {Object3D} object - The object that should no longer be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.delete() instead.\n   */\n  deselectObject(object) {\n    this.selection.delete(object);\n    return this;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const selection = this.selection;\n    const uniforms = this.uniforms;\n    const pulse = uniforms.get(\"pulse\");\n    const background = scene.background;\n    const mask = camera.layers.mask;\n    if (this.forceUpdate || selection.size > 0) {\n      scene.background = null;\n      pulse.value = 1;\n      if (this.pulseSpeed > 0) {\n        pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;\n      }\n      this.time += deltaTime;\n      selection.setVisible(false);\n      this.depthPass.render(renderer);\n      selection.setVisible(true);\n      camera.layers.set(selection.layer);\n      this.maskPass.render(renderer, this.renderTargetMask);\n      camera.layers.mask = mask;\n      scene.background = background;\n      this.outlinePass.render(renderer, null, this.renderTargetOutline);\n      if (this.blurPass.enabled) {\n        this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);\n      }\n    }\n    this.forceUpdate = selection.size > 0;\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.blurPass.setSize(width, height);\n    this.renderTargetMask.setSize(width, height);\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.depthPass.setSize(w, h);\n    this.renderTargetOutline.setSize(w, h);\n    this.outlinePass.fullscreenMaterial.setSize(w, h);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n    if (frameBufferType !== void 0) {\n      this.depthPass.initialize(renderer, alpha, frameBufferType);\n      this.maskPass.initialize(renderer, alpha, frameBufferType);\n      this.outlinePass.initialize(renderer, alpha, frameBufferType);\n    }\n  }\n};\n\n// src/effects/PixelationEffect.js\n\n\n// src/effects/glsl/pixelation.frag\nvar pixelation_default = \"uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}\";\n\n// src/effects/PixelationEffect.js\nvar PixelationEffect = class extends Effect {\n  /**\n   * Constructs a new pixelation effect.\n   *\n   * @param {Object} [granularity=30.0] - The pixel granularity.\n   */\n  constructor(granularity = 30) {\n    super(\"PixelationEffect\", pixelation_default, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"active\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)],\n        [\"d\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4())]\n      ])\n    });\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this._granularity = 0;\n    this.granularity = granularity;\n  }\n  /**\n   * The pixel granularity.\n   *\n   * A higher value yields coarser visuals.\n   *\n   * @type {Number}\n   */\n  get granularity() {\n    return this._granularity;\n  }\n  set granularity(value) {\n    let d = Math.floor(value);\n    if (d % 2 > 0) {\n      d += 1;\n    }\n    this._granularity = d;\n    this.uniforms.get(\"active\").value = d > 0;\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @return {Number} The granularity.\n   */\n  getGranularity() {\n    return this.granularity;\n  }\n  /**\n   * Sets the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @param {Number} value - The new granularity.\n   */\n  setGranularity(value) {\n    this.granularity = value;\n  }\n  /**\n   * Updates the granularity.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.set(width, height);\n    const d = this.granularity;\n    const x = d / resolution.x;\n    const y = d / resolution.y;\n    this.uniforms.get(\"d\").value.set(x, y, 1 / x, 1 / y);\n  }\n};\n\n// src/effects/RealisticBokehEffect.js\n\n\n// src/effects/glsl/realistic-bokeh.frag\nvar realistic_bokeh_default = \"uniform float focus;uniform float focalLength;uniform float fStop;uniform float maxBlur;uniform float luminanceThreshold;uniform float luminanceGain;uniform float bias;uniform float fringe;\\n#ifdef MANUAL_DOF\\nuniform vec4 dof;\\n#endif\\n#ifdef PENTAGON\\nfloat pentagon(const in vec2 coords){const vec4 HS0=vec4(1.0,0.0,0.0,1.0);const vec4 HS1=vec4(0.309016994,0.951056516,0.0,1.0);const vec4 HS2=vec4(-0.809016994,0.587785252,0.0,1.0);const vec4 HS3=vec4(-0.809016994,-0.587785252,0.0,1.0);const vec4 HS4=vec4(0.309016994,-0.951056516,0.0,1.0);const vec4 HS5=vec4(0.0,0.0,1.0,1.0);const vec4 ONE=vec4(1.0);const float P_FEATHER=0.4;const float N_FEATHER=-P_FEATHER;float inOrOut=-4.0;vec4 P=vec4(coords,vec2(RINGS_FLOAT-1.3));vec4 dist=vec4(dot(P,HS0),dot(P,HS1),dot(P,HS2),dot(P,HS3));dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dot(dist,ONE);dist.x=dot(P,HS4);dist.y=HS5.w-abs(P.z);dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dist.x;return clamp(inOrOut,0.0,1.0);}\\n#endif\\nvec3 processTexel(const in vec2 coords,const in float blur){vec2 scale=texelSize*fringe*blur;vec3 c=vec3(texture2D(inputBuffer,coords+vec2(0.0,1.0)*scale).r,texture2D(inputBuffer,coords+vec2(-0.866,-0.5)*scale).g,texture2D(inputBuffer,coords+vec2(0.866,-0.5)*scale).b);float luminance=linearToRelativeLuminance(c);float threshold=max((luminance-luminanceThreshold)*luminanceGain,0.0);return c+mix(vec3(0.0),c,threshold*blur);}float gather(const in float i,const in float j,const in float ringSamples,const in vec2 uv,const in vec2 blurFactor,const in float blur,inout vec3 color){float step=PI2/ringSamples;vec2 wh=vec2(cos(j*step)*i,sin(j*step)*i);\\n#ifdef PENTAGON\\nfloat p=pentagon(wh);\\n#else\\nfloat p=1.0;\\n#endif\\ncolor+=processTexel(wh*blurFactor+uv,blur)*mix(1.0,i/RINGS_FLOAT,bias)*p;return mix(1.0,i/RINGS_FLOAT,bias)*p;}void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\\n#else\\nfloat linearDepth=depth;\\n#endif\\n#ifdef MANUAL_DOF\\nfloat focalPlane=linearDepth-focus;float farDoF=(focalPlane-dof.z)/dof.w;float nearDoF=(-focalPlane-dof.x)/dof.y;float blur=(focalPlane>0.0)?farDoF:nearDoF;\\n#else\\nconst float CIRCLE_OF_CONFUSION=0.03;float focalPlaneMM=focus*1000.0;float depthMM=linearDepth*1000.0;float focalPlane=(depthMM*focalLength)/(depthMM-focalLength);float farDoF=(focalPlaneMM*focalLength)/(focalPlaneMM-focalLength);float nearDoF=(focalPlaneMM-focalLength)/(focalPlaneMM*fStop*CIRCLE_OF_CONFUSION);float blur=abs(focalPlane-farDoF)*nearDoF;\\n#endif\\nconst int MAX_RING_SAMPLES=RINGS_INT*SAMPLES_INT;blur=clamp(blur,0.0,1.0);vec3 color=inputColor.rgb;if(blur>=0.05){vec2 blurFactor=blur*maxBlur*texelSize;float s=1.0;int ringSamples;for(int i=1;i<=RINGS_INT;i++){ringSamples=i*SAMPLES_INT;for(int j=0;j<MAX_RING_SAMPLES;j++){if(j>=ringSamples){break;}s+=gather(float(i),float(j),float(ringSamples),uv,blurFactor,blur,color);}}color/=s;}\\n#ifdef SHOW_FOCUS\\nfloat edge=0.002*linearDepth;float m=clamp(smoothstep(0.0,edge,blur),0.0,1.0);float e=clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);color=mix(color,vec3(1.0,0.5,0.0),(1.0-m)*0.6);color=mix(color,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\\n#endif\\noutputColor=vec4(color,inputColor.a);}\";\n\n// src/effects/RealisticBokehEffect.js\nvar RealisticBokehEffect = class extends Effect {\n  /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=1.0] - The focus distance in world units.\n   * @param {Number} [options.focalLength=24.0] - The focal length of the main camera.\n   * @param {Number} [options.fStop=0.9] - The ratio of the lens focal length to the diameter of the entrance pupil (aperture).\n   * @param {Number} [options.luminanceThreshold=0.5] - A luminance threshold.\n   * @param {Number} [options.luminanceGain=2.0] - A luminance gain factor.\n   * @param {Number} [options.bias=0.5] - A blur bias.\n   * @param {Number} [options.fringe=0.7] - A blur offset.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   * @param {Boolean} [options.rings=3] - The number of blur iterations.\n   * @param {Boolean} [options.samples=2] - The amount of samples taken per ring.\n   * @param {Boolean} [options.showFocus=false] - Whether the focal point should be highlighted. Useful for debugging.\n   * @param {Boolean} [options.manualDoF=false] - Enables manual control over the depth of field.\n   * @param {Boolean} [options.pentagon=false] - Enables pentagonal blur shapes. Requires a high number of rings and samples.\n   */\n  constructor({\n    blendFunction,\n    focus = 1,\n    focalLength = 24,\n    fStop = 0.9,\n    luminanceThreshold = 0.5,\n    luminanceGain = 2,\n    bias = 0.5,\n    fringe = 0.7,\n    maxBlur = 1,\n    rings = 3,\n    samples = 2,\n    showFocus = false,\n    manualDoF = false,\n    pentagon = false\n  } = {}) {\n    super(\"RealisticBokehEffect\", realistic_bokeh_default, {\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"focus\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)],\n        [\"focalLength\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)],\n        [\"fStop\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fStop)],\n        [\"luminanceThreshold\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceThreshold)],\n        [\"luminanceGain\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceGain)],\n        [\"bias\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(bias)],\n        [\"fringe\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fringe)],\n        [\"maxBlur\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)],\n        [\"dof\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.rings = rings;\n    this.samples = samples;\n    this.showFocus = showFocus;\n    this.manualDoF = manualDoF;\n    this.pentagon = pentagon;\n  }\n  /**\n   * The amount of blur iterations.\n   *\n   * @type {Number}\n   */\n  get rings() {\n    return Number.parseInt(this.defines.get(\"RINGS_INT\"));\n  }\n  set rings(value) {\n    const r = Math.floor(value);\n    this.defines.set(\"RINGS_INT\", r.toFixed(0));\n    this.defines.set(\"RINGS_FLOAT\", r.toFixed(1));\n    this.setChanged();\n  }\n  /**\n   * The amount of blur samples per ring.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number.parseInt(this.defines.get(\"SAMPLES_INT\"));\n  }\n  set samples(value) {\n    const s = Math.floor(value);\n    this.defines.set(\"SAMPLES_INT\", s.toFixed(0));\n    this.defines.set(\"SAMPLES_FLOAT\", s.toFixed(1));\n    this.setChanged();\n  }\n  /**\n   * Indicates whether the focal point will be highlighted.\n   *\n   * @type {Boolean}\n   */\n  get showFocus() {\n    return this.defines.has(\"SHOW_FOCUS\");\n  }\n  set showFocus(value) {\n    if (this.showFocus !== value) {\n      if (value) {\n        this.defines.set(\"SHOW_FOCUS\", \"1\");\n      } else {\n        this.defines.delete(\"SHOW_FOCUS\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the Depth of Field should be calculated manually.\n   *\n   * If enabled, the Depth of Field can be adjusted via the `dof` uniform.\n   *\n   * @type {Boolean}\n   */\n  get manualDoF() {\n    return this.defines.has(\"MANUAL_DOF\");\n  }\n  set manualDoF(value) {\n    if (this.manualDoF !== value) {\n      if (value) {\n        this.defines.set(\"MANUAL_DOF\", \"1\");\n        this.uniforms.get(\"dof\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0.2, 1, 0.2, 2);\n      } else {\n        this.defines.delete(\"MANUAL_DOF\");\n        this.uniforms.get(\"dof\").value = null;\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the blur shape should be pentagonal.\n   *\n   * @type {Boolean}\n   */\n  get pentagon() {\n    return this.defines.has(\"PENTAGON\");\n  }\n  set pentagon(value) {\n    if (this.pentagon !== value) {\n      if (value) {\n        this.defines.set(\"PENTAGON\", \"1\");\n      } else {\n        this.defines.delete(\"PENTAGON\");\n      }\n      this.setChanged();\n    }\n  }\n};\n\n// src/effects/ScanlineEffect.js\n\n\n// src/effects/glsl/scanlines.frag\nvar scanlines_default = \"uniform float count;\\n#ifdef SCROLL\\nuniform float scrollSpeed;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;\\n#ifdef SCROLL\\ny+=time*scrollSpeed;\\n#endif\\nvec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}\";\n\n// src/effects/ScanlineEffect.js\nvar ScanlineEffect = class extends Effect {\n  /**\n   * Constructs a new scanline effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.density=1.25] - The scanline density.\n   * @param {Number} [options.scrollSpeed=0.0] - The scanline scroll speed.\n   */\n  constructor({ blendFunction = BlendFunction.OVERLAY, density = 1.25, scrollSpeed = 0 } = {}) {\n    super(\"ScanlineEffect\", scanlines_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"count\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)],\n        [\"scrollSpeed\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)]\n      ])\n    });\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.d = density;\n    this.scrollSpeed = scrollSpeed;\n  }\n  /**\n   * The scanline density.\n   *\n   * @type {Number}\n   */\n  get density() {\n    return this.d;\n  }\n  set density(value) {\n    this.d = value;\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the current scanline density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The scanline density.\n   */\n  getDensity() {\n    return this.density;\n  }\n  /**\n   * Sets the scanline density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The new scanline density.\n   */\n  setDensity(value) {\n    this.density = value;\n  }\n  /**\n   * The scanline scroll speed. Default is 0 (disabled).\n   *\n   * @type {Number}\n   */\n  get scrollSpeed() {\n    return this.uniforms.get(\"scrollSpeed\").value;\n  }\n  set scrollSpeed(value) {\n    this.uniforms.get(\"scrollSpeed\").value = value;\n    if (value === 0) {\n      if (this.defines.delete(\"SCROLL\")) {\n        this.setChanged();\n      }\n    } else if (!this.defines.has(\"SCROLL\")) {\n      this.defines.set(\"SCROLL\", \"1\");\n      this.setChanged();\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.resolution.set(width, height);\n    this.uniforms.get(\"count\").value = Math.round(height * this.density);\n  }\n};\n\n// src/effects/ShockWaveEffect.js\n\n\n// src/effects/glsl/shock-wave.frag\nvar shock_wave_default = \"uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}\";\n\n// src/effects/glsl/shock-wave.vert\nvar shock_wave_default2 = \"uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}\";\n\n// src/effects/ShockWaveEffect.js\nvar HALF_PI = Math.PI * 0.5;\nvar v2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ab = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ShockWaveEffect = class extends Effect {\n  /**\n   * Constructs a new shock wave effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Vector3} [position] - The world position of the shock wave.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.speed=2.0] - The animation speed.\n   * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.\n   * @param {Number} [options.waveSize=0.2] - The wave size.\n   * @param {Number} [options.amplitude=0.05] - The distortion amplitude.\n   */\n  constructor(camera, position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), {\n    speed = 2,\n    maxRadius = 1,\n    waveSize = 0.2,\n    amplitude = 0.05\n  } = {}) {\n    super(\"ShockWaveEffect\", shock_wave_default, {\n      vertexShader: shock_wave_default2,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"active\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)],\n        [\"center\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.5, 0.5))],\n        [\"cameraDistance\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"size\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"radius\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(-waveSize)],\n        [\"maxRadius\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxRadius)],\n        [\"waveSize\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(waveSize)],\n        [\"amplitude\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(amplitude)]\n      ])\n    });\n    this.position = position;\n    this.speed = speed;\n    this.camera = camera;\n    this.screenPosition = this.uniforms.get(\"center\").value;\n    this.time = 0;\n    this.active = false;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n  }\n  /**\n   * The amplitude.\n   *\n   * @type {Number}\n   */\n  get amplitude() {\n    return this.uniforms.get(\"amplitude\").value;\n  }\n  set amplitude(value) {\n    this.uniforms.get(\"amplitude\").value = value;\n  }\n  /**\n   * The wave size.\n   *\n   * @type {Number}\n   */\n  get waveSize() {\n    return this.uniforms.get(\"waveSize\").value;\n  }\n  set waveSize(value) {\n    this.uniforms.get(\"waveSize\").value = value;\n  }\n  /**\n   * The maximum radius.\n   *\n   * @type {Number}\n   */\n  get maxRadius() {\n    return this.uniforms.get(\"maxRadius\").value;\n  }\n  set maxRadius(value) {\n    this.uniforms.get(\"maxRadius\").value = value;\n  }\n  /**\n   * The position of the shock wave.\n   *\n   * @type {Vector3}\n   * @deprecated Use position instead.\n   */\n  get epicenter() {\n    return this.position;\n  }\n  set epicenter(value) {\n    this.position = value;\n  }\n  /**\n   * Returns the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @return {Vector3} The position.\n   */\n  getPosition() {\n    return this.position;\n  }\n  /**\n   * Sets the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @param {Vector3} value - The position.\n   */\n  setPosition(value) {\n    this.position = value;\n  }\n  /**\n   * Returns the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @return {Number} The speed.\n   */\n  getSpeed() {\n    return this.speed;\n  }\n  /**\n   * Sets the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @param {Number} value - The speed.\n   */\n  setSpeed(value) {\n    this.speed = value;\n  }\n  /**\n   * Emits the shock wave.\n   */\n  explode() {\n    this.time = 0;\n    this.active = true;\n    this.uniforms.get(\"active\").value = true;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [delta] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, delta) {\n    const position = this.position;\n    const camera = this.camera;\n    const uniforms = this.uniforms;\n    const uActive = uniforms.get(\"active\");\n    if (this.active) {\n      const waveSize = uniforms.get(\"waveSize\").value;\n      camera.getWorldDirection(v2);\n      ab.copy(camera.position).sub(position);\n      uActive.value = v2.angleTo(ab) > HALF_PI;\n      if (uActive.value) {\n        uniforms.get(\"cameraDistance\").value = camera.position.distanceTo(position);\n        v2.copy(position).project(camera);\n        this.screenPosition.set((v2.x + 1) * 0.5, (v2.y + 1) * 0.5);\n      }\n      this.time += delta * this.speed;\n      const radius = this.time - waveSize;\n      uniforms.get(\"radius\").value = radius;\n      if (radius >= (uniforms.get(\"maxRadius\").value + waveSize) * 2) {\n        this.active = false;\n        uActive.value = false;\n      }\n    }\n  }\n};\n\n// src/effects/SelectiveBloomEffect.js\n\nvar SelectiveBloomEffect = class extends BloomEffect {\n  /**\n   * Constructs a new selective bloom effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options. See {@link BloomEffect} for details.\n   */\n  constructor(scene, camera, options) {\n    super(options);\n    this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);\n    this.camera = camera;\n    this.depthPass = new DepthPass(scene, camera);\n    this.clearPass = new ClearPass(true, false, false);\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n    const depthMaskMaterial = this.depthMaskMaterial;\n    depthMaskMaterial.copyCameraSettings(camera);\n    depthMaskMaterial.depthBuffer1 = this.depthPass.texture;\n    depthMaskMaterial.depthPacking1 = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n    depthMaskMaterial.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n    this.renderTargetMasked = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetMasked.texture.name = \"Bloom.Masked\";\n    this.selection = new Selection();\n    this.selection.layer = 11;\n    this._inverted = false;\n    this._ignoreBackground = false;\n  }\n  set mainScene(value) {\n    this.depthPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.depthPass.mainCamera = value;\n    this.depthMaskMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */\n  getSelection() {\n    return this.selection;\n  }\n  /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */\n  get depthMaskMaterial() {\n    return this.depthMaskPass.fullscreenMaterial;\n  }\n  /**\n   * Indicates whether the selection should be considered inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this._inverted;\n  }\n  set inverted(value) {\n    this._inverted = value;\n    this.depthMaskMaterial.depthMode = value ? three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth : three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n  }\n  /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n  /**\n   * Indicates whether the background colors will be ignored.\n   *\n   * @type {Boolean}\n   */\n  get ignoreBackground() {\n    return this._ignoreBackground;\n  }\n  set ignoreBackground(value) {\n    this._ignoreBackground = value;\n    this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;\n  }\n  /**\n   * Indicates whether the background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the background is disabled.\n   */\n  isBackgroundDisabled() {\n    return this.ignoreBackground;\n  }\n  /**\n   * Enables or disables the background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the background should be disabled.\n   */\n  setBackgroundDisabled(value) {\n    this.ignoreBackground = value;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthMaskMaterial.depthBuffer0 = depthTexture;\n    this.depthMaskMaterial.depthPacking0 = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const camera = this.camera;\n    const selection = this.selection;\n    const inverted = this.inverted;\n    let renderTarget = inputBuffer;\n    if (this.ignoreBackground || !inverted || selection.size > 0) {\n      const mask = camera.layers.mask;\n      camera.layers.set(selection.layer);\n      this.depthPass.render(renderer);\n      camera.layers.mask = mask;\n      renderTarget = this.renderTargetMasked;\n      this.clearPass.render(renderer, renderTarget);\n      this.depthMaskPass.render(renderer, inputBuffer, renderTarget);\n    }\n    super.update(renderer, renderTarget, deltaTime);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    super.setSize(width, height);\n    this.renderTargetMasked.setSize(width, height);\n    this.depthPass.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    super.initialize(renderer, alpha, frameBufferType);\n    this.clearPass.initialize(renderer, alpha, frameBufferType);\n    this.depthPass.initialize(renderer, alpha, frameBufferType);\n    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n    if (renderer.capabilities.logarithmicDepthBuffer) {\n      this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n    }\n    if (frameBufferType !== void 0) {\n      this.renderTargetMasked.texture.type = frameBufferType;\n      if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTargetMasked.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/effects/SepiaEffect.js\n\n\n// src/effects/glsl/sepia.frag\nvar sepia_default = \"uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}\";\n\n// src/effects/SepiaEffect.js\nvar SepiaEffect = class extends Effect {\n  /**\n   * Constructs a new sepia effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.intensity=1.0] - The intensity of the effect.\n   */\n  constructor({ blendFunction, intensity = 1 } = {}) {\n    super(\"SepiaEffect\", sepia_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"weightsR\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.393, 0.769, 0.189))],\n        [\"weightsG\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.349, 0.686, 0.168))],\n        [\"weightsB\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.272, 0.534, 0.131))]\n      ])\n    });\n  }\n  /**\n   * The intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @type {Number}\n   */\n  get intensity() {\n    return this.blendMode.opacity.value;\n  }\n  set intensity(value) {\n    this.blendMode.opacity.value = value;\n  }\n  /**\n   * Returns the current sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @return {Number} The intensity.\n   */\n  getIntensity() {\n    return this.intensity;\n  }\n  /**\n   * Sets the sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @param {Number} value - The intensity.\n   */\n  setIntensity(value) {\n    this.intensity = value;\n  }\n  /**\n   * The weights for the red channel. Default is `(0.393, 0.769, 0.189)`.\n   *\n   * @type {Vector3}\n   */\n  get weightsR() {\n    return this.uniforms.get(\"weightsR\").value;\n  }\n  /**\n   * The weights for the green channel. Default is `(0.349, 0.686, 0.168)`.\n   *\n   * @type {Vector3}\n   */\n  get weightsG() {\n    return this.uniforms.get(\"weightsG\").value;\n  }\n  /**\n   * The weights for the blue channel. Default is `(0.272, 0.534, 0.131)`.\n   *\n   * @type {Vector3}\n   */\n  get weightsB() {\n    return this.uniforms.get(\"weightsB\").value;\n  }\n};\n\n// src/effects/SMAAEffect.js\n\n\n// src/textures/smaa/searchImageDataURL.js\nvar searchImageDataURL_default = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC\";\n\n// src/textures/smaa/areaImageDataURL.js\nvar areaImageDataURL_default = \"data:image/png;base64,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\";\n\n// src/effects/glsl/smaa.frag\nvar smaa_default = \"uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}\";\n\n// src/effects/glsl/smaa.vert\nvar smaa_default2 = \"varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}\";\n\n// src/effects/SMAAEffect.js\nvar SMAAEffect = class extends Effect {\n  /**\n   * Constructs a new SMAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.\n   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.\n   */\n  constructor({\n    blendFunction = BlendFunction.SRC,\n    preset = SMAAPreset.MEDIUM,\n    edgeDetectionMode = EdgeDetectionMode.COLOR,\n    predicationMode = PredicationMode.DISABLED\n  } = {}) {\n    super(\"SMAAEffect\", smaa_default, {\n      vertexShader: smaa_default2,\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"weightMap\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    let searchImage, areaImage;\n    if (arguments.length > 1) {\n      searchImage = arguments[0];\n      areaImage = arguments[1];\n      if (arguments.length > 2) {\n        preset = arguments[2];\n      }\n      if (arguments.length > 3) {\n        edgeDetectionMode = arguments[3];\n      }\n    }\n    this.renderTargetEdges = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetEdges.texture.name = \"SMAA.Edges\";\n    this.renderTargetWeights = this.renderTargetEdges.clone();\n    this.renderTargetWeights.texture.name = \"SMAA.Weights\";\n    this.uniforms.get(\"weightMap\").value = this.renderTargetWeights.texture;\n    this.clearPass = new ClearPass(true, false, false);\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.clearPass.overrideClearAlpha = 1;\n    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());\n    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;\n    this.edgeDetectionMaterial.predicationMode = predicationMode;\n    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());\n    const loadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    loadingManager.onLoad = () => {\n      const searchTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(searchImage);\n      searchTexture.name = \"SMAA.Search\";\n      searchTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n      searchTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n      searchTexture.generateMipmaps = false;\n      searchTexture.needsUpdate = true;\n      searchTexture.flipY = true;\n      this.weightsMaterial.searchTexture = searchTexture;\n      const areaTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(areaImage);\n      areaTexture.name = \"SMAA.Area\";\n      areaTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      areaTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      areaTexture.generateMipmaps = false;\n      areaTexture.needsUpdate = true;\n      areaTexture.flipY = false;\n      this.weightsMaterial.areaTexture = areaTexture;\n      this.dispatchEvent({ type: \"load\" });\n    };\n    loadingManager.itemStart(\"search\");\n    loadingManager.itemStart(\"area\");\n    if (searchImage !== void 0 && areaImage !== void 0) {\n      loadingManager.itemEnd(\"search\");\n      loadingManager.itemEnd(\"area\");\n    } else if (typeof Image !== \"undefined\") {\n      searchImage = new Image();\n      areaImage = new Image();\n      searchImage.addEventListener(\"load\", () => loadingManager.itemEnd(\"search\"));\n      areaImage.addEventListener(\"load\", () => loadingManager.itemEnd(\"area\"));\n      searchImage.src = searchImageDataURL_default;\n      areaImage.src = areaImageDataURL_default;\n    }\n    this.applyPreset(preset);\n  }\n  /**\n   * The edges texture.\n   *\n   * @type {Texture}\n   */\n  get edgesTexture() {\n    return this.renderTargetEdges.texture;\n  }\n  /**\n   * Returns the edges texture.\n   *\n   * @deprecated Use edgesTexture instead.\n   * @return {Texture} The texture.\n   */\n  getEdgesTexture() {\n    return this.edgesTexture;\n  }\n  /**\n   * The edge weights texture.\n   *\n   * @type {Texture}\n   */\n  get weightsTexture() {\n    return this.renderTargetWeights.texture;\n  }\n  /**\n   * Returns the edge weights texture.\n   *\n   * @deprecated Use weightsTexture instead.\n   * @return {Texture} The texture.\n   */\n  getWeightsTexture() {\n    return this.weightsTexture;\n  }\n  /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   */\n  get edgeDetectionMaterial() {\n    return this.edgeDetectionPass.fullscreenMaterial;\n  }\n  /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   * @deprecated Use edgeDetectionMaterial instead.\n   */\n  get colorEdgesMaterial() {\n    return this.edgeDetectionMaterial;\n  }\n  /**\n   * Returns the edge detection material.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @return {EdgeDetectionMaterial} The material.\n   */\n  getEdgeDetectionMaterial() {\n    return this.edgeDetectionMaterial;\n  }\n  /**\n   * The edge weights material.\n   *\n   * @type {SMAAWeightsMaterial}\n   */\n  get weightsMaterial() {\n    return this.weightsPass.fullscreenMaterial;\n  }\n  /**\n   * Returns the edge weights material.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @return {SMAAWeightsMaterial} The material.\n   */\n  getWeightsMaterial() {\n    return this.weightsMaterial;\n  }\n  /**\n   * Sets the edge detection sensitivity.\n   *\n   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].\n   */\n  setEdgeDetectionThreshold(threshold) {\n    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;\n  }\n  /**\n   * Sets the maximum amount of horizontal/vertical search steps.\n   *\n   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @param {Number} steps - The search steps. Range: [0, 112].\n   */\n  setOrthogonalSearchSteps(steps) {\n    this.weightsMaterial.orthogonalSearchSteps = steps;\n  }\n  /**\n   * Applies the given quality preset.\n   *\n   * @param {SMAAPreset} preset - The preset.\n   */\n  applyPreset(preset) {\n    const edgeDetectionMaterial = this.edgeDetectionMaterial;\n    const weightsMaterial = this.weightsMaterial;\n    switch (preset) {\n      case SMAAPreset.LOW:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;\n        weightsMaterial.orthogonalSearchSteps = 4;\n        weightsMaterial.diagonalDetection = false;\n        weightsMaterial.cornerDetection = false;\n        break;\n      case SMAAPreset.MEDIUM:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n        weightsMaterial.orthogonalSearchSteps = 8;\n        weightsMaterial.diagonalDetection = false;\n        weightsMaterial.cornerDetection = false;\n        break;\n      case SMAAPreset.HIGH:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n        weightsMaterial.orthogonalSearchSteps = 16;\n        weightsMaterial.diagonalSearchSteps = 8;\n        weightsMaterial.cornerRounding = 25;\n        weightsMaterial.diagonalDetection = true;\n        weightsMaterial.cornerDetection = true;\n        break;\n      case SMAAPreset.ULTRA:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;\n        weightsMaterial.orthogonalSearchSteps = 32;\n        weightsMaterial.diagonalSearchSteps = 16;\n        weightsMaterial.cornerRounding = 25;\n        weightsMaterial.diagonalDetection = true;\n        weightsMaterial.cornerDetection = true;\n        break;\n    }\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.edgeDetectionMaterial.depthBuffer = depthTexture;\n    this.edgeDetectionMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    this.clearPass.render(renderer, this.renderTargetEdges);\n    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);\n    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.edgeDetectionMaterial.setSize(width, height);\n    this.weightsMaterial.setSize(width, height);\n    this.renderTargetEdges.setSize(width, height);\n    this.renderTargetWeights.setSize(width, height);\n  }\n  /**\n   * Deletes internal render targets and textures.\n   */\n  dispose() {\n    const { searchTexture, areaTexture } = this.weightsMaterial;\n    if (searchTexture !== null && areaTexture !== null) {\n      searchTexture.dispose();\n      areaTexture.dispose();\n    }\n    super.dispose();\n  }\n  /**\n   * The SMAA search image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */\n  static get searchImageDataURL() {\n    return searchImageDataURL_default;\n  }\n  /**\n   * The SMAA area image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */\n  static get areaImageDataURL() {\n    return areaImageDataURL_default;\n  }\n};\n\n// src/effects/SSAOEffect.js\n\n\n// src/effects/glsl/ssao.frag\nvar ssao_default3 = \"uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\n#endif\\n#ifdef COLORIZE\\nuniform vec3 color;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\\n#else\\nfloat ao=aoLinear;\\n#endif\\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\\n#ifdef COLORIZE\\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\\n#else\\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\\n#endif\\n}\";\n\n// src/effects/SSAOEffect.js\nvar NOISE_TEXTURE_SIZE = 64;\nvar SSAOEffect = class extends Effect {\n  /**\n   * Constructs a new SSAO effect.\n   *\n   * @todo Move normalBuffer to options.\n   * @param {Camera} [camera] - The main camera.\n   * @param {Texture} [normalBuffer] - A texture that contains the scene normals.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.\n   * @param {Boolean} [options.distanceScaling=true] - Deprecated.\n   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.\n   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.\n   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.\n   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.\n   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.\n   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.\n   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.\n   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.\n   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.\n   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.\n   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.\n   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.\n   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.\n   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.\n   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].\n   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.\n   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.\n   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.\n   * @param {Color} [options.color=null] - The color of the ambient occlusion.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(camera, normalBuffer, {\n    blendFunction = BlendFunction.MULTIPLY,\n    samples = 9,\n    rings = 7,\n    normalDepthBuffer = null,\n    depthAwareUpsampling = true,\n    worldDistanceThreshold,\n    worldDistanceFalloff,\n    worldProximityThreshold,\n    worldProximityFalloff,\n    distanceThreshold = 0.97,\n    distanceFalloff = 0.03,\n    rangeThreshold = 5e-4,\n    rangeFalloff = 1e-3,\n    minRadiusScale = 0.1,\n    luminanceInfluence = 0.7,\n    radius = 0.1825,\n    intensity = 1,\n    bias = 0.025,\n    fade = 0.01,\n    color: color2 = null,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"SSAOEffect\", ssao_default3, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      defines: /* @__PURE__ */ new Map([\n        [\"THRESHOLD\", \"0.997\"]\n      ]),\n      uniforms: /* @__PURE__ */ new Map([\n        [\"aoBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"normalDepthBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(normalDepthBuffer)],\n        [\"luminanceInfluence\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceInfluence)],\n        [\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"intensity\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)]\n        // Unused.\n      ])\n    });\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"AO.Target\";\n    this.uniforms.get(\"aoBuffer\").value = this.renderTarget.texture;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.camera = camera;\n    this.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer, resolutionScale });\n    this.depthDownsamplingPass.enabled = normalDepthBuffer === null;\n    this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));\n    const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n    noiseTexture.wrapS = noiseTexture.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n    const ssaoMaterial = this.ssaoMaterial;\n    ssaoMaterial.normalBuffer = normalBuffer;\n    ssaoMaterial.noiseTexture = noiseTexture;\n    ssaoMaterial.minRadiusScale = minRadiusScale;\n    ssaoMaterial.samples = samples;\n    ssaoMaterial.radius = radius;\n    ssaoMaterial.rings = rings;\n    ssaoMaterial.fade = fade;\n    ssaoMaterial.bias = bias;\n    ssaoMaterial.distanceThreshold = distanceThreshold;\n    ssaoMaterial.distanceFalloff = distanceFalloff;\n    ssaoMaterial.proximityThreshold = rangeThreshold;\n    ssaoMaterial.proximityFalloff = rangeFalloff;\n    if (worldDistanceThreshold !== void 0) {\n      ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;\n    }\n    if (worldDistanceFalloff !== void 0) {\n      ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;\n    }\n    if (worldProximityThreshold !== void 0) {\n      ssaoMaterial.worldProximityThreshold = worldProximityThreshold;\n    }\n    if (worldProximityFalloff !== void 0) {\n      ssaoMaterial.worldProximityFalloff = worldProximityFalloff;\n    }\n    if (normalDepthBuffer !== null) {\n      this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n      this.defines.set(\"NORMAL_DEPTH\", \"1\");\n    }\n    this.depthAwareUpsampling = depthAwareUpsampling;\n    this.color = color2;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.ssaoMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Sets the normal buffer.\n   *\n   * @type {Texture}\n   */\n  get normalBuffer() {\n    return this.ssaoMaterial.normalBuffer;\n  }\n  set normalBuffer(value) {\n    this.ssaoMaterial.normalBuffer = value;\n    this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = value;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The SSAO material.\n   *\n   * @type {SSAOMaterial}\n   */\n  get ssaoMaterial() {\n    return this.ssaoPass.fullscreenMaterial;\n  }\n  /**\n   * Returns the SSAO material.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @return {SSAOMaterial} The material.\n   */\n  getSSAOMaterial() {\n    return this.ssaoMaterial;\n  }\n  /**\n   * The amount of occlusion samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.samples instead.\n   */\n  get samples() {\n    return this.ssaoMaterial.samples;\n  }\n  set samples(value) {\n    this.ssaoMaterial.samples = value;\n  }\n  /**\n   * The amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.rings instead.\n   */\n  get rings() {\n    return this.ssaoMaterial.rings;\n  }\n  set rings(value) {\n    this.ssaoMaterial.rings = value;\n  }\n  /**\n   * The occlusion sampling radius.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.radius instead.\n   */\n  get radius() {\n    return this.ssaoMaterial.radius;\n  }\n  set radius(value) {\n    this.ssaoMaterial.radius = value;\n  }\n  /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @type {Boolean}\n   */\n  get depthAwareUpsampling() {\n    return this.defines.has(\"DEPTH_AWARE_UPSAMPLING\");\n  }\n  set depthAwareUpsampling(value) {\n    if (this.depthAwareUpsampling !== value) {\n      if (value) {\n        this.defines.set(\"DEPTH_AWARE_UPSAMPLING\", \"1\");\n      } else {\n        this.defines.delete(\"DEPTH_AWARE_UPSAMPLING\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @return {Boolean} Whether depth-aware upsampling is enabled.\n   */\n  isDepthAwareUpsamplingEnabled() {\n    return this.depthAwareUpsampling;\n  }\n  /**\n   * Enables or disables depth-aware upsampling.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.\n   */\n  setDepthAwareUpsamplingEnabled(value) {\n    this.depthAwareUpsampling = value;\n  }\n  /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get distanceScaling() {\n    return true;\n  }\n  set distanceScaling(value) {\n  }\n  /**\n   * The color of the ambient occlusion. Set to `null` to disable.\n   *\n   * @type {Color}\n   */\n  get color() {\n    return this.uniforms.get(\"color\").value;\n  }\n  set color(value) {\n    const uniforms = this.uniforms;\n    const defines = this.defines;\n    if (value !== null) {\n      if (defines.has(\"COLORIZE\")) {\n        uniforms.get(\"color\").value.set(value);\n      } else {\n        defines.set(\"COLORIZE\", \"1\");\n        uniforms.get(\"color\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Color(value);\n        this.setChanged();\n      }\n    } else if (defines.has(\"COLORIZE\")) {\n      defines.delete(\"COLORIZE\");\n      uniforms.get(\"color\").value = null;\n      this.setChanged();\n    }\n  }\n  /**\n   * The luminance influence factor. Range: [0.0, 1.0].\n   *\n   * @type {Boolean}\n   */\n  get luminanceInfluence() {\n    return this.uniforms.get(\"luminanceInfluence\").value;\n  }\n  set luminanceInfluence(value) {\n    this.uniforms.get(\"luminanceInfluence\").value = value;\n  }\n  /**\n   * The intensity.\n   *\n   * @type {Number}\n   */\n  get intensity() {\n    return this.uniforms.get(\"intensity\").value;\n  }\n  set intensity(value) {\n    this.uniforms.get(\"intensity\").value = value;\n  }\n  /**\n   * Returns the color of the ambient occlusion.\n   *\n   * @deprecated Use color instead.\n   * @return {Color} The color.\n   */\n  getColor() {\n    return this.color;\n  }\n  /**\n   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.\n   *\n   * @deprecated Use color instead.\n   * @param {Color} value - The color.\n   */\n  setColor(value) {\n    this.color = value;\n  }\n  /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setDistanceCutoff(threshold, falloff) {\n    this.ssaoMaterial.distanceThreshold = threshold;\n    this.ssaoMaterial.distanceFalloff = falloff;\n  }\n  /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setProximityCutoff(threshold, falloff) {\n    this.ssaoMaterial.proximityThreshold = threshold;\n    this.ssaoMaterial.proximityFalloff = falloff;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);\n    this.ssaoMaterial.depthBuffer = depthTexture;\n    this.ssaoMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const renderTarget = this.renderTarget;\n    if (this.depthDownsamplingPass.enabled) {\n      this.depthDownsamplingPass.render(renderer);\n    }\n    this.ssaoPass.render(renderer, null, renderTarget);\n  }\n  /**\n   * Sets the size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.ssaoMaterial.copyCameraSettings(this.camera);\n    this.ssaoMaterial.setSize(w, h);\n    this.renderTarget.setSize(w, h);\n    this.depthDownsamplingPass.resolution.scale = resolution.scale;\n    this.depthDownsamplingPass.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    try {\n      let normalDepthBuffer = this.uniforms.get(\"normalDepthBuffer\").value;\n      if (normalDepthBuffer === null) {\n        this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);\n        normalDepthBuffer = this.depthDownsamplingPass.texture;\n        this.uniforms.get(\"normalDepthBuffer\").value = normalDepthBuffer;\n        this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n        this.defines.set(\"NORMAL_DEPTH\", \"1\");\n      }\n    } catch (e) {\n      this.depthDownsamplingPass.enabled = false;\n    }\n  }\n};\n\n// src/effects/TextureEffect.js\n\n\n// src/effects/glsl/texture.frag\nvar texture_default = \"#ifdef TEXTURE_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nvarying vec2 vUv2;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\\n#ifdef UV_TRANSFORM\\nvec4 texel=texture2D(map,vUv2);\\n#else\\nvec4 texel=texture2D(map,uv);\\n#endif\\noutputColor=TEXEL;}\";\n\n// src/effects/glsl/texture.vert\nvar texture_default2 = \"#ifdef ASPECT_CORRECTION\\nuniform float scale;\\n#else\\nuniform mat3 uvTransform;\\n#endif\\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\\n#ifdef ASPECT_CORRECTION\\nvUv2=uv*vec2(aspect,1.0)*scale;\\n#else\\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\\n#endif\\n}\";\n\n// src/effects/TextureEffect.js\nvar TextureEffect = class extends Effect {\n  /**\n   * Constructs a new texture effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Texture} [options.texture] - A texture.\n   * @param {Boolean} [options.aspectCorrection=false] - Deprecated. Adjust the texture's offset, repeat and center instead.\n   */\n  constructor({ blendFunction, texture = null, aspectCorrection = false } = {}) {\n    super(\"TextureEffect\", texture_default, {\n      blendFunction,\n      defines: /* @__PURE__ */ new Map([\n        [\"TEXEL\", \"texel\"]\n      ]),\n      uniforms: /* @__PURE__ */ new Map([\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"uvTransform\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.texture = texture;\n    this.aspectCorrection = aspectCorrection;\n  }\n  /**\n   * The texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.uniforms.get(\"map\").value;\n  }\n  set texture(value) {\n    const prevTexture = this.texture;\n    const uniforms = this.uniforms;\n    const defines = this.defines;\n    if (prevTexture !== value) {\n      uniforms.get(\"map\").value = value;\n      uniforms.get(\"uvTransform\").value = value.matrix;\n      defines.delete(\"TEXTURE_PRECISION_HIGH\");\n      if (value !== null) {\n        if (value.matrixAutoUpdate) {\n          defines.set(\"UV_TRANSFORM\", \"1\");\n          this.setVertexShader(texture_default2);\n        } else {\n          defines.delete(\"UV_TRANSFORM\");\n          this.setVertexShader(null);\n        }\n        if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n          defines.set(\"TEXTURE_PRECISION_HIGH\", \"1\");\n        }\n        if (prevTexture === null || prevTexture.type !== value.type || prevTexture.encoding !== value.encoding) {\n          this.setChanged();\n        }\n      }\n    }\n  }\n  /**\n   * Returns the texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.texture;\n  }\n  /**\n   * Sets the texture.\n   *\n   * @deprecated Use texture instead.\n   * @param {Texture} value - The texture.\n   */\n  setTexture(value) {\n    this.texture = value;\n  }\n  /**\n   * Indicates whether aspect correction is enabled.\n   *\n   * @type {Number}\n   * @deprecated Adjust the texture's offset, repeat, rotation and center instead.\n   */\n  get aspectCorrection() {\n    return this.defines.has(\"ASPECT_CORRECTION\");\n  }\n  set aspectCorrection(value) {\n    if (this.aspectCorrection !== value) {\n      if (value) {\n        this.defines.set(\"ASPECT_CORRECTION\", \"1\");\n      } else {\n        this.defines.delete(\"ASPECT_CORRECTION\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the texture UV coordinates will be transformed using the transformation matrix of the texture.\n   *\n   * @type {Boolean}\n   * @deprecated Use texture.matrixAutoUpdate instead.\n   */\n  get uvTransform() {\n    const texture = this.texture;\n    return texture !== null && texture.matrixAutoUpdate;\n  }\n  set uvTransform(value) {\n    const texture = this.texture;\n    if (texture !== null) {\n      texture.matrixAutoUpdate = value;\n    }\n  }\n  /**\n   * Sets the swizzles that will be applied to the components of a texel before it is written to the output color.\n   *\n   * @param {ColorChannel} r - The swizzle for the `r` component.\n   * @param {ColorChannel} [g=r] - The swizzle for the `g` component.\n   * @param {ColorChannel} [b=r] - The swizzle for the `b` component.\n   * @param {ColorChannel} [a=r] - The swizzle for the `a` component.\n   */\n  setTextureSwizzleRGBA(r, g = r, b = r, a = r) {\n    const rgba = \"rgba\";\n    let swizzle = \"\";\n    if (r !== ColorChannel.RED || g !== ColorChannel.GREEN || b !== ColorChannel.BLUE || a !== ColorChannel.ALPHA) {\n      swizzle = [\".\", rgba[r], rgba[g], rgba[b], rgba[a]].join(\"\");\n    }\n    this.defines.set(\"TEXEL\", \"texel\" + swizzle);\n    this.setChanged();\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    if (this.texture.matrixAutoUpdate) {\n      this.texture.updateMatrix();\n    }\n  }\n};\n\n// src/effects/TiltShiftEffect.js\n\n\n// src/effects/glsl/tilt-shift.frag\nvar tilt_shift_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nuniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}\";\n\n// src/effects/glsl/tilt-shift.vert\nvar tilt_shift_default2 = \"uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}\";\n\n// src/effects/TiltShiftEffect.js\nvar TiltShiftEffect = class extends Effect {\n  /**\n   * Constructs a new tilt shift Effect\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {Number} [options.bias=0.06] - Deprecated.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    blendFunction,\n    offset = 0,\n    rotation = 0,\n    focusArea = 0.4,\n    feather = 0.3,\n    kernelSize = KernelSize.MEDIUM,\n    resolutionScale = 0.5,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super(\"TiltShiftEffect\", tilt_shift_default, {\n      vertexShader: tilt_shift_default2,\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"rotation\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"maskParams\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this._offset = offset;\n    this._focusArea = focusArea;\n    this._feather = feather;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"TiltShift.Target\";\n    this.uniforms.get(\"map\").value = this.renderTarget.texture;\n    this.blurPass = new TiltShiftBlurPass({\n      kernelSize,\n      resolutionScale,\n      resolutionX,\n      resolutionY,\n      offset,\n      rotation,\n      focusArea,\n      feather\n    });\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.rotation = rotation;\n    this.updateParams();\n  }\n  /**\n   * Updates the mask params.\n   *\n   * @private\n   */\n  updateParams() {\n    const params = this.uniforms.get(\"maskParams\").value;\n    const x = Math.max(this.focusArea - this.feather, 0);\n    params.set(this.offset - x, this.offset + x);\n  }\n  /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */\n  get rotation() {\n    return Math.acos(this.uniforms.get(\"rotation\").value.x);\n  }\n  set rotation(value) {\n    this.uniforms.get(\"rotation\").value.set(Math.cos(value), Math.sin(value));\n    this.blurPass.blurMaterial.rotation = value;\n  }\n  /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */\n  get offset() {\n    return this._offset;\n  }\n  set offset(value) {\n    this._offset = value;\n    this.blurPass.blurMaterial.offset = value;\n    this.updateParams();\n  }\n  /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */\n  get focusArea() {\n    return this._focusArea;\n  }\n  set focusArea(value) {\n    this._focusArea = value;\n    this.blurPass.blurMaterial.focusArea = value;\n    this.updateParams();\n  }\n  /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */\n  get feather() {\n    return this._feather;\n  }\n  set feather(value) {\n    this._feather = value;\n    this.blurPass.blurMaterial.feather = value;\n    this.updateParams();\n  }\n  /**\n   * A blend bias.\n   *\n   * @type {Number}\n   * @deprecated\n   */\n  get bias() {\n    return 0;\n  }\n  set bias(value) {\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    this.blurPass.render(renderer, inputBuffer, this.renderTarget);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n    this.blurPass.resolution.copy(resolution);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, frameBufferType);\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n        setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n      }\n    }\n  }\n};\n\n// src/effects/ToneMappingEffect.js\n\n\n// src/effects/glsl/tone-mapping.frag\nvar tone_mapping_default = \"#include <tonemapping_pars_fragment>\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\nuniform float whitePoint;\\n#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2\\nuniform float middleGrey;\\n#if TONE_MAPPING_MODE == 2\\nuniform lowp sampler2D luminanceBuffer;\\n#else\\nuniform float averageLuminance;\\n#endif\\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\\n#if TONE_MAPPING_MODE == 2\\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\\n#else\\nfloat lumAvg=averageLuminance;\\n#endif\\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\\n#elif TONE_MAPPING_MODE == 5\\n#define A 0.15\\n#define B 0.50\\n#define C 0.10\\n#define D 0.20\\n#define E 0.02\\n#define F 0.30\\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\\n#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2\\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\\n#elif TONE_MAPPING_MODE == 5\\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\\n#else\\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\\n#endif\\n}\";\n\n// src/effects/ToneMappingEffect.js\nvar ToneMappingEffect = class extends Effect {\n  /**\n   * Constructs a new tone mapping effect.\n   *\n   * The additional parameters only affect the Reinhard2 operator.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.adaptive=false] - Deprecated. Use mode instead.\n   * @param {ToneMappingMode} [options.mode=ToneMappingMode.ACES_FILMIC] - The tone mapping mode.\n   * @param {Number} [options.resolution=256] - The resolution of the luminance texture. Must be a power of two.\n   * @param {Number} [options.maxLuminance=4.0] - Deprecated. Same as whitePoint.\n   * @param {Number} [options.whitePoint=4.0] - The white point.\n   * @param {Number} [options.middleGrey=0.6] - The middle grey factor.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance. Prevents very high exposure in dark scenes.\n   * @param {Number} [options.averageLuminance=1.0] - The average luminance. Used for the non-adaptive Reinhard operator.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */\n  constructor({\n    blendFunction = BlendFunction.SRC,\n    adaptive = false,\n    mode = adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.ACES_FILMIC,\n    resolution = 256,\n    maxLuminance = 4,\n    whitePoint = maxLuminance,\n    middleGrey = 0.6,\n    minLuminance = 0.01,\n    averageLuminance = 1,\n    adaptationRate = 1\n  } = {}) {\n    super(\"ToneMappingEffect\", tone_mapping_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"luminanceBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"maxLuminance\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxLuminance)],\n        // Unused\n        [\"whitePoint\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(whitePoint)],\n        [\"middleGrey\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(middleGrey)],\n        [\"averageLuminance\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(averageLuminance)]\n      ])\n    });\n    this.renderTargetLuminance = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter,\n      depthBuffer: false\n    });\n    this.renderTargetLuminance.texture.generateMipmaps = true;\n    this.renderTargetLuminance.texture.name = \"Luminance\";\n    this.luminancePass = new LuminancePass({\n      renderTarget: this.renderTargetLuminance\n    });\n    this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, {\n      minLuminance,\n      adaptationRate\n    });\n    this.uniforms.get(\"luminanceBuffer\").value = this.adaptiveLuminancePass.texture;\n    this.resolution = resolution;\n    this.mode = mode;\n  }\n  /**\n   * The tone mapping mode.\n   *\n   * @type {ToneMappingMode}\n   */\n  get mode() {\n    return Number(this.defines.get(\"TONE_MAPPING_MODE\"));\n  }\n  set mode(value) {\n    if (this.mode !== value) {\n      this.defines.clear();\n      this.defines.set(\"TONE_MAPPING_MODE\", value.toFixed(0));\n      switch (value) {\n        case ToneMappingMode.REINHARD:\n          this.defines.set(\"toneMapping(texel)\", \"ReinhardToneMapping(texel)\");\n          break;\n        case ToneMappingMode.OPTIMIZED_CINEON:\n          this.defines.set(\"toneMapping(texel)\", \"OptimizedCineonToneMapping(texel)\");\n          break;\n        case ToneMappingMode.ACES_FILMIC:\n          this.defines.set(\"toneMapping(texel)\", \"ACESFilmicToneMapping(texel)\");\n          break;\n        default:\n          this.defines.set(\"toneMapping(texel)\", \"texel\");\n          break;\n      }\n      this.adaptiveLuminancePass.enabled = value === ToneMappingMode.REINHARD2_ADAPTIVE;\n      this.setChanged();\n    }\n  }\n  /**\n   * Returns the current tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {ToneMappingMode} The tone mapping mode.\n   */\n  getMode() {\n    return this.mode;\n  }\n  /**\n   * Sets the tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {ToneMappingMode} value - The tone mapping mode.\n   */\n  setMode(value) {\n    this.mode = value;\n  }\n  /**\n   * The white point. Default is `4.0`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */\n  get whitePoint() {\n    return this.uniforms.get(\"whitePoint\").value;\n  }\n  set whitePoint(value) {\n    this.uniforms.get(\"whitePoint\").value = value;\n  }\n  /**\n   * The middle grey factor. Default is `0.6`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */\n  get middleGrey() {\n    return this.uniforms.get(\"middleGrey\").value;\n  }\n  set middleGrey(value) {\n    this.uniforms.get(\"middleGrey\").value = value;\n  }\n  /**\n   * The average luminance.\n   *\n   * Only applies to Reinhard2 (Modified).\n   *\n   * @type {Number}\n   */\n  get averageLuminance() {\n    return this.uniforms.get(\"averageLuminance\").value;\n  }\n  set averageLuminance(value) {\n    this.uniforms.get(\"averageLuminance\").value = value;\n  }\n  /**\n   * The adaptive luminance material.\n   *\n   * @type {AdaptiveLuminanceMaterial}\n   */\n  get adaptiveLuminanceMaterial() {\n    return this.adaptiveLuminancePass.fullscreenMaterial;\n  }\n  /**\n   * Returns the adaptive luminance material.\n   *\n   * @deprecated Use adaptiveLuminanceMaterial instead.\n   * @return {AdaptiveLuminanceMaterial} The material.\n   */\n  getAdaptiveLuminanceMaterial() {\n    return this.adaptiveLuminanceMaterial;\n  }\n  /**\n   * The resolution of the luminance texture. Must be a power of two.\n   *\n   * @type {Number}\n   */\n  get resolution() {\n    return this.luminancePass.resolution.width;\n  }\n  set resolution(value) {\n    const exponent = Math.max(0, Math.ceil(Math.log2(value)));\n    const size = Math.pow(2, exponent);\n    this.luminancePass.resolution.setPreferredSize(size, size);\n    this.adaptiveLuminanceMaterial.mipLevel1x1 = exponent;\n  }\n  /**\n   * Returns the resolution of the luminance texture.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Number} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Sets the resolution of the luminance texture. Must be a power of two.\n   *\n   * @deprecated Use resolution instead.\n   * @param {Number} value - The resolution.\n   */\n  setResolution(value) {\n    this.resolution = value;\n  }\n  /**\n   * Indicates whether this pass uses adaptive luminance.\n   *\n   * @type {Boolean}\n   * @deprecated Use mode instead.\n   */\n  get adaptive() {\n    return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE;\n  }\n  set adaptive(value) {\n    this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;\n  }\n  /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use adaptiveLuminanceMaterial.adaptationRate instead.\n   */\n  get adaptationRate() {\n    return this.adaptiveLuminanceMaterial.adaptationRate;\n  }\n  set adaptationRate(value) {\n    this.adaptiveLuminanceMaterial.adaptationRate = value;\n  }\n  /**\n   * @type {Number}\n   * @deprecated\n   */\n  get distinction() {\n    console.warn(this.name, \"distinction was removed.\");\n    return 1;\n  }\n  set distinction(value) {\n    console.warn(this.name, \"distinction was removed.\");\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    if (this.adaptiveLuminancePass.enabled) {\n      this.luminancePass.render(renderer, inputBuffer);\n      this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);\n  }\n};\n\n// src/effects/VignetteEffect.js\n\n\n// src/effects/glsl/vignette.frag\nvar vignette_default = \"uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\\n#if VIGNETTE_TECHNIQUE == 0\\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\\n#else\\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\\n#endif\\noutputColor=vec4(color,inputColor.a);}\";\n\n// src/effects/VignetteEffect.js\nvar VignetteEffect = class extends Effect {\n  /**\n   * Constructs a new Vignette effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.\n   * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.\n   * @param {Number} [options.offset=0.5] - The Vignette offset.\n   * @param {Number} [options.darkness=0.5] - The Vignette darkness.\n   */\n  constructor({\n    blendFunction,\n    technique = VignetteTechnique.DEFAULT,\n    eskil = false,\n    offset = 0.5,\n    darkness = 0.5\n  } = {}) {\n    super(\"VignetteEffect\", vignette_default, {\n      blendFunction,\n      defines: /* @__PURE__ */ new Map([\n        [\"VIGNETTE_TECHNIQUE\", technique.toFixed(0)]\n      ]),\n      uniforms: /* @__PURE__ */ new Map([\n        [\"offset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)],\n        [\"darkness\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(darkness)]\n      ])\n    });\n  }\n  /**\n   * The Vignette technique.\n   *\n   * @type {VignetteTechnique}\n   */\n  get technique() {\n    return Number(this.defines.get(\"VIGNETTE_TECHNIQUE\"));\n  }\n  set technique(value) {\n    if (this.technique !== value) {\n      this.defines.set(\"VIGNETTE_TECHNIQUE\", value.toFixed(0));\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */\n  get eskil() {\n    return this.technique === VignetteTechnique.ESKIL;\n  }\n  /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */\n  set eskil(value) {\n    this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;\n  }\n  /**\n   * Returns the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @return {VignetteTechnique} The technique.\n   */\n  getTechnique() {\n    return this.technique;\n  }\n  /**\n   * Sets the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @param {VignetteTechnique} value - The technique.\n   */\n  setTechnique(value) {\n    this.technique = value;\n  }\n  /**\n   * The Vignette offset.\n   *\n   * @type {Number}\n   */\n  get offset() {\n    return this.uniforms.get(\"offset\").value;\n  }\n  set offset(value) {\n    this.uniforms.get(\"offset\").value = value;\n  }\n  /**\n   * Returns the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @return {Number} The offset.\n   */\n  getOffset() {\n    return this.offset;\n  }\n  /**\n   * Sets the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @param {Number} value - The offset.\n   */\n  setOffset(value) {\n    this.offset = value;\n  }\n  /**\n   * The Vignette darkness.\n   *\n   * @type {Number}\n   */\n  get darkness() {\n    return this.uniforms.get(\"darkness\").value;\n  }\n  set darkness(value) {\n    this.uniforms.get(\"darkness\").value = value;\n  }\n  /**\n   * Returns the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @return {Number} The darkness.\n   */\n  getDarkness() {\n    return this.darkness;\n  }\n  /**\n   * Sets the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @param {Number} value - The darkness.\n   */\n  setDarkness(value) {\n    this.darkness = value;\n  }\n};\n\n// src/loaders/LUT3dlLoader.js\n\nvar LUT3dlLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the 3dl-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */\n  load(url, onLoad = () => {\n  }, onProgress = () => {\n  }, onError = null) {\n    const externalManager = this.manager;\n    const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    return new Promise((resolve, reject) => {\n      internalManager.onError = (url2) => {\n        externalManager.itemError(url2);\n        if (onError !== null) {\n          onError(`Failed to load ${url2}`);\n          resolve();\n        } else {\n          reject(`Failed to load ${url2}`);\n        }\n      };\n      externalManager.itemStart(url);\n      loader.load(url, (data) => {\n        try {\n          const result = this.parse(data);\n          externalManager.itemEnd(url);\n          onLoad(result);\n          resolve(result);\n        } catch (e) {\n          console.error(e);\n          internalManager.onError(url);\n        }\n      }, onProgress);\n    });\n  }\n  /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */\n  parse(input) {\n    const regExpGridInfo = /^[\\d ]+$/m;\n    const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n    let result = regExpGridInfo.exec(input);\n    if (result === null) {\n      throw new Error(\"Missing grid information\");\n    }\n    const gridLines = result[0].trim().split(/\\s+/g).map((n) => Number(n));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n    const sizeSq = size ** 2;\n    for (let i = 1, l = gridLines.length; i < l; ++i) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error(\"Inconsistent grid size\");\n      }\n    }\n    const data = new Float32Array(size ** 3 * 4);\n    let maxValue = 0;\n    let index = 0;\n    while ((result = regExpDataPoints.exec(input)) !== null) {\n      const r = Number(result[1]);\n      const g = Number(result[2]);\n      const b = Number(result[3]);\n      maxValue = Math.max(maxValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / sizeSq) % size;\n      const d4 = (bLayer * sizeSq + gLayer * size + rLayer) * 4;\n      data[d4 + 0] = r;\n      data[d4 + 1] = g;\n      data[d4 + 2] = b;\n      data[d4 + 3] = 1;\n      ++index;\n    }\n    const bits = Math.ceil(Math.log2(maxValue));\n    const maxBitValue = Math.pow(2, bits);\n    for (let i = 0, l = data.length; i < l; i += 4) {\n      data[i + 0] /= maxBitValue;\n      data[i + 1] /= maxBitValue;\n      data[i + 2] /= maxBitValue;\n    }\n    return new LookupTexture(data, size);\n  }\n};\n\n// src/loaders/LUTCubeLoader.js\n\nvar LUTCubeLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the CUBE-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */\n  load(url, onLoad = () => {\n  }, onProgress = () => {\n  }, onError = null) {\n    const externalManager = this.manager;\n    const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    return new Promise((resolve, reject) => {\n      internalManager.onError = (url2) => {\n        externalManager.itemError(url2);\n        if (onError !== null) {\n          onError(`Failed to load ${url2}`);\n          resolve();\n        } else {\n          reject(`Failed to load ${url2}`);\n        }\n      };\n      externalManager.itemStart(url);\n      loader.load(url, (data) => {\n        try {\n          const result = this.parse(data);\n          externalManager.itemEnd(url);\n          onLoad(result);\n          resolve(result);\n        } catch (e) {\n          console.error(e);\n          internalManager.onError(url);\n        }\n      }, onProgress);\n    });\n  }\n  /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */\n  parse(input) {\n    const regExpTitle = /TITLE +\"([^\"]*)\"/;\n    const regExpSize = /LUT_3D_SIZE +(\\d+)/;\n    const regExpDomainMin = /DOMAIN_MIN +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n    const regExpDomainMax = /DOMAIN_MAX +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n    const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n    let result = regExpTitle.exec(input);\n    const title = result !== null ? result[1] : null;\n    result = regExpSize.exec(input);\n    if (result === null) {\n      throw new Error(\"Missing LUT_3D_SIZE information\");\n    }\n    const size = Number(result[1]);\n    const data = new Float32Array(size ** 3 * 4);\n    const domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    const domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n    result = regExpDomainMin.exec(input);\n    if (result !== null) {\n      domainMin.set(Number(result[1]), Number(result[2]), Number(result[3]));\n    }\n    result = regExpDomainMax.exec(input);\n    if (result !== null) {\n      domainMax.set(Number(result[1]), Number(result[2]), Number(result[3]));\n    }\n    if (domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z) {\n      domainMin.set(0, 0, 0);\n      domainMax.set(1, 1, 1);\n      throw new Error(\"Invalid input domain\");\n    }\n    let i = 0;\n    while ((result = regExpDataPoints.exec(input)) !== null) {\n      data[i++] = Number(result[1]);\n      data[i++] = Number(result[2]);\n      data[i++] = Number(result[3]);\n      data[i++] = 1;\n    }\n    const lut = new LookupTexture(data, size);\n    lut.domainMin.copy(domainMin);\n    lut.domainMax.copy(domainMax);\n    if (title !== null) {\n      lut.name = title;\n    }\n    return lut;\n  }\n};\n\n// src/loaders/SMAAImageLoader.js\n\nvar SMAAImageLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  /**\n   * Loads the SMAA data images.\n   *\n   * @param {Function} [onLoad] - A callback that receives the search image and area image as a pair.\n   * @param {Function} [onError] - An error callback that receives the URL of the image that failed to load.\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */\n  load(onLoad = () => {\n  }, onError = null) {\n    if (arguments.length === 4) {\n      onLoad = arguments[1];\n      onError = arguments[3];\n    } else if (arguments.length === 3 || typeof arguments[0] !== \"function\") {\n      onLoad = arguments[1];\n      onError = null;\n    }\n    const externalManager = this.manager;\n    const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    return new Promise((resolve, reject) => {\n      const searchImage = new Image();\n      const areaImage = new Image();\n      internalManager.onError = (url) => {\n        externalManager.itemError(url);\n        if (onError !== null) {\n          onError(`Failed to load ${url}`);\n          resolve();\n        } else {\n          reject(`Failed to load ${url}`);\n        }\n      };\n      internalManager.onLoad = () => {\n        const result = [searchImage, areaImage];\n        onLoad(result);\n        resolve(result);\n      };\n      searchImage.addEventListener(\"error\", (e) => {\n        internalManager.itemError(\"smaa-search\");\n      });\n      areaImage.addEventListener(\"error\", (e) => {\n        internalManager.itemError(\"smaa-area\");\n      });\n      searchImage.addEventListener(\"load\", () => {\n        externalManager.itemEnd(\"smaa-search\");\n        internalManager.itemEnd(\"smaa-search\");\n      });\n      areaImage.addEventListener(\"load\", () => {\n        externalManager.itemEnd(\"smaa-area\");\n        internalManager.itemEnd(\"smaa-area\");\n      });\n      externalManager.itemStart(\"smaa-search\");\n      externalManager.itemStart(\"smaa-area\");\n      internalManager.itemStart(\"smaa-search\");\n      internalManager.itemStart(\"smaa-area\");\n      searchImage.src = searchImageDataURL_default;\n      areaImage.src = areaImageDataURL_default;\n    });\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFVZTs7QUFFZjtBQUMrRTs7QUFFL0U7QUFDNEQ7O0FBRTVEO0FBQ0EsZ01BQWdNLHdDQUF3QywyQkFBMkIsd0JBQXdCLGtCQUFrQixpQkFBaUIsWUFBWSw0REFBNEQsd0ZBQXdGLG1FQUFtRSxrQ0FBa0Msd0JBQXdCLHNEQUFzRCxzRUFBc0U7O0FBRXZ0QjtBQUNBLHVDQUF1QyxZQUFZLHdCQUF3Qix1Q0FBdUM7O0FBRWxIO0FBQ0EsOENBQThDLGlEQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw4QkFBOEIsMENBQU87QUFDckMsOEJBQThCLDBDQUFPO0FBQ3JDLDBCQUEwQiwwQ0FBTztBQUNqQyx1QkFBdUIsMENBQU87QUFDOUIsaUJBQWlCLDBDQUFPO0FBQ3hCLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLGdCQUFnQiw2Q0FBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2tKOztBQUVsSjtBQUMrRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDJDQUFRO0FBQzlCO0FBQ0E7QUFDQSxHQUFHLGlEQUFjO0FBQ2pCLEdBQUcsK0NBQVk7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtB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Q3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzZDOztBQUU3QztBQUNB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QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLHNCQUFzQixVQUFVO0FBQ2hDLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsc0JBQXNCLFVBQVU7QUFDaEMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaURBQWU7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzZFO0FBQzdFLG9DQUFvQyx5Q0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlEQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0EsVUFBVTtBQUNWLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFtSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL2J1aWxkL2luZGV4LmpzP2I4YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBwb3N0cHJvY2Vzc2luZyB2Ni4zMy40IGJ1aWxkIFNhdCBEZWMgMDIgMjAyM1xuICogaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9wb3N0cHJvY2Vzc2luZ1xuICogQ29weXJpZ2h0IDIwMTUtMjAyMyBSYW91bCB2YW4gUsO8c2NoZW5cbiAqIEBsaWNlbnNlIFpsaWJcbiAqL1xuXG4vLyBwYWNrYWdlLmpzb25cbnZhciB2ZXJzaW9uID0gXCI2LjMzLjRcIjtcblxuLy8gc3JjL2NvcmUvRGlzcG9zYWJsZS5qc1xudmFyIERpc3Bvc2FibGUgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBGcmVlcyBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9FZmZlY3RDb21wb3Nlci5qc1xuaW1wb3J0IHtcbiAgRGVwdGhTdGVuY2lsRm9ybWF0LFxuICBEZXB0aFRleHR1cmUsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXIyLFxuICBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxMSxcbiAgVW5zaWduZWRJbnRUeXBlLFxuICBVbnNpZ25lZEludDI0OFR5cGUsXG4gIFZlY3RvcjIgYXMgVmVjdG9yMjE2LFxuICBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDEzXG59IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvcGFzc2VzL0FkYXB0aXZlTHVtaW5hbmNlUGFzcy5qc1xuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZywgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0gfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2FkYXB0aXZlLWx1bWluYW5jZS5mcmFnXG52YXIgYWRhcHRpdmVfbHVtaW5hbmNlX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxwYWNraW5nPlxcbiNkZWZpbmUgcGFja0Zsb2F0VG9SR0JBKHYpIHBhY2tEZXB0aFRvUkdCQSh2KVxcbiNkZWZpbmUgdW5wYWNrUkdCQVRvRmxvYXQodikgdW5wYWNrUkdCQVRvRGVwdGgodilcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGx1bWluYW5jZUJ1ZmZlcjA7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBsdW1pbmFuY2VCdWZmZXIxO3VuaWZvcm0gZmxvYXQgbWluTHVtaW5hbmNlO3VuaWZvcm0gZmxvYXQgZGVsdGFUaW1lO3VuaWZvcm0gZmxvYXQgdGF1O3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7ZmxvYXQgbDA9dW5wYWNrUkdCQVRvRmxvYXQodGV4dHVyZTJEKGx1bWluYW5jZUJ1ZmZlcjAsdlV2KSk7XFxuI2lmIF9fVkVSU0lPTl9fIDwgMzAwXFxuZmxvYXQgbDE9dGV4dHVyZTJETG9kRVhUKGx1bWluYW5jZUJ1ZmZlcjEsdlV2LE1JUF9MRVZFTF8xWDEpLnI7XFxuI2Vsc2VcXG5mbG9hdCBsMT10ZXh0dXJlTG9kKGx1bWluYW5jZUJ1ZmZlcjEsdlV2LE1JUF9MRVZFTF8xWDEpLnI7XFxuI2VuZGlmXFxubDA9bWF4KG1pbkx1bWluYW5jZSxsMCk7bDE9bWF4KG1pbkx1bWluYW5jZSxsMSk7ZmxvYXQgYWRhcHRlZEx1bT1sMCsobDEtbDApKigxLjAtZXhwKC1kZWx0YVRpbWUqdGF1KSk7Z2xfRnJhZ0NvbG9yPShhZGFwdGVkTHVtPT0xLjApP3ZlYzQoMS4wKTpwYWNrRmxvYXRUb1JHQkEoYWRhcHRlZEx1bSk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29tbW9uLnZlcnRcbnZhciBjb21tb25fZGVmYXVsdCA9IFwidmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9BZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmpzXG52YXIgQWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBhZGFwdGl2ZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgTUlQX0xFVkVMXzFYMTogXCIwLjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGx1bWluYW5jZUJ1ZmZlcjA6IG5ldyBVbmlmb3JtKG51bGwpLFxuICAgICAgICBsdW1pbmFuY2VCdWZmZXIxOiBuZXcgVW5pZm9ybShudWxsKSxcbiAgICAgICAgbWluTHVtaW5hbmNlOiBuZXcgVW5pZm9ybSgwLjAxKSxcbiAgICAgICAgZGVsdGFUaW1lOiBuZXcgVW5pZm9ybSgwKSxcbiAgICAgICAgdGF1OiBuZXcgVW5pZm9ybSgxKVxuICAgICAgfSxcbiAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgc2hhZGVyVGV4dHVyZUxPRDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogYWRhcHRpdmVfbHVtaW5hbmNlX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmltYXJ5IGx1bWluYW5jZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgZG93bnNhbXBsZWQgYXZlcmFnZSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGx1bWluYW5jZUJ1ZmZlcjAodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmx1bWluYW5jZUJ1ZmZlcjAudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJpbWFyeSBsdW1pbmFuY2UgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIGRvd25zYW1wbGVkIGF2ZXJhZ2UgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHVtaW5hbmNlQnVmZmVyMCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldEx1bWluYW5jZUJ1ZmZlcjAodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmx1bWluYW5jZUJ1ZmZlcjAudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlY29uZGFyeSBsdW1pbmFuY2UgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBsdW1pbmFuY2VCdWZmZXIxKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5sdW1pbmFuY2VCdWZmZXIxLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlY29uZGFyeSBsdW1pbmFuY2UgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHVtaW5hbmNlQnVmZmVyMSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldEx1bWluYW5jZUJ1ZmZlcjEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmx1bWluYW5jZUJ1ZmZlcjEudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIDF4MSBtaXBtYXAgbGV2ZWwuXG4gICAqXG4gICAqIFRoaXMgbGV2ZWwgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgc21hbGxlc3QgbWlwbWFwIG9mIHRoZSBwcmltYXJ5IGx1bWluYW5jZSBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgbWlwTGV2ZWwxeDEodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuTUlQX0xFVkVMXzFYMSA9IHZhbHVlLnRvRml4ZWQoMSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIDF4MSBtaXBtYXAgbGV2ZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaXBMZXZlbDF4MSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbGV2ZWwuXG4gICAqL1xuICBzZXRNaXBMZXZlbDF4MSh2YWx1ZSkge1xuICAgIHRoaXMubWlwTGV2ZWwxeDEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlbHRhIHRpbWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgZGVsdGFUaW1lKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YVRpbWUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVsdGEgdGltZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlbHRhVGltZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZGVsdGEgdGltZS5cbiAgICovXG4gIHNldERlbHRhVGltZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVsdGFUaW1lLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsb3dlc3QgcG9zc2libGUgbHVtaW5hbmNlIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbkx1bWluYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5taW5MdW1pbmFuY2UudmFsdWU7XG4gIH1cbiAgc2V0IG1pbkx1bWluYW5jZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWluTHVtaW5hbmNlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxvd2VzdCBwb3NzaWJsZSBsdW1pbmFuY2UgdmFsdWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5MdW1pbmFuY2UgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWluaW11bSBsdW1pbmFuY2UuXG4gICAqL1xuICBnZXRNaW5MdW1pbmFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWluTHVtaW5hbmNlLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtaW5pbXVtIGx1bWluYW5jZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkx1bWluYW5jZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBsdW1pbmFuY2UuXG4gICAqL1xuICBzZXRNaW5MdW1pbmFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1pbkx1bWluYW5jZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBhZGFwdGF0aW9uUmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50YXUudmFsdWU7XG4gIH1cbiAgc2V0IGFkYXB0YXRpb25SYXRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy50YXUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFkYXB0YXRpb25SYXRlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICovXG4gIGdldEFkYXB0YXRpb25SYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRhdS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFkYXB0YXRpb25SYXRlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqL1xuICBzZXRBZGFwdGF0aW9uUmF0ZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudGF1LnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvQm9rZWhNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwyLCBVbmlmb3JtIGFzIFVuaWZvcm0yLCBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5ib2tlaC5mcmFnXG52YXIgY29udm9sdXRpb25fYm9rZWhfZGVmYXVsdCA9IFwiI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxuI2lmIFBBU1MgPT0gMVxcbnVuaWZvcm0gdmVjNCBrZXJuZWw2NFszMl07XFxuI2Vsc2VcXG51bmlmb3JtIHZlYzQga2VybmVsMTZbOF07XFxuI2VuZGlmXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBjb2NCdWZmZXI7dW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIGZsb2F0IHNjYWxlO3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7XFxuI2lmZGVmIEZPUkVHUk9VTkRcXG52ZWMyIGNvY05lYXJGYXI9dGV4dHVyZTJEKGNvY0J1ZmZlcix2VXYpLnJnKnNjYWxlO2Zsb2F0IGNvYz1jb2NOZWFyRmFyLng7XFxuI2Vsc2VcXG5mbG9hdCBjb2M9dGV4dHVyZTJEKGNvY0J1ZmZlcix2VXYpLmcqc2NhbGU7XFxuI2VuZGlmXFxuaWYoY29jPT0wLjApe2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTt9ZWxzZXtcXG4jaWZkZWYgRk9SRUdST1VORFxcbnZlYzIgc3RlcD10ZXhlbFNpemUqbWF4KGNvY05lYXJGYXIueCxjb2NOZWFyRmFyLnkpO1xcbiNlbHNlXFxudmVjMiBzdGVwPXRleGVsU2l6ZSpjb2M7XFxuI2VuZGlmXFxuI2lmIFBBU1MgPT0gMVxcbnZlYzQgYWNjPXZlYzQoMC4wKTtmb3IoaW50IGk9MDtpPDMyOysraSl7dmVjNCBrZXJuZWw9a2VybmVsNjRbaV07dmVjMiB1dj1zdGVwKmtlcm5lbC54eSt2VXY7YWNjKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYpO3V2PXN0ZXAqa2VybmVsLnp3K3ZVdjthY2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1dik7fWdsX0ZyYWdDb2xvcj1hY2MvNjQuMDtcXG4jZWxzZVxcbnZlYzQgbWF4VmFsdWU9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdik7Zm9yKGludCBpPTA7aTw4OysraSl7dmVjNCBrZXJuZWw9a2VybmVsMTZbaV07dmVjMiB1dj1zdGVwKmtlcm5lbC54eSt2VXY7bWF4VmFsdWU9bWF4KHRleHR1cmUyRChpbnB1dEJ1ZmZlcix1diksbWF4VmFsdWUpO3V2PXN0ZXAqa2VybmVsLnp3K3ZVdjttYXhWYWx1ZT1tYXgodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2KSxtYXhWYWx1ZSk7fWdsX0ZyYWdDb2xvcj1tYXhWYWx1ZTtcXG4jZW5kaWZcXG59fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0Jva2VoTWF0ZXJpYWwuanNcbnZhciBCb2tlaE1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBib2tlaCBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmlsbD1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBib2tlaCBoaWdobGlnaHQgZmlsbCBtb2RlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JlZ3JvdW5kPWZhbHNlXSAtIERldGVybWluZXMgd2hldGhlciB0aGlzIG1hdGVyaWFsIHdpbGwgYmUgYXBwbGllZCB0byBmb3JlZ3JvdW5kIGNvbG9ycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbGwgPSBmYWxzZSwgZm9yZWdyb3VuZCA9IGZhbHNlKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJCb2tlaE1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIFBBU1M6IGZpbGwgPyBcIjJcIiA6IFwiMVwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMihudWxsKSxcbiAgICAgICAgY29jQnVmZmVyOiBuZXcgVW5pZm9ybTIobnVsbCksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0yKG5ldyBWZWN0b3IyKCkpLFxuICAgICAgICBrZXJuZWw2NDogbmV3IFVuaWZvcm0yKG51bGwpLFxuICAgICAgICBrZXJuZWwxNjogbmV3IFVuaWZvcm0yKG51bGwpLFxuICAgICAgICBzY2FsZTogbmV3IFVuaWZvcm0yKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcyLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fYm9rZWhfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgICBpZiAoZm9yZWdyb3VuZCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkZPUkVHUk9VTkQgPSBcIjFcIjtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZUtlcm5lbCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBjb2NCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmNvY0J1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvY0J1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldENvQ0J1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuY29jQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0U2NhbGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGJsdXIga2VybmVsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VuZXJhdGVLZXJuZWwoKSB7XG4gICAgY29uc3QgR09MREVOX0FOR0xFID0gMi4zOTk5NjMyMztcbiAgICBjb25zdCBwb2ludHM2NCA9IG5ldyBGbG9hdDY0QXJyYXkoMTI4KTtcbiAgICBjb25zdCBwb2ludHMxNiA9IG5ldyBGbG9hdDY0QXJyYXkoMzIpO1xuICAgIGxldCBpNjQgPSAwLCBpMTYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcXJ0ODAgPSBNYXRoLnNxcnQoODApOyBpIDwgODA7ICsraSkge1xuICAgICAgY29uc3QgdGhldGEgPSBpICogR09MREVOX0FOR0xFO1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChpKSAvIHNxcnQ4MDtcbiAgICAgIGNvbnN0IHUgPSByICogTWF0aC5jb3ModGhldGEpLCB2MyA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICBpZiAoaSAlIDUgPT09IDApIHtcbiAgICAgICAgcG9pbnRzMTZbaTE2KytdID0gdTtcbiAgICAgICAgcG9pbnRzMTZbaTE2KytdID0gdjM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludHM2NFtpNjQrK10gPSB1O1xuICAgICAgICBwb2ludHM2NFtpNjQrK10gPSB2MztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5rZXJuZWw2NC52YWx1ZSA9IHBvaW50czY0O1xuICAgIHRoaXMudW5pZm9ybXMua2VybmVsMTYudmFsdWUgPSBwb2ludHMxNjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Cb3hCbHVyTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzMsIFBlcnNwZWN0aXZlQ2FtZXJhLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDMsIFVuaWZvcm0gYXMgVW5pZm9ybTMsIFZlY3RvcjIgYXMgVmVjdG9yMjIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3V0aWxzL0JhY2tDb21wYXQuanNcbmltcG9ydCB7IExpbmVhckVuY29kaW5nLCBSRVZJU0lPTiwgc1JHQkVuY29kaW5nIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lbnVtcy9CbGVuZEZ1bmN0aW9uLmpzXG52YXIgQmxlbmRGdW5jdGlvbiA9IHtcbiAgU0tJUDogOSxcbiAgU0VUOiAzMCxcbiAgQUREOiAwLFxuICBBTFBIQTogMSxcbiAgQVZFUkFHRTogMixcbiAgQ09MT1I6IDMsXG4gIENPTE9SX0JVUk46IDQsXG4gIENPTE9SX0RPREdFOiA1LFxuICBEQVJLRU46IDYsXG4gIERJRkZFUkVOQ0U6IDcsXG4gIERJVklERTogOCxcbiAgRFNUOiA5LFxuICBFWENMVVNJT046IDEwLFxuICBIQVJEX0xJR0hUOiAxMSxcbiAgSEFSRF9NSVg6IDEyLFxuICBIVUU6IDEzLFxuICBJTlZFUlQ6IDE0LFxuICBJTlZFUlRfUkdCOiAxNSxcbiAgTElHSFRFTjogMTYsXG4gIExJTkVBUl9CVVJOOiAxNyxcbiAgTElORUFSX0RPREdFOiAxOCxcbiAgTElORUFSX0xJR0hUOiAxOSxcbiAgTFVNSU5PU0lUWTogMjAsXG4gIE1VTFRJUExZOiAyMSxcbiAgTkVHQVRJT046IDIyLFxuICBOT1JNQUw6IDIzLFxuICBPVkVSTEFZOiAyNCxcbiAgUElOX0xJR0hUOiAyNSxcbiAgUkVGTEVDVDogMjYsXG4gIFNBVFVSQVRJT046IDI3LFxuICBTQ1JFRU46IDI4LFxuICBTT0ZUX0xJR0hUOiAyOSxcbiAgU1JDOiAzMCxcbiAgU1VCVFJBQ1Q6IDMxLFxuICBWSVZJRF9MSUdIVDogMzJcbn07XG5cbi8vIHNyYy9lbnVtcy9Db2xvckNoYW5uZWwuanNcbnZhciBDb2xvckNoYW5uZWwgPSB7XG4gIFJFRDogMCxcbiAgR1JFRU46IDEsXG4gIEJMVUU6IDIsXG4gIEFMUEhBOiAzXG59O1xuXG4vLyBzcmMvZW51bXMvQ29sb3JTcGFjZS5qc1xudmFyIE5vQ29sb3JTcGFjZSA9IFwiXCI7XG52YXIgU1JHQkNvbG9yU3BhY2UgPSBcInNyZ2JcIjtcbnZhciBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbnZhciBEaXNwbGF5UDNDb2xvclNwYWNlID0gXCJkaXNwbGF5LXAzXCI7XG5cbi8vIHNyYy9lbnVtcy9EZXB0aENvcHlNb2RlLmpzXG52YXIgRGVwdGhDb3B5TW9kZSA9IHtcbiAgRlVMTDogMCxcbiAgU0lOR0xFOiAxXG59O1xuXG4vLyBzcmMvZW51bXMvRGVwdGhUZXN0U3RyYXRlZ3kuanNcbnZhciBEZXB0aFRlc3RTdHJhdGVneSA9IHtcbiAgREVGQVVMVDogMCxcbiAgS0VFUF9NQVhfREVQVEg6IDEsXG4gIERJU0NBUkRfTUFYX0RFUFRIOiAyXG59O1xuXG4vLyBzcmMvZW51bXMvRWRnZURldGVjdGlvbk1vZGUuanNcbnZhciBFZGdlRGV0ZWN0aW9uTW9kZSA9IHtcbiAgREVQVEg6IDAsXG4gIExVTUE6IDEsXG4gIENPTE9SOiAyXG59O1xuXG4vLyBzcmMvZW51bXMvRWZmZWN0QXR0cmlidXRlLmpzXG52YXIgRWZmZWN0QXR0cmlidXRlID0ge1xuICBOT05FOiAwLFxuICBERVBUSDogMSxcbiAgQ09OVk9MVVRJT046IDJcbn07XG5cbi8vIHNyYy9lbnVtcy9FZmZlY3RTaGFkZXJTZWN0aW9uLmpzXG52YXIgRWZmZWN0U2hhZGVyU2VjdGlvbiA9IHtcbiAgRlJBR01FTlRfSEVBRDogXCJGUkFHTUVOVF9IRUFEXCIsXG4gIEZSQUdNRU5UX01BSU5fVVY6IFwiRlJBR01FTlRfTUFJTl9VVlwiLFxuICBGUkFHTUVOVF9NQUlOX0lNQUdFOiBcIkZSQUdNRU5UX01BSU5fSU1BR0VcIixcbiAgVkVSVEVYX0hFQUQ6IFwiVkVSVEVYX0hFQURcIixcbiAgVkVSVEVYX01BSU5fU1VQUE9SVDogXCJWRVJURVhfTUFJTl9TVVBQT1JUXCJcbn07XG5cbi8vIHNyYy9lbnVtcy9HbGl0Y2hNb2RlLmpzXG52YXIgR2xpdGNoTW9kZSA9IHtcbiAgRElTQUJMRUQ6IDAsXG4gIFNQT1JBRElDOiAxLFxuICBDT05TVEFOVF9NSUxEOiAyLFxuICBDT05TVEFOVF9XSUxEOiAzXG59O1xuXG4vLyBzcmMvZW51bXMvS2VybmVsU2l6ZS5qc1xudmFyIEtlcm5lbFNpemUgPSB7XG4gIFZFUllfU01BTEw6IDAsXG4gIFNNQUxMOiAxLFxuICBNRURJVU06IDIsXG4gIExBUkdFOiAzLFxuICBWRVJZX0xBUkdFOiA0LFxuICBIVUdFOiA1XG59O1xuXG4vLyBzcmMvZW51bXMvTFVUT3BlcmF0aW9uLmpzXG52YXIgTFVUT3BlcmF0aW9uID0ge1xuICBTQ0FMRV9VUDogXCJsdXQuc2NhbGV1cFwiXG59O1xuXG4vLyBzcmMvZW51bXMvTWFza0Z1bmN0aW9uLmpzXG52YXIgTWFza0Z1bmN0aW9uID0ge1xuICBESVNDQVJEOiAwLFxuICBNVUxUSVBMWTogMSxcbiAgTVVMVElQTFlfUkdCX1NFVF9BTFBIQTogMixcbiAgTVVMVElQTFlfUkdCOiAzXG59O1xuXG4vLyBzcmMvZW51bXMvUHJlZGljYXRpb25Nb2RlLmpzXG52YXIgUHJlZGljYXRpb25Nb2RlID0ge1xuICBESVNBQkxFRDogMCxcbiAgREVQVEg6IDEsXG4gIENVU1RPTTogMlxufTtcblxuLy8gc3JjL2VudW1zL1NNQUFQcmVzZXQuanNcbnZhciBTTUFBUHJlc2V0ID0ge1xuICBMT1c6IDAsXG4gIE1FRElVTTogMSxcbiAgSElHSDogMixcbiAgVUxUUkE6IDNcbn07XG5cbi8vIHNyYy9lbnVtcy9Ub25lTWFwcGluZ01vZGUuanNcbnZhciBUb25lTWFwcGluZ01vZGUgPSB7XG4gIFJFSU5IQVJEOiAwLFxuICBSRUlOSEFSRDI6IDEsXG4gIFJFSU5IQVJEMl9BREFQVElWRTogMixcbiAgT1BUSU1JWkVEX0NJTkVPTjogMyxcbiAgQUNFU19GSUxNSUM6IDQsXG4gIFVOQ0hBUlRFRDI6IDVcbn07XG5cbi8vIHNyYy9lbnVtcy9WaWduZXR0ZVRlY2huaXF1ZS5qc1xudmFyIFZpZ25ldHRlVGVjaG5pcXVlID0ge1xuICBERUZBVUxUOiAwLFxuICBFU0tJTDogMVxufTtcblxuLy8gc3JjL2VudW1zL1dlYkdMRXh0ZW5zaW9uLmpzXG52YXIgV2ViR0xFeHRlbnNpb24gPSB7XG4gIERFUklWQVRJVkVTOiBcImRlcml2YXRpdmVzXCIsXG4gIEZSQUdfREVQVEg6IFwiZnJhZ0RlcHRoXCIsXG4gIERSQVdfQlVGRkVSUzogXCJkcmF3QnVmZmVyc1wiLFxuICBTSEFERVJfVEVYVFVSRV9MT0Q6IFwic2hhZGVyVGV4dHVyZUxPRFwiXG59O1xuXG4vLyBzcmMvdXRpbHMvQmFja0NvbXBhdC5qc1xudmFyIHJldmlzaW9uID0gTnVtYmVyKFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgXCJcIikpO1xudmFyIHVzZUNvbG9yU3BhY2UgPSByZXZpc2lvbiA+PSAxNTI7XG52YXIgZW5jb2RpbmdUb0NvbG9yU3BhY2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtMaW5lYXJFbmNvZGluZywgTGluZWFyU1JHQkNvbG9yU3BhY2VdLFxuICBbc1JHQkVuY29kaW5nLCBTUkdCQ29sb3JTcGFjZV1cbl0pO1xudmFyIGNvbG9yU3BhY2VUb0VuY29kaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbTGluZWFyU1JHQkNvbG9yU3BhY2UsIExpbmVhckVuY29kaW5nXSxcbiAgW1NSR0JDb2xvclNwYWNlLCBzUkdCRW5jb2RpbmddXG5dKTtcbmZ1bmN0aW9uIGdldE91dHB1dENvbG9yU3BhY2UocmVuZGVyZXIpIHtcbiAgcmV0dXJuIHJlbmRlcmVyID09PSBudWxsID8gbnVsbCA6IHVzZUNvbG9yU3BhY2UgPyByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlIDogZW5jb2RpbmdUb0NvbG9yU3BhY2UuZ2V0KHJlbmRlcmVyLm91dHB1dEVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIHNldFRleHR1cmVDb2xvclNwYWNlKHRleHR1cmUsIGNvbG9yU3BhY2UpIHtcbiAgaWYgKHRleHR1cmUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHVzZUNvbG9yU3BhY2UpIHtcbiAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuICB9IGVsc2Uge1xuICAgIHRleHR1cmUuZW5jb2RpbmcgPSBjb2xvclNwYWNlVG9FbmNvZGluZy5nZXQoY29sb3JTcGFjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlUZXh0dXJlQ29sb3JTcGFjZShzcmMsIGRlc3QpIHtcbiAgaWYgKHNyYyA9PT0gbnVsbCB8fCBkZXN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh1c2VDb2xvclNwYWNlKSB7XG4gICAgZGVzdC5jb2xvclNwYWNlID0gc3JjLmNvbG9yU3BhY2U7XG4gIH0gZWxzZSB7XG4gICAgZGVzdC5lbmNvZGluZyA9IHNyYy5lbmNvZGluZztcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnRTaGFkZXIoZnJhZ21lbnRTaGFkZXIpIHtcbiAgaWYgKHJldmlzaW9uIDwgMTU0KSB7XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXCJjb2xvcnNwYWNlX2ZyYWdtZW50XCIsIFwiZW5jb2RpbmdzX2ZyYWdtZW50XCIpO1xuICB9XG4gIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbn1cblxuLy8gc3JjL3V0aWxzL29ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3Wi5qc1xuZnVuY3Rpb24gb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKGRlcHRoLCBuZWFyLCBmYXIpIHtcbiAgcmV0dXJuIGRlcHRoICogKG5lYXIgLSBmYXIpIC0gbmVhcjtcbn1cblxuLy8gc3JjL3V0aWxzL3ZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aC5qc1xuZnVuY3Rpb24gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLCBuZWFyLCBmYXIpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KCh2aWV3WiArIG5lYXIpIC8gKG5lYXIgLSBmYXIpLCAwKSwgMSk7XG59XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5ib3guZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2JveF9kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZW5kaWZcXG4jaWZkZWYgQklMQVRFUkFMXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxudW5pZm9ybSB2ZWMyIGNhbWVyYU5lYXJGYXI7XFxuI2lmZGVmIE5PUk1BTF9ERVBUSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIHRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix1dikuYTt9XFxuI2Vsc2VcXG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbmZsb2F0IGdldFZpZXdaKGNvbnN0IGluIGZsb2F0IGRlcHRoKXtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xcbiNlbHNlXFxucmV0dXJuIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZW5kaWZcXG59XFxuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxcbiNkZWZpbmUgbGluZWFyRGVwdGgodikgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKGdldFZpZXdaKHJlYWREZXB0aCh2KSksIGNhbWVyYU5lYXJGYXIueCwgY2FtZXJhTmVhckZhci55KVxcbiNlbHNlXFxuI2RlZmluZSBsaW5lYXJEZXB0aCh2KSByZWFkRGVwdGgodilcXG4jZW5kaWZcXG4jZW5kaWZcXG4jZGVmaW5lIGdldFRleGVsKHYpIHRleHR1cmUyRChpbnB1dEJ1ZmZlciwgdilcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMjt2YXJ5aW5nIHZlYzIgdlV2MDMsdlV2MDQsdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2LHZVdjA3LHZVdjA4O1xcbiNlbGlmIEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMix2VXYwMyx2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDUsdlV2MDYsdlV2MDcsdlV2MDgsdlV2MDk7dmFyeWluZyB2ZWMyIHZVdjEwLHZVdjExLHZVdjEyLHZVdjEzLHZVdjE0O3ZhcnlpbmcgdmVjMiB2VXYxNSx2VXYxNix2VXYxNyx2VXYxOCx2VXYxOTt2YXJ5aW5nIHZlYzIgdlV2MjAsdlV2MjEsdlV2MjIsdlV2MjMsdlV2MjQ7XFxuI2Vsc2VcXG51bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcXG52b2lkIG1haW4oKXtcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZlYzQgY1tdPXZlYzRbS0VSTkVMX1NJWkVfU1FdKGdldFRleGVsKHZVdjAwKSxnZXRUZXhlbCh2VXYwMSksZ2V0VGV4ZWwodlV2MDIpLGdldFRleGVsKHZVdjAzKSxnZXRUZXhlbCh2VXYwNCksZ2V0VGV4ZWwodlV2MDUpLGdldFRleGVsKHZVdjA2KSxnZXRUZXhlbCh2VXYwNyksZ2V0VGV4ZWwodlV2MDgpKTtcXG4jaWZkZWYgQklMQVRFUkFMXFxuZmxvYXQgeltdPWZsb2F0W0tFUk5FTF9TSVpFX1NRXShsaW5lYXJEZXB0aCh2VXYwMCksbGluZWFyRGVwdGgodlV2MDEpLGxpbmVhckRlcHRoKHZVdjAyKSxsaW5lYXJEZXB0aCh2VXYwMyksbGluZWFyRGVwdGgodlV2MDQpLGxpbmVhckRlcHRoKHZVdjA1KSxsaW5lYXJEZXB0aCh2VXYwNiksbGluZWFyRGVwdGgodlV2MDcpLGxpbmVhckRlcHRoKHZVdjA4KSk7XFxuI2VuZGlmXFxuI2VsaWYgS0VSTkVMX1NJWkUgPT0gNSAmJiBNQVhfVkFSWUlOR19WRUNUT1JTID49IDEzXFxudmVjNCBjW109dmVjNFtLRVJORUxfU0laRV9TUV0oZ2V0VGV4ZWwodlV2MDApLGdldFRleGVsKHZVdjAxKSxnZXRUZXhlbCh2VXYwMiksZ2V0VGV4ZWwodlV2MDMpLGdldFRleGVsKHZVdjA0KSxnZXRUZXhlbCh2VXYwNSksZ2V0VGV4ZWwodlV2MDYpLGdldFRleGVsKHZVdjA3KSxnZXRUZXhlbCh2VXYwOCksZ2V0VGV4ZWwodlV2MDkpLGdldFRleGVsKHZVdjEwKSxnZXRUZXhlbCh2VXYxMSksZ2V0VGV4ZWwodlV2MTIpLGdldFRleGVsKHZVdjEzKSxnZXRUZXhlbCh2VXYxNCksZ2V0VGV4ZWwodlV2MTUpLGdldFRleGVsKHZVdjE2KSxnZXRUZXhlbCh2VXYxNyksZ2V0VGV4ZWwodlV2MTgpLGdldFRleGVsKHZVdjE5KSxnZXRUZXhlbCh2VXYyMCksZ2V0VGV4ZWwodlV2MjEpLGdldFRleGVsKHZVdjIyKSxnZXRUZXhlbCh2VXYyMyksZ2V0VGV4ZWwodlV2MjQpKTtcXG4jaWZkZWYgQklMQVRFUkFMXFxuZmxvYXQgeltdPWZsb2F0W0tFUk5FTF9TSVpFX1NRXShsaW5lYXJEZXB0aCh2VXYwMCksbGluZWFyRGVwdGgodlV2MDEpLGxpbmVhckRlcHRoKHZVdjAyKSxsaW5lYXJEZXB0aCh2VXYwMyksbGluZWFyRGVwdGgodlV2MDQpLGxpbmVhckRlcHRoKHZVdjA1KSxsaW5lYXJEZXB0aCh2VXYwNiksbGluZWFyRGVwdGgodlV2MDcpLGxpbmVhckRlcHRoKHZVdjA4KSxsaW5lYXJEZXB0aCh2VXYwOSksbGluZWFyRGVwdGgodlV2MTApLGxpbmVhckRlcHRoKHZVdjExKSxsaW5lYXJEZXB0aCh2VXYxMiksbGluZWFyRGVwdGgodlV2MTMpLGxpbmVhckRlcHRoKHZVdjE0KSxsaW5lYXJEZXB0aCh2VXYxNSksbGluZWFyRGVwdGgodlV2MTYpLGxpbmVhckRlcHRoKHZVdjE3KSxsaW5lYXJEZXB0aCh2VXYxOCksbGluZWFyRGVwdGgodlV2MTkpLGxpbmVhckRlcHRoKHZVdjIwKSxsaW5lYXJEZXB0aCh2VXYyMSksbGluZWFyRGVwdGgodlV2MjIpLGxpbmVhckRlcHRoKHZVdjIzKSxsaW5lYXJEZXB0aCh2VXYyNCkpO1xcbiNlbmRpZlxcbiNlbmRpZlxcbnZlYzQgcmVzdWx0PXZlYzQoMC4wKTtcXG4jaWZkZWYgQklMQVRFUkFMXFxuZmxvYXQgdz0wLjA7XFxuI2lmIEtFUk5FTF9TSVpFID09IDMgfHwgKEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxMylcXG5mbG9hdCBjZW50ZXJEZXB0aD16W0tFUk5FTF9TSVpFX1NRX0hBTEZdO2ZvcihpbnQgaT0wO2k8S0VSTkVMX1NJWkVfU1E7KytpKXtmbG9hdCBkPXN0ZXAoYWJzKHpbaV0tY2VudGVyRGVwdGgpLERJU1RBTkNFX1RIUkVTSE9MRCk7cmVzdWx0Kz1jW2ldKmQ7dys9ZDt9XFxuI2Vsc2VcXG5mbG9hdCBjZW50ZXJEZXB0aD1saW5lYXJEZXB0aCh2VXYpO3ZlYzIgcz10ZXhlbFNpemUqc2NhbGU7Zm9yKGludCB4PS1LRVJORUxfU0laRV9IQUxGO3g8PUtFUk5FTF9TSVpFX0hBTEY7Kyt4KXtmb3IoaW50IHk9LUtFUk5FTF9TSVpFX0hBTEY7eTw9S0VSTkVMX1NJWkVfSEFMRjsrK3kpe3ZlYzIgY29vcmRzPXZVdit2ZWMyKHgseSkqczt2ZWM0IGM9Z2V0VGV4ZWwoY29vcmRzKTtmbG9hdCB6PSh4PT0wJiZ5PT0wKT9jZW50ZXJEZXB0aDpsaW5lYXJEZXB0aChjb29yZHMpO2Zsb2F0IGQ9c3RlcChhYnMoei1jZW50ZXJEZXB0aCksRElTVEFOQ0VfVEhSRVNIT0xEKTtyZXN1bHQrPWMqZDt3Kz1kO319XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yPXJlc3VsdC9tYXgodywxLjApO1xcbiNlbHNlXFxuI2lmIEtFUk5FTF9TSVpFID09IDMgfHwgKEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxMylcXG5mb3IoaW50IGk9MDtpPEtFUk5FTF9TSVpFX1NROysraSl7cmVzdWx0Kz1jW2ldO31cXG4jZWxzZVxcbnZlYzIgcz10ZXhlbFNpemUqc2NhbGU7Zm9yKGludCB4PS1LRVJORUxfU0laRV9IQUxGO3g8PUtFUk5FTF9TSVpFX0hBTEY7Kyt4KXtmb3IoaW50IHk9LUtFUk5FTF9TSVpFX0hBTEY7eTw9S0VSTkVMX1NJWkVfSEFMRjsrK3kpe3Jlc3VsdCs9Z2V0VGV4ZWwodXYrdmVjMih4LHkpKnMpO319XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yPXJlc3VsdCpJTlZfS0VSTkVMX1NJWkVfU1E7XFxuI2VuZGlmXFxufVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uYm94LnZlcnRcbnZhciBjb252b2x1dGlvbl9ib3hfZGVmYXVsdDIgPSBcInVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBzY2FsZTtcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMjt2YXJ5aW5nIHZlYzIgdlV2MDMsdlV2MDQsdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2LHZVdjA3LHZVdjA4O1xcbiNlbGlmIEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMix2VXYwMyx2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDUsdlV2MDYsdlV2MDcsdlV2MDgsdlV2MDk7dmFyeWluZyB2ZWMyIHZVdjEwLHZVdjExLHZVdjEyLHZVdjEzLHZVdjE0O3ZhcnlpbmcgdmVjMiB2VXYxNSx2VXYxNix2VXYxNyx2VXYxOCx2VXYxOTt2YXJ5aW5nIHZlYzIgdlV2MjAsdlV2MjEsdlV2MjIsdlV2MjMsdlV2MjQ7XFxuI2Vsc2VcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTtcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZlYzIgcz10ZXhlbFNpemUqc2NhbGU7dlV2MDA9dXYrcyp2ZWMyKC0xLjAsLTEuMCk7dlV2MDE9dXYrcyp2ZWMyKDAuMCwtMS4wKTt2VXYwMj11ditzKnZlYzIoMS4wLC0xLjApO3ZVdjAzPXV2K3MqdmVjMigtMS4wLDAuMCk7dlV2MDQ9dXY7dlV2MDU9dXYrcyp2ZWMyKDEuMCwwLjApO3ZVdjA2PXV2K3MqdmVjMigtMS4wLDEuMCk7dlV2MDc9dXYrcyp2ZWMyKDAuMCwxLjApO3ZVdjA4PXV2K3MqdmVjMigxLjAsMS4wKTtcXG4jZWxpZiBLRVJORUxfU0laRSA9PSA1XFxudmVjMiBzPXRleGVsU2l6ZSpzY2FsZTt2VXYwMD11ditzKnZlYzIoLTIuMCwtMi4wKTt2VXYwMT11ditzKnZlYzIoLTEuMCwtMi4wKTt2VXYwMj11ditzKnZlYzIoMC4wLC0yLjApO3ZVdjAzPXV2K3MqdmVjMigxLjAsLTIuMCk7dlV2MDQ9dXYrcyp2ZWMyKDIuMCwtMi4wKTt2VXYwNT11ditzKnZlYzIoLTIuMCwtMS4wKTt2VXYwNj11ditzKnZlYzIoLTEuMCwtMS4wKTt2VXYwNz11ditzKnZlYzIoMC4wLC0xLjApO3ZVdjA4PXV2K3MqdmVjMigxLjAsLTEuMCk7dlV2MDk9dXYrcyp2ZWMyKDIuMCwtMS4wKTt2VXYxMD11ditzKnZlYzIoLTIuMCwwLjApO3ZVdjExPXV2K3MqdmVjMigtMS4wLDAuMCk7dlV2MTI9dXY7dlV2MTM9dXYrcyp2ZWMyKDEuMCwwLjApO3ZVdjE0PXV2K3MqdmVjMigyLjAsMC4wKTt2VXYxNT11ditzKnZlYzIoLTIuMCwxLjApO3ZVdjE2PXV2K3MqdmVjMigtMS4wLDEuMCk7dlV2MTc9dXYrcyp2ZWMyKDAuMCwxLjApO3ZVdjE4PXV2K3MqdmVjMigxLjAsMS4wKTt2VXYxOT11ditzKnZlYzIoMi4wLDEuMCk7dlV2MjA9dXYrcyp2ZWMyKC0yLjAsMi4wKTt2VXYyMT11ditzKnZlYzIoLTEuMCwyLjApO3ZVdjIyPXV2K3MqdmVjMigwLjAsMi4wKTt2VXYyMz11ditzKnZlYzIoMS4wLDIuMCk7dlV2MjQ9dXYrcyp2ZWMyKDIuMCwyLjApO1xcbiNlbHNlXFxudlV2PXV2O1xcbiNlbmRpZlxcbmdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0JveEJsdXJNYXRlcmlhbC5qc1xudmFyIEJveEJsdXJNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYm94IGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpbGF0ZXJhbD1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIGJpbGF0ZXJhbCBibHVycmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9NV0gLSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJpbGF0ZXJhbCA9IGZhbHNlLCBrZXJuZWxTaXplID0gNSB9ID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkJveEJsdXJNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgRElTVEFOQ0VfVEhSRVNIT0xEOiBcIjAuMVwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMyhudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMyhudWxsKSxcbiAgICAgICAgbm9ybWFsRGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMyhudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTMobmV3IFZlY3RvcjIyKCkpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTMobmV3IFZlY3RvcjIyKCkpLFxuICAgICAgICBzY2FsZTogbmV3IFVuaWZvcm0zKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmczLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fYm94X2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2JveF9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuYmlsYXRlcmFsID0gYmlsYXRlcmFsO1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gICAgdGhpcy5tYXhWYXJ5aW5nVmVjdG9ycyA9IDg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB2YXJ5aW5nIHZlY3RvcnMuXG4gICAqXG4gICAqIFNob3VsZCBiZSBzeW5jZWQgd2l0aCBgcmVuZGVyZXIuY2FwYWJpbGl0aWVzLm1heFZhcnlpbmdzYC4gRGVmYXVsdCBpcyA4LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IG1heFZhcnlpbmdWZWN0b3JzKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIC0gTXVzdCBiZSBhbiBvZGQgbnVtYmVyXG4gICAqIC0gS2VybmVsIHNpemUgMyBhbmQgNSB1c2Ugb3B0aW1pemVkIGNvZGUgcGF0aHNcbiAgICogLSBEZWZhdWx0IGlzIDVcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLktFUk5FTF9TSVpFKTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAlIDIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBrZXJuZWwgc2l6ZSBtdXN0IGJlIGFuIG9kZCBudW1iZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVmaW5lcy5LRVJORUxfU0laRSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLktFUk5FTF9TSVpFX0hBTEYgPSBNYXRoLmZsb29yKHZhbHVlIC8gMikudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkVfU1EgPSAodmFsdWUgKiogMikudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkVfU1FfSEFMRiA9IE1hdGguZmxvb3IodmFsdWUgKiogMiAvIDIpLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLklOVl9LRVJORUxfU0laRV9TUSA9ICgxIC8gdmFsdWUgKiogMikudG9GaXhlZCg2KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBuZWFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgbmVhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGZhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGZhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQSBjb21iaW5lZCBub3JtYWwtZGVwdGggYnVmZmVyLiBPdmVycmlkZXMge0BsaW5rIGRlcHRoQnVmZmVyfSBpZiBzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG5vcm1hbERlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub3JtYWxEZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGJpbGF0ZXJhbCBmaWx0ZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgYmlsYXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuQklMQVRFUkFMICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGJpbGF0ZXJhbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkJJTEFURVJBTCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkJJTEFURVJBTDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiaWxhdGVyYWwgZmlsdGVyIGRpc3RhbmNlIHRocmVzaG9sZCBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZERpc3RhbmNlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiAtb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKE51bWJlcih0aGlzLmRlZmluZXMuRElTVEFOQ0VfVEhSRVNIT0xEKSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLXZhbHVlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgICB0aGlzLmRlZmluZXMuRElTVEFOQ0VfVEhSRVNIT0xEID0gdGhyZXNob2xkLnRvRml4ZWQoMTIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUuc2V0KGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0NpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nLCBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc0LCBQZXJzcGVjdGl2ZUNhbWVyYSBhcyBQZXJzcGVjdGl2ZUNhbWVyYTIsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsNCwgVW5pZm9ybSBhcyBVbmlmb3JtNCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY2lyY2xlLW9mLWNvbmZ1c2lvbi5mcmFnXG52YXIgY2lyY2xlX29mX2NvbmZ1c2lvbl9kZWZhdWx0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IGZvY3VzRGlzdGFuY2U7dW5pZm9ybSBmbG9hdCBmb2N1c1JhbmdlO3VuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjt1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjt2YXJ5aW5nIHZlYzIgdlV2O2Zsb2F0IHJlYWREZXB0aChjb25zdCBpbiB2ZWMyIHV2KXtcXG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuZmxvYXQgZGVwdGg9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XFxuI2Vsc2VcXG5mbG9hdCBkZXB0aD10ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxuI2lmZGVmIExPR19ERVBUSFxcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aCpsb2cyKGNhbWVyYUZhcisxLjApKS0xLjA7ZmxvYXQgYT1jYW1lcmFGYXIvKGNhbWVyYUZhci1jYW1lcmFOZWFyKTtmbG9hdCBiPWNhbWVyYUZhcipjYW1lcmFOZWFyLyhjYW1lcmFOZWFyLWNhbWVyYUZhcik7ZGVwdGg9YStiL2Q7XFxuI2VuZGlmXFxucmV0dXJuIGRlcHRoO312b2lkIG1haW4oKXtmbG9hdCBkZXB0aD1yZWFkRGVwdGgodlV2KTtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxuZmxvYXQgdmlld1o9cGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhcixjYW1lcmFGYXIpO2Zsb2F0IGxpbmVhckRlcHRoPXZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WixjYW1lcmFOZWFyLGNhbWVyYUZhcik7XFxuI2Vsc2VcXG5mbG9hdCBsaW5lYXJEZXB0aD1kZXB0aDtcXG4jZW5kaWZcXG5mbG9hdCBzaWduZWREaXN0YW5jZT1saW5lYXJEZXB0aC1mb2N1c0Rpc3RhbmNlO2Zsb2F0IG1hZ25pdHVkZT1zbW9vdGhzdGVwKDAuMCxmb2N1c1JhbmdlLGFicyhzaWduZWREaXN0YW5jZSkpO2dsX0ZyYWdDb2xvci5yZz1tYWduaXR1ZGUqdmVjMihzdGVwKHNpZ25lZERpc3RhbmNlLDAuMCksc3RlcCgwLjAsc2lnbmVkRGlzdGFuY2UpKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQ2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbC5qc1xudmFyIENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvQyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtNChudWxsKSxcbiAgICAgICAgZm9jdXNEaXN0YW5jZTogbmV3IFVuaWZvcm00KDApLFxuICAgICAgICBmb2N1c1JhbmdlOiBuZXcgVW5pZm9ybTQoMCksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtNCgwLjMpLFxuICAgICAgICBjYW1lcmFGYXI6IG5ldyBVbmlmb3JtNCgxZTMpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc0LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY2lyY2xlX29mX2NvbmZ1c2lvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMuZm9jYWxMZW5ndGggPSB0aGlzLnVuaWZvcm1zLmZvY3VzUmFuZ2U7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbmVhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IG5lYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhci52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZmFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZmFyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZykge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c0Rpc3RhbmNlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c0Rpc3RhbmNlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY3VzIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9jdXNEaXN0YW5jZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIGdldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZm9jdXMgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c0Rpc3RhbmNlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIHNldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBmb2N1c1JhbmdlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZvY2FsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzUmFuZ2U7XG4gIH1cbiAgc2V0IGZvY2FsTGVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzUmFuZ2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c1JhbmdlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZvY3VzUmFuZ2UgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZm9jYWwgbGVuZ3RoLlxuICAgKi9cbiAgZ2V0Rm9jYWxMZW5ndGgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c1JhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmb2NhbCBsZW5ndGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c1JhbmdlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2NhbCBsZW5ndGguXG4gICAqL1xuICBzZXRGb2NhbExlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuZm9jdXNSYW5nZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTIpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvS2F3YXNlQmx1ck1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc1LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDUsIFVuaWZvcm0gYXMgVW5pZm9ybTUsIFZlY3RvcjQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmthd2FzZS5mcmFnXG52YXIgY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQgPSBcIiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzQgc3VtPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYxKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYzKTtnbF9GcmFnQ29sb3I9c3VtKjAuMjU7XFxuI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxufVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24ua2F3YXNlLnZlcnRcbnZhciBjb252b2x1dGlvbl9rYXdhc2VfZGVmYXVsdDIgPSBcInVuaWZvcm0gdmVjNCB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBrZXJuZWw7dW5pZm9ybSBmbG9hdCBzY2FsZTt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2b2lkIG1haW4oKXt2ZWMyIHV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dmVjMiBkVXY9KHRleGVsU2l6ZS54eSp2ZWMyKGtlcm5lbCkrdGV4ZWxTaXplLnp3KSpzY2FsZTt2VXYwPXZlYzIodXYueC1kVXYueCx1di55K2RVdi55KTt2VXYxPXZlYzIodXYueCtkVXYueCx1di55K2RVdi55KTt2VXYyPXZlYzIodXYueCtkVXYueCx1di55LWRVdi55KTt2VXYzPXZlYzIodXYueC1kVXYueCx1di55LWRVdi55KTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9LYXdhc2VCbHVyTWF0ZXJpYWwuanNcbnZhciBrZXJuZWxQcmVzZXRzID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDFdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMl0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAyLCAyLCAzXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDIsIDMsIDQsIDQsIDVdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMiwgMywgNCwgNSwgNywgOCwgOSwgMTBdKVxuXTtcbnZhciBLYXdhc2VCbHVyTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnZvbHV0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSB0ZXhlbFNpemUgcGFyYW0uXG4gICAqIEBwYXJhbSB7VmVjdG9yNH0gW3RleGVsU2l6ZV0gLSBEZXByZWNhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjQoKSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiS2F3YXNlQmx1ck1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm01KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNShuZXcgVmVjdG9yNCgpKSxcbiAgICAgICAgc2NhbGU6IG5ldyBVbmlmb3JtNSgxKSxcbiAgICAgICAga2VybmVsOiBuZXcgVW5pZm9ybTUoMClcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzUsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjb252b2x1dGlvbl9rYXdhc2VfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMuc2V0VGV4ZWxTaXplKHRleGVsU2l6ZS54LCB0ZXhlbFNpemUueSk7XG4gICAgdGhpcy5rZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5pbnB1dEJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNlcXVlbmNlIGZvciB0aGUgY3VycmVudCBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0Zsb2F0MzJBcnJheX1cbiAgICovXG4gIGdldCBrZXJuZWxTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4ga2VybmVsUHJlc2V0c1t0aGlzLmtlcm5lbFNpemVdO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXJuZWwuXG4gICAqXG4gICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gVGhlIGtlcm5lbC5cbiAgICogQGRlcHJlY2F0ZWQgSW1wbGVtZW50YXRpb24gZGV0YWlsLCByZW1vdmVkIHdpdGggbm8gcmVwbGFjZW1lbnQuXG4gICAqL1xuICBnZXRLZXJuZWwoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGtlcm5lbC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBrZXJuZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMua2VybmVsLnZhbHVlO1xuICB9XG4gIHNldCBrZXJuZWwodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmtlcm5lbC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGtlcm5lbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGtlcm5lbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUga2VybmVsLlxuICAgKi9cbiAgc2V0S2VybmVsKHZhbHVlKSB7XG4gICAgdGhpcy5rZXJuZWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSwgeCAqIDAuNSwgeSAqIDAuNSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB4ID0gMSAvIHdpZHRoLCB5ID0gMSAvIGhlaWdodDtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSwgeCAqIDAuNSwgeSAqIDAuNSk7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvQ29weU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc2LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDYsIFVuaWZvcm0gYXMgVW5pZm9ybTYgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvcHkuZnJhZ1xudmFyIGNvcHlfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9b3BhY2l0eSp0ZXhlbDtcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9Db3B5TWF0ZXJpYWwuanNcbnZhciBDb3B5TWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvcHkgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkNvcHlNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNihudWxsKSxcbiAgICAgICAgb3BhY2l0eTogbmV3IFVuaWZvcm02KDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc2LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29weV9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB1cGRhdGVGcmFnbWVudFNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9wYWNpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIGdldE9wYWNpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGFjaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3BhY2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIHNldE9wYWNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aENvbXBhcmlzb25NYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nNywgUGVyc3BlY3RpdmVDYW1lcmEgYXMgUGVyc3BlY3RpdmVDYW1lcmEzLCBSR0JBRGVwdGhQYWNraW5nLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDcsIFVuaWZvcm0gYXMgVW5pZm9ybTcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWNvbXBhcmlzb24uZnJhZ1xudmFyIGRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdCA9IFwiI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7Y2VudHJvaWQgdmFyeWluZyBmbG9hdCB2Vmlld1o7Y2VudHJvaWQgdmFyeWluZyB2ZWM0IHZQcm9qVGV4Q29vcmQ7dm9pZCBtYWluKCl7XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG52ZWMyIHByb2pUZXhDb29yZD0odlByb2pUZXhDb29yZC54eS92UHJvalRleENvb3JkLncpKjAuNSswLjU7cHJvalRleENvb3JkPWNsYW1wKHByb2pUZXhDb29yZCwwLjAwMiwwLjk5OCk7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbmZsb2F0IGZyYWdDb29yZFo9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHByb2pUZXhDb29yZCkpO1xcbiNlbHNlXFxuZmxvYXQgZnJhZ0Nvb3JkWj10ZXh0dXJlMkQoZGVwdGhCdWZmZXIscHJvalRleENvb3JkKS5yO1xcbiNlbmRpZlxcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihmcmFnQ29vcmRaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZWxzZVxcbmZsb2F0IHZpZXdaPW9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihmcmFnQ29vcmRaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZW5kaWZcXG5mbG9hdCBkZXB0aFRlc3Q9KC12Vmlld1o+LXZpZXdaKT8xLjA6MC4wO2dsX0ZyYWdDb2xvci5yZz12ZWMyKDAuMCxkZXB0aFRlc3QpO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWNvbXBhcmlzb24udmVydFxudmFyIGRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdDIgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZhcnlpbmcgZmxvYXQgdlZpZXdaO3ZhcnlpbmcgdmVjNCB2UHJvalRleENvb3JkO3ZvaWQgbWFpbigpe1xcbiNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcbnZWaWV3Wj1tdlBvc2l0aW9uLno7dlByb2pUZXhDb29yZD1nbF9Qb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhDb21wYXJpc29uTWF0ZXJpYWwuanNcbnZhciBEZXB0aENvbXBhcmlzb25NYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw3IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggY29tcGFyaXNvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbZGVwdGhUZXh0dXJlPW51bGxdIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVwdGhUZXh0dXJlID0gbnVsbCwgY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEZXB0aENvbXBhcmlzb25NYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTcobnVsbCksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtNygwLjMpLFxuICAgICAgICBjYW1lcmFGYXI6IG5ldyBVbmlmb3JtNygxZTMpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc3LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfY29tcGFyaXNvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aF9jb21wYXJpc29uX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmc7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPVJHQkFEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmcpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTMpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhDb3B5TWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMiwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nOCwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWw4LCBVbmlmb3JtIGFzIFVuaWZvcm04LCBWZWN0b3IyIGFzIFZlY3RvcjIzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1jb3B5LmZyYWdcbnZhciBkZXB0aF9jb3B5X2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxwYWNraW5nPlxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuI2lmZGVmIE5PUk1BTF9ERVBUSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIHRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix1dikuYTt9XFxuI2Vsc2VcXG4jaWYgSU5QVVRfREVQVEhfUEFDS0lORyA9PSAzMjAxXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmIElOUFVUX0RFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbnZvaWQgbWFpbigpe1xcbiNpZiBJTlBVVF9ERVBUSF9QQUNLSU5HID09IE9VVFBVVF9ERVBUSF9QQUNLSU5HXFxuZ2xfRnJhZ0NvbG9yPXRleHR1cmUyRChkZXB0aEJ1ZmZlcix2VXYpO1xcbiNlbHNlXFxuZmxvYXQgZGVwdGg9cmVhZERlcHRoKHZVdik7XFxuI2lmIE9VVFBVVF9ERVBUSF9QQUNLSU5HID09IDMyMDFcXG5nbF9GcmFnQ29sb3I9KGRlcHRoPT0xLjApP3ZlYzQoMS4wKTpwYWNrRGVwdGhUb1JHQkEoZGVwdGgpO1xcbiNlbHNlXFxuZ2xfRnJhZ0NvbG9yPXZlYzQodmVjMyhkZXB0aCksMS4wKTtcXG4jZW5kaWZcXG4jZW5kaWZcXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1jb3B5LnZlcnRcbnZhciBkZXB0aF9jb3B5X2RlZmF1bHQyID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcbiNpZiBERVBUSF9DT1BZX01PREUgPT0gMVxcbnVuaWZvcm0gdmVjMiB0ZXhlbFBvc2l0aW9uO1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpe1xcbiNpZiBERVBUSF9DT1BZX01PREUgPT0gMVxcbnZVdj10ZXhlbFBvc2l0aW9uO1xcbiNlbHNlXFxudlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7XFxuI2VuZGlmXFxuZ2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhDb3B5TWF0ZXJpYWwuanNcbnZhciBEZXB0aENvcHlNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw4IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggY29weSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRGVwdGhDb3B5TWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgSU5QVVRfREVQVEhfUEFDS0lORzogXCIwXCIsXG4gICAgICAgIE9VVFBVVF9ERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgREVQVEhfQ09QWV9NT0RFOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTgobnVsbCksXG4gICAgICAgIHRleGVsUG9zaXRpb246IG5ldyBVbmlmb3JtOChuZXcgVmVjdG9yMjMoKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzgsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aF9jb3B5X2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoX2NvcHlfZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLmRlcHRoQ29weU1vZGUgPSBEZXB0aENvcHlNb2RlLkZVTEw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGRlcHRoQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlO1xuICB9XG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGlucHV0RGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLklOUFVUX0RFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgZ2V0IG91dHB1dERlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyk7XG4gIH1cbiAgc2V0IG91dHB1dERlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBpbnB1dERlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMikge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5pbnB1dERlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcmV0dXJuIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBUaGUgaW5wdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIGdldElucHV0RGVwdGhQYWNraW5nKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLklOUFVUX0RFUFRIX1BBQ0tJTkcpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXREZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSB2YWx1ZSAtIFRoZSBuZXcgaW5wdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldElucHV0RGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLklOUFVUX0RFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3V0cHV0RGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFRoZSBvdXRwdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIGdldE91dHB1dERlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3V0cHV0RGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gdmFsdWUgLSBUaGUgbmV3IG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0T3V0cHV0RGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk9VVFBVVF9ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjcmVlbiBzcGFjZSBwb3NpdGlvbiB1c2VkIGZvciBzaW5nbGUtdGV4ZWwgY29weSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCB0ZXhlbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRleGVsUG9zaXRpb24udmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcmVlbiBzcGFjZSBwb3NpdGlvbiB1c2VkIGZvciBzaW5nbGUtdGV4ZWwgY29weSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4ZWxQb3NpdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfSBUaGUgcG9zaXRpb24uXG4gICAqL1xuICBnZXRUZXhlbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRleGVsUG9zaXRpb24udmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjcmVlbiBzcGFjZSBwb3NpdGlvbiB1c2VkIGZvciBzaW5nbGUtdGV4ZWwgY29weSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZhbHVlIC0gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgc2V0VGV4ZWxQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxQb3NpdGlvbi52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggY29weSBtb2RlLlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhDb3B5TW9kZX1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmRlcHRoQ29weU1vZGU7XG4gIH1cbiAgc2V0IG1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmRlcHRoQ29weU1vZGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfQ09QWV9NT0RFID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVwdGggY29weSBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtEZXB0aENvcHlNb2RlfSBUaGUgZGVwdGggY29weSBtb2RlLlxuICAgKi9cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBjb3B5IG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhDb3B5TW9kZX0gdmFsdWUgLSBUaGUgbmV3IG1vZGUuXG4gICAqL1xuICBzZXRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5tb2RlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmczLCBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc5LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDksIFVuaWZvcm0gYXMgVW5pZm9ybTksIFZlY3RvcjIgYXMgVmVjdG9yMjQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWRvd25zYW1wbGluZy5mcmFnXG52YXIgZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG4jaWZkZWYgRE9XTlNBTVBMRV9OT1JNQUxTXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBub3JtYWxCdWZmZXI7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7ZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XFxuI2Vsc2VcXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xcbiNlbmRpZlxcbn1pbnQgZmluZEJlc3REZXB0aChjb25zdCBpbiBmbG9hdCBzYW1wbGVzWzRdKXtmbG9hdCBjPShzYW1wbGVzWzBdK3NhbXBsZXNbMV0rc2FtcGxlc1syXStzYW1wbGVzWzNdKSowLjI1O2Zsb2F0IGRpc3RhbmNlc1s0XTtkaXN0YW5jZXNbMF09YWJzKGMtc2FtcGxlc1swXSk7ZGlzdGFuY2VzWzFdPWFicyhjLXNhbXBsZXNbMV0pO2Rpc3RhbmNlc1syXT1hYnMoYy1zYW1wbGVzWzJdKTtkaXN0YW5jZXNbM109YWJzKGMtc2FtcGxlc1szXSk7ZmxvYXQgbWF4RGlzdGFuY2U9bWF4KG1heChkaXN0YW5jZXNbMF0sZGlzdGFuY2VzWzFdKSxtYXgoZGlzdGFuY2VzWzJdLGRpc3RhbmNlc1szXSkpO2ludCByZW1haW5pbmdbM107aW50IHJlamVjdGVkWzNdO2ludCBpLGosaztmb3IoaT0wLGo9MCxrPTA7aTw0OysraSl7aWYoZGlzdGFuY2VzW2ldPG1heERpc3RhbmNlKXtyZW1haW5pbmdbaisrXT1pO31lbHNle3JlamVjdGVkW2srK109aTt9fWZvcig7ajwzOysrail7cmVtYWluaW5nW2pdPXJlamVjdGVkWy0ta107fXZlYzMgcz12ZWMzKHNhbXBsZXNbcmVtYWluaW5nWzBdXSxzYW1wbGVzW3JlbWFpbmluZ1sxXV0sc2FtcGxlc1tyZW1haW5pbmdbMl1dKTtjPShzLngrcy55K3MueikvMy4wO2Rpc3RhbmNlc1swXT1hYnMoYy1zLngpO2Rpc3RhbmNlc1sxXT1hYnMoYy1zLnkpO2Rpc3RhbmNlc1syXT1hYnMoYy1zLnopO2Zsb2F0IG1pbkRpc3RhbmNlPW1pbihkaXN0YW5jZXNbMF0sbWluKGRpc3RhbmNlc1sxXSxkaXN0YW5jZXNbMl0pKTtmb3IoaT0wO2k8MzsrK2kpe2lmKGRpc3RhbmNlc1tpXT09bWluRGlzdGFuY2Upe2JyZWFrO319cmV0dXJuIHJlbWFpbmluZ1tpXTt9dm9pZCBtYWluKCl7ZmxvYXQgZFs0XTtkWzBdPXJlYWREZXB0aCh2VXYwKTtkWzFdPXJlYWREZXB0aCh2VXYxKTtkWzJdPXJlYWREZXB0aCh2VXYyKTtkWzNdPXJlYWREZXB0aCh2VXYzKTtpbnQgaW5kZXg9ZmluZEJlc3REZXB0aChkKTtcXG4jaWZkZWYgRE9XTlNBTVBMRV9OT1JNQUxTXFxudmVjMyBuWzRdO25bMF09dGV4dHVyZTJEKG5vcm1hbEJ1ZmZlcix2VXYwKS5yZ2I7blsxXT10ZXh0dXJlMkQobm9ybWFsQnVmZmVyLHZVdjEpLnJnYjtuWzJdPXRleHR1cmUyRChub3JtYWxCdWZmZXIsdlV2MikucmdiO25bM109dGV4dHVyZTJEKG5vcm1hbEJ1ZmZlcix2VXYzKS5yZ2I7XFxuI2Vsc2VcXG52ZWMzIG5bNF07blswXT12ZWMzKDAuMCk7blsxXT12ZWMzKDAuMCk7blsyXT12ZWMzKDAuMCk7blszXT12ZWMzKDAuMCk7XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yPXZlYzQobltpbmRleF0sZFtpbmRleF0pO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWRvd25zYW1wbGluZy52ZXJ0XG52YXIgZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXV2O3ZVdjE9dmVjMih1di54LHV2LnkrdGV4ZWxTaXplLnkpO3ZVdjI9dmVjMih1di54K3RleGVsU2l6ZS54LHV2LnkpO3ZVdjM9dXYrdGV4ZWxTaXplO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0RlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWwuanNcbnZhciBEZXB0aERvd25zYW1wbGluZ01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDkge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBkb3duc2FtcGxpbmcgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgREVQVEhfUEFDS0lORzogXCIwXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBkZXB0aEJ1ZmZlcjogbmV3IFVuaWZvcm05KG51bGwpLFxuICAgICAgICBub3JtYWxCdWZmZXI6IG5ldyBVbmlmb3JtOShudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTkobmV3IFZlY3RvcjI0KCkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc5LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoX2Rvd25zYW1wbGluZ19kZWZhdWx0MlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMykge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkRPV05TQU1QTEVfTk9STUFMUyA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkRPV05TQU1QTEVfTk9STUFMUztcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vcm1hbCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBub3JtYWxCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKi9cbiAgc2V0Tm9ybWFsQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5ub3JtYWxCdWZmZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aE1hc2tNYXRlcmlhbC5qc1xuaW1wb3J0IHtcbiAgQWx3YXlzRGVwdGgsXG4gIEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nNCxcbiAgRXF1YWxEZXB0aCxcbiAgR3JlYXRlckRlcHRoLFxuICBHcmVhdGVyRXF1YWxEZXB0aCxcbiAgTGVzc0RlcHRoLFxuICBMZXNzRXF1YWxEZXB0aCxcbiAgTmV2ZXJEZXB0aCxcbiAgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTAsXG4gIE5vdEVxdWFsRGVwdGgsXG4gIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhNCxcbiAgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxMCxcbiAgVW5pZm9ybSBhcyBVbmlmb3JtMTAsXG4gIFZlY3RvcjIgYXMgVmVjdG9yMjVcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1tYXNrLmZyYWdcbnZhciBkZXB0aF9tYXNrX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIwO3VuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMTtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIwO3VuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIxO1xcbiNlbmRpZlxcbnVuaWZvcm0gc2FtcGxlcjJEIGlucHV0QnVmZmVyO3VuaWZvcm0gdmVjMiBjYW1lcmFOZWFyRmFyO2Zsb2F0IGdldFZpZXdaKGNvbnN0IGluIGZsb2F0IGRlcHRoKXtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xcbiNlbHNlXFxucmV0dXJuIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZW5kaWZcXG59dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2ZWMyIGRlcHRoO1xcbiNpZiBERVBUSF9QQUNLSU5HXzAgPT0gMzIwMVxcbmRlcHRoLng9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyMCx2VXYpKTtcXG4jZWxzZVxcbmRlcHRoLng9dGV4dHVyZTJEKGRlcHRoQnVmZmVyMCx2VXYpLnI7XFxuI2lmZGVmIExPR19ERVBUSFxcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aC54KmxvZzIoY2FtZXJhTmVhckZhci55KzEuMCkpLTEuMDtmbG9hdCBhPWNhbWVyYU5lYXJGYXIueS8oY2FtZXJhTmVhckZhci55LWNhbWVyYU5lYXJGYXIueCk7ZmxvYXQgYj1jYW1lcmFOZWFyRmFyLnkqY2FtZXJhTmVhckZhci54LyhjYW1lcmFOZWFyRmFyLngtY2FtZXJhTmVhckZhci55KTtkZXB0aC54PWErYi9kO1xcbiNlbmRpZlxcbiNlbmRpZlxcbiNpZiBERVBUSF9QQUNLSU5HXzEgPT0gMzIwMVxcbmRlcHRoLnk9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyMSx2VXYpKTtcXG4jZWxzZVxcbmRlcHRoLnk9dGV4dHVyZTJEKGRlcHRoQnVmZmVyMSx2VXYpLnI7XFxuI2lmZGVmIExPR19ERVBUSFxcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aC55KmxvZzIoY2FtZXJhTmVhckZhci55KzEuMCkpLTEuMDtmbG9hdCBhPWNhbWVyYU5lYXJGYXIueS8oY2FtZXJhTmVhckZhci55LWNhbWVyYU5lYXJGYXIueCk7ZmxvYXQgYj1jYW1lcmFOZWFyRmFyLnkqY2FtZXJhTmVhckZhci54LyhjYW1lcmFOZWFyRmFyLngtY2FtZXJhTmVhckZhci55KTtkZXB0aC55PWErYi9kO1xcbiNlbmRpZlxcbiNlbmRpZlxcbmJvb2wgaXNNYXhEZXB0aD0oZGVwdGgueD09MS4wKTtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxuZGVwdGgueD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoZ2V0Vmlld1ooZGVwdGgueCksY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7ZGVwdGgueT12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoZ2V0Vmlld1ooZGVwdGgueSksY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XFxuI2VuZGlmXFxuI2lmIERFUFRIX1RFU1RfU1RSQVRFR1kgPT0gMFxcbmJvb2wga2VlcD1kZXB0aFRlc3QoZGVwdGgueCxkZXB0aC55KTtcXG4jZWxpZiBERVBUSF9URVNUX1NUUkFURUdZID09IDFcXG5ib29sIGtlZXA9aXNNYXhEZXB0aHx8ZGVwdGhUZXN0KGRlcHRoLngsZGVwdGgueSk7XFxuI2Vsc2VcXG5ib29sIGtlZXA9IWlzTWF4RGVwdGgmJmRlcHRoVGVzdChkZXB0aC54LGRlcHRoLnkpO1xcbiNlbmRpZlxcbmlmKGtlZXApe2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTt9ZWxzZXtkaXNjYXJkO319XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhNYXNrTWF0ZXJpYWwuanNcbnZhciBEZXB0aE1hc2tNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxMCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoTWFza01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX0VQU0lMT046IFwiMC4wMDAxXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMDogXCIwXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMTogXCIwXCIsXG4gICAgICAgIERFUFRIX1RFU1RfU1RSQVRFR1k6IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMTAobnVsbCksXG4gICAgICAgIGRlcHRoQnVmZmVyMDogbmV3IFVuaWZvcm0xMChudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXIxOiBuZXcgVW5pZm9ybTEwKG51bGwpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTEwKG5ldyBWZWN0b3IyNSgxLCAxKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzEwLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfbWFza19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMuZGVwdGhNb2RlID0gTGVzc0RlcHRoO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIwLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmltYXJ5IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZzAodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lOR18wID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjAgYW5kIGRlcHRoUGFja2luZzAgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIwKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc0KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjAgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcwID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kYXJ5IGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIxKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlcjEudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlY29uZGFyeSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcxKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkdfMSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlciB0aGF0IHdpbGwgYmUgY29tcGFyZWQgd2l0aCB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjEgYW5kIGRlcHRoUGFja2luZzEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIxKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc0KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjEgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcxID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIG1heGltdW0gZGVwdGguXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFRlc3RTdHJhdGVneX1cbiAgICovXG4gIGdldCBtYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kpO1xuICB9XG4gIHNldCBtYXhEZXB0aFN0cmF0ZWd5KHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBtYXhpbXVtIGRlcHRoIHZhbHVlcyBzaG91bGQgYmUgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlcHRoU3RyYXRlZ3kgaW5zdGVhZC5cbiAgICovXG4gIGdldCBrZWVwRmFyKCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgc2V0IGtlZXBGYXIodmFsdWUpIHtcbiAgICB0aGlzLm1heERlcHRoU3RyYXRlZ3kgPSB2YWx1ZSA/IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIIDogRGVwdGhUZXN0U3RyYXRlZ3kuRElTQ0FSRF9NQVhfREVQVEg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoVGVzdFN0cmF0ZWd5fSBUaGUgc3RyYXRlZ3kuXG4gICAqL1xuICBnZXRNYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhUZXN0U3RyYXRlZ3l9IHZhbHVlIC0gVGhlIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0TWF4RGVwdGhTdHJhdGVneSh2YWx1ZSkge1xuICAgIHRoaXMubWF4RGVwdGhTdHJhdGVneSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIHNtYWxsIGVycm9yIHRocmVzaG9sZCB0aGF0IGlzIHVzZWQgZm9yIGBFcXVhbERlcHRoYCBhbmQgYE5vdEVxdWFsRGVwdGhgIHRlc3RzLiBEZWZhdWx0IGlzIGAxZS00YC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBlcHNpbG9uKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04pO1xuICB9XG4gIHNldCBlcHNpbG9uKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04gPSB2YWx1ZS50b0ZpeGVkKDE2KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBlcnJvciB0aHJlc2hvbGQgZm9yIGRlcHRoIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlcnJvciB0aHJlc2hvbGQuXG4gICAqL1xuICBnZXRFcHNpbG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVwc2lsb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGNvbXBhcmlzb24gZXJyb3IgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IGVycm9yIHRocmVzaG9sZC5cbiAgICovXG4gIHNldEVwc2lsb24odmFsdWUpIHtcbiAgICB0aGlzLmVwc2lsb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vY29uc3RhbnRzL01hdGVyaWFsc1xuICAgKiBAdHlwZSB7RGVwdGhNb2Rlc31cbiAgICovXG4gIGdldCBkZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuREVQVEhfTU9ERSk7XG4gIH1cbiAgc2V0IGRlcHRoTW9kZSh2YWx1ZSkge1xuICAgIGxldCBkZXB0aFRlc3Q7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBOZXZlckRlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImZhbHNlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbHdheXNEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJ0cnVlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA8PSBERVBUSF9FUFNJTE9OXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOb3RFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA+IERFUFRIX0VQU0lMT05cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlc3NEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+IGQxXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXNzRXF1YWxEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+PSBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPD0gZDFcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyZWF0ZXJEZXB0aDpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPCBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lc1tcImRlcHRoVGVzdChkMCwgZDEpXCJdID0gZGVwdGhUZXN0O1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aE1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhNb2Rlc30gVGhlIGRlcHRoIG1vZGUuIERlZmF1bHQgaXMgYExlc3NEZXB0aGAuXG4gICAqL1xuICBnZXREZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhNb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhNb2Rlc30gbW9kZSAtIFRoZSBkZXB0aCBtb2RlLlxuICAgKi9cbiAgc2V0RGVwdGhNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmRlcHRoTW9kZSA9IG1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlDYW1lcmFTZXR0aW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS5zZXQoY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIpO1xuICAgICAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhNCkge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Eb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTEsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTEsIFVuaWZvcm0gYXMgVW5pZm9ybTExLCBWZWN0b3IyIGFzIFZlY3RvcjI2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5kb3duc2FtcGxpbmcuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZW5kaWZcXG4jZGVmaW5lIFdFSUdIVF9JTk5FUiAwLjEyNVxcbiNkZWZpbmUgV0VJR0hUX09VVEVSIDAuMDU1NTU1NVxcbnZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjAwO3ZhcnlpbmcgdmVjMiB2VXYwMTt2YXJ5aW5nIHZlYzIgdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzO3ZhcnlpbmcgdmVjMiB2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2O3ZhcnlpbmcgdmVjMiB2VXYwNzt2YXJ5aW5nIHZlYzIgdlV2MDg7dmFyeWluZyB2ZWMyIHZVdjA5O3ZhcnlpbmcgdmVjMiB2VXYxMDt2YXJ5aW5nIHZlYzIgdlV2MTE7ZmxvYXQgY2xhbXBUb0JvcmRlcihjb25zdCBpbiB2ZWMyIHV2KXtyZXR1cm4gZmxvYXQodXYucz49MC4wJiZ1di5zPD0xLjAmJnV2LnQ+PTAuMCYmdXYudDw9MS4wKTt9dm9pZCBtYWluKCl7dmVjNCBjPXZlYzQoMC4wKTt2ZWM0IHc9V0VJR0hUX0lOTkVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwMCksY2xhbXBUb0JvcmRlcih2VXYwMSksY2xhbXBUb0JvcmRlcih2VXYwMiksY2xhbXBUb0JvcmRlcih2VXYwMykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDApO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDEpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDIpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDMpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwNCksY2xhbXBUb0JvcmRlcih2VXYwNSksY2xhbXBUb0JvcmRlcih2VXYwNiksY2xhbXBUb0JvcmRlcih2VXYwNykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDQpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDUpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDYpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDcpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwOCksY2xhbXBUb0JvcmRlcih2VXYwOSksY2xhbXBUb0JvcmRlcih2VXYxMCksY2xhbXBUb0JvcmRlcih2VXYxMSkpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDgpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDkpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTApO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTEpO2MrPVdFSUdIVF9PVVRFUip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9YztcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5kb3duc2FtcGxpbmcudmVydFxudmFyIGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwMDt2YXJ5aW5nIHZlYzIgdlV2MDE7dmFyeWluZyB2ZWMyIHZVdjAyO3ZhcnlpbmcgdmVjMiB2VXYwMzt2YXJ5aW5nIHZlYzIgdlV2MDQ7dmFyeWluZyB2ZWMyIHZVdjA1O3ZhcnlpbmcgdmVjMiB2VXYwNjt2YXJ5aW5nIHZlYzIgdlV2MDc7dmFyeWluZyB2ZWMyIHZVdjA4O3ZhcnlpbmcgdmVjMiB2VXYwOTt2YXJ5aW5nIHZlYzIgdlV2MTA7dmFyeWluZyB2ZWMyIHZVdjExO3ZvaWQgbWFpbigpe3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdjAwPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLDEuMCk7dlV2MDE9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwxLjApO3ZVdjAyPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLC0xLjApO3ZVdjAzPXZVdit0ZXhlbFNpemUqdmVjMigxLjAsLTEuMCk7dlV2MDQ9dlV2K3RleGVsU2l6ZSp2ZWMyKC0yLjAsMi4wKTt2VXYwNT12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLDIuMCk7dlV2MDY9dlV2K3RleGVsU2l6ZSp2ZWMyKDIuMCwyLjApO3ZVdjA3PXZVdit0ZXhlbFNpemUqdmVjMigtMi4wLDAuMCk7dlV2MDg9dlV2K3RleGVsU2l6ZSp2ZWMyKDIuMCwwLjApO3ZVdjA5PXZVdit0ZXhlbFNpemUqdmVjMigtMi4wLC0yLjApO3ZVdjEwPXZVdit0ZXhlbFNpemUqdmVjMigwLjAsLTIuMCk7dlV2MTE9dlV2K3RleGVsU2l6ZSp2ZWMyKDIuMCwtMi4wKTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9Eb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xudmFyIERvd25zYW1wbGluZ01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDExIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZG93bnNhbXBsaW5nIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEb3duc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMTEobnVsbCksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0xMShuZXcgVmVjdG9yMjYoKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzExLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fZG93bnNhbXBsaW5nX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB1cGRhdGVGcmFnbWVudFNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9FZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nNSwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTIsIFJFVklTSU9OIGFzIFJFVklTSU9OMiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxMiwgVW5pZm9ybSBhcyBVbmlmb3JtMTIsIFZlY3RvcjIgYXMgVmVjdG9yMjcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VkZ2UtZGV0ZWN0aW9uLmZyYWdcbnZhciBlZGdlX2RldGVjdGlvbl9kZWZhdWx0ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO1xcbiNpZiBUSFJFRV9SRVZJU0lPTiA8IDE0M1xcbiNkZWZpbmUgbHVtaW5hbmNlKHYpIGxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UodilcXG4jZW5kaWZcXG4jaWYgRURHRV9ERVRFQ1RJT05fTU9ERSAhPSAwXFxudmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dmFyeWluZyB2ZWMyIHZVdjQ7dmFyeWluZyB2ZWMyIHZVdjU7XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgPT0gMVxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgPT0gMCB8fCBQUkVESUNBVElPTl9NT0RFID09IDFcXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XFxuI2VuZGlmXFxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XFxuI2Vsc2VcXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xcbiNlbmRpZlxcbn12ZWMzIGdhdGhlck5laWdoYm9ycygpe2Zsb2F0IHA9cmVhZERlcHRoKHZVdik7ZmxvYXQgcExlZnQ9cmVhZERlcHRoKHZVdjApO2Zsb2F0IHBUb3A9cmVhZERlcHRoKHZVdjEpO3JldHVybiB2ZWMzKHAscExlZnQscFRvcCk7fVxcbiNlbGlmIFBSRURJQ0FUSU9OX01PREUgPT0gMlxcbnVuaWZvcm0gc2FtcGxlcjJEIHByZWRpY2F0aW9uQnVmZmVyO3ZlYzMgZ2F0aGVyTmVpZ2hib3JzKCl7ZmxvYXQgcD10ZXh0dXJlMkQocHJlZGljYXRpb25CdWZmZXIsdlV2KS5yO2Zsb2F0IHBMZWZ0PXRleHR1cmUyRChwcmVkaWNhdGlvbkJ1ZmZlcix2VXYwKS5yO2Zsb2F0IHBUb3A9dGV4dHVyZTJEKHByZWRpY2F0aW9uQnVmZmVyLHZVdjEpLnI7cmV0dXJuIHZlYzMocCxwTGVmdCxwVG9wKTt9XFxuI2VuZGlmXFxuI2lmIFBSRURJQ0FUSU9OX01PREUgIT0gMFxcbnZlYzIgY2FsY3VsYXRlUHJlZGljYXRlZFRocmVzaG9sZCgpe3ZlYzMgbmVpZ2hib3Vycz1nYXRoZXJOZWlnaGJvcnMoKTt2ZWMyIGRlbHRhPWFicyhuZWlnaGJvdXJzLnh4LW5laWdoYm91cnMueXopO3ZlYzIgZWRnZXM9c3RlcChQUkVESUNBVElPTl9USFJFU0hPTEQsZGVsdGEpO3JldHVybiBQUkVESUNBVElPTl9TQ0FMRSpFREdFX1RIUkVTSE9MRCooMS4wLVBSRURJQ0FUSU9OX1NUUkVOR1RIKmVkZ2VzKTt9XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgIT0gMFxcbnVuaWZvcm0gc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpe1xcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDBcXG5jb25zdCB2ZWMyIHRocmVzaG9sZD12ZWMyKERFUFRIX1RIUkVTSE9MRCk7XFxuI2VsaWYgUFJFRElDQVRJT05fTU9ERSAhPSAwXFxudmVjMiB0aHJlc2hvbGQ9Y2FsY3VsYXRlUHJlZGljYXRlZFRocmVzaG9sZCgpO1xcbiNlbHNlXFxuY29uc3QgdmVjMiB0aHJlc2hvbGQ9dmVjMihFREdFX1RIUkVTSE9MRCk7XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgPT0gMFxcbnZlYzMgbmVpZ2hib3JzPWdhdGhlck5laWdoYm9ycygpO3ZlYzIgZGVsdGE9YWJzKG5laWdoYm9ycy54eC12ZWMyKG5laWdoYm9ycy55LG5laWdoYm9ycy56KSk7dmVjMiBlZGdlcz1zdGVwKHRocmVzaG9sZCxkZWx0YSk7aWYoZG90KGVkZ2VzLHZlYzIoMS4wKSk9PTAuMCl7ZGlzY2FyZDt9Z2xfRnJhZ0NvbG9yPXZlYzQoZWRnZXMsMC4wLDEuMCk7XFxuI2VsaWYgRURHRV9ERVRFQ1RJT05fTU9ERSA9PSAxXFxuZmxvYXQgbD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikucmdiKTtmbG9hdCBsTGVmdD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjApLnJnYik7ZmxvYXQgbFRvcD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpLnJnYik7dmVjNCBkZWx0YTtkZWx0YS54eT1hYnMobC12ZWMyKGxMZWZ0LGxUb3ApKTt2ZWMyIGVkZ2VzPXN0ZXAodGhyZXNob2xkLGRlbHRhLnh5KTtpZihkb3QoZWRnZXMsdmVjMigxLjApKT09MC4wKXtkaXNjYXJkO31mbG9hdCBsUmlnaHQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKS5yZ2IpO2Zsb2F0IGxCb3R0b209bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYzKS5yZ2IpO2RlbHRhLnp3PWFicyhsLXZlYzIobFJpZ2h0LGxCb3R0b20pKTt2ZWMyIG1heERlbHRhPW1heChkZWx0YS54eSxkZWx0YS56dyk7ZmxvYXQgbExlZnRMZWZ0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NCkucmdiKTtmbG9hdCBsVG9wVG9wPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NSkucmdiKTtkZWx0YS56dz1hYnModmVjMihsTGVmdCxsVG9wKS12ZWMyKGxMZWZ0TGVmdCxsVG9wVG9wKSk7bWF4RGVsdGE9bWF4KG1heERlbHRhLnh5LGRlbHRhLnp3KTtmbG9hdCBmaW5hbERlbHRhPW1heChtYXhEZWx0YS54LG1heERlbHRhLnkpO2VkZ2VzLnh5Kj1zdGVwKGZpbmFsRGVsdGEsTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IqZGVsdGEueHkpO2dsX0ZyYWdDb2xvcj12ZWM0KGVkZ2VzLDAuMCwxLjApO1xcbiNlbGlmIEVER0VfREVURUNUSU9OX01PREUgPT0gMlxcbnZlYzQgZGVsdGE7dmVjMyBjPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpLnJnYjt2ZWMzIGNMZWZ0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKS5yZ2I7dmVjMyB0PWFicyhjLWNMZWZ0KTtkZWx0YS54PW1heChtYXgodC5yLHQuZyksdC5iKTt2ZWMzIGNUb3A9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpLnJnYjt0PWFicyhjLWNUb3ApO2RlbHRhLnk9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzIgZWRnZXM9c3RlcCh0aHJlc2hvbGQsZGVsdGEueHkpO2lmKGRvdChlZGdlcyx2ZWMyKDEuMCkpPT0wLjApe2Rpc2NhcmQ7fXZlYzMgY1JpZ2h0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKS5yZ2I7dD1hYnMoYy1jUmlnaHQpO2RlbHRhLno9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzMgY0JvdHRvbT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MykucmdiO3Q9YWJzKGMtY0JvdHRvbSk7ZGVsdGEudz1tYXgobWF4KHQucix0LmcpLHQuYik7dmVjMiBtYXhEZWx0YT1tYXgoZGVsdGEueHksZGVsdGEuencpO3ZlYzMgY0xlZnRMZWZ0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY0KS5yZ2I7dD1hYnMoYy1jTGVmdExlZnQpO2RlbHRhLno9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzMgY1RvcFRvcD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NSkucmdiO3Q9YWJzKGMtY1RvcFRvcCk7ZGVsdGEudz1tYXgobWF4KHQucix0LmcpLHQuYik7bWF4RGVsdGE9bWF4KG1heERlbHRhLnh5LGRlbHRhLnp3KTtmbG9hdCBmaW5hbERlbHRhPW1heChtYXhEZWx0YS54LG1heERlbHRhLnkpO2VkZ2VzKj1zdGVwKGZpbmFsRGVsdGEsTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IqZGVsdGEueHkpO2dsX0ZyYWdDb2xvcj12ZWM0KGVkZ2VzLDAuMCwxLjApO1xcbiNlbmRpZlxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VkZ2UtZGV0ZWN0aW9uLnZlcnRcbnZhciBlZGdlX2RldGVjdGlvbl9kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO1xcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcXG52YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2YXJ5aW5nIHZlYzIgdlV2NDt2YXJ5aW5nIHZlYzIgdlV2NTtcXG4jZW5kaWZcXG52b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLDAuMCk7dlV2MT12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLC0xLjApO1xcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcXG52VXYyPXZVdit0ZXhlbFNpemUqdmVjMigxLjAsMC4wKTt2VXYzPXZVdit0ZXhlbFNpemUqdmVjMigwLjAsMS4wKTt2VXY0PXZVdit0ZXhlbFNpemUqdmVjMigtMi4wLDAuMCk7dlV2NT12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLC0yLjApO1xcbiNlbmRpZlxcbmdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0VkZ2VEZXRlY3Rpb25NYXRlcmlhbC5qc1xudmFyIEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxMiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVkZ2UgZGV0ZWN0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIHNjcmVlbiB0ZXhlbCBzaXplLlxuICAgKiBAcGFyYW0ge0VkZ2VEZXRlY3Rpb25Nb2RlfSBbbW9kZT1FZGdlRGV0ZWN0aW9uTW9kZS5DT0xPUl0gLSBUaGUgZWRnZSBkZXRlY3Rpb24gbW9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyNygpLCBtb2RlID0gRWRnZURldGVjdGlvbk1vZGUuQ09MT1IpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkVkZ2VEZXRlY3Rpb25NYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBUSFJFRV9SRVZJU0lPTjogUkVWSVNJT04yLnJlcGxhY2UoL1xcRCsvZywgXCJcIiksXG4gICAgICAgIExPQ0FMX0NPTlRSQVNUX0FEQVBUQVRJT05fRkFDVE9SOiBcIjIuMFwiLFxuICAgICAgICBFREdFX1RIUkVTSE9MRDogXCIwLjFcIixcbiAgICAgICAgREVQVEhfVEhSRVNIT0xEOiBcIjAuMDFcIixcbiAgICAgICAgUFJFRElDQVRJT05fTU9ERTogXCIwXCIsXG4gICAgICAgIFBSRURJQ0FUSU9OX1RIUkVTSE9MRDogXCIwLjAxXCIsXG4gICAgICAgIFBSRURJQ0FUSU9OX1NDQUxFOiBcIjIuMFwiLFxuICAgICAgICBQUkVESUNBVElPTl9TVFJFTkdUSDogXCIxLjBcIixcbiAgICAgICAgREVQVEhfUEFDS0lORzogXCIwXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xMihudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMTIobnVsbCksXG4gICAgICAgIHByZWRpY2F0aW9uQnVmZmVyOiBuZXcgVW5pZm9ybTEyKG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTIodGV4ZWxTaXplKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTIsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBlZGdlX2RldGVjdGlvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBlZGdlX2RldGVjdGlvbl9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1vZGUgPSBtb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNSkge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAdHlwZSB7RWRnZURldGVjdGlvbk1vZGV9XG4gICAqL1xuICBnZXQgZWRnZURldGVjdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuRURHRV9ERVRFQ1RJT05fTU9ERSk7XG4gIH1cbiAgc2V0IGVkZ2VEZXRlY3Rpb25Nb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkVER0VfREVURUNUSU9OX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvbk1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RWRnZURldGVjdGlvbk1vZGV9IFRoZSBtb2RlLlxuICAgKi9cbiAgZ2V0RWRnZURldGVjdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvbk1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVkZ2UgZGV0ZWN0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0VkZ2VEZXRlY3Rpb25Nb2RlfSB2YWx1ZSAtIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKi9cbiAgc2V0RWRnZURldGVjdGlvbk1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25Nb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgZWRnZSBkZXRlY3Rpb24gbW9kZSBpcyBzZXQgdG8gREVQVEguIERlZmF1bHQgaXMgMi4wLlxuICAgKlxuICAgKiBJZiBhIG5laWdoYm9yIGVkZ2UgaGFzIF9mYWN0b3JfIHRpbWVzIGJpZ2dlciBjb250cmFzdCB0aGFuIHRoZSBjdXJyZW50IGVkZ2UsIHRoZSBlZGdlIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB0byBlbGltaW5hdGUgc3B1cmlvdXMgY3Jvc3NpbmcgZWRnZXMgYW5kIGlzIGJhc2VkIG9uIHRoZSBmYWN0IHRoYXQgaWYgdGhlcmUgaXMgdG9vIG11Y2ggY29udHJhc3QgaW4gYVxuICAgKiBkaXJlY3Rpb24sIHRoZSBwZXJjZXB0dWFsIGNvbnRyYXN0IGluIHRoZSBvdGhlciBuZWlnaGJvcnMgd2lsbCBiZSBoaWRkZW4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IpO1xuICB9XG4gIHNldCBsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3Rvcih2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5MT0NBTF9DT05UUkFTVF9BREFQVEFUSU9OX0ZBQ1RPUiA9IHZhbHVlLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZhY3Rvci5cbiAgICovXG4gIGdldExvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgZWRnZSBkZXRlY3Rpb24gbW9kZSBpcyBzZXQgdG8gREVQVEguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3RvciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbG9jYWwgY29udHJhc3QgYWRhcHRhdGlvbiBmYWN0b3IuIERlZmF1bHQgaXMgMi4wLlxuICAgKi9cbiAgc2V0TG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLmxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiB0aHJlc2hvbGQuIFJhbmdlOiBbMC4wLCAwLjVdLlxuICAgKlxuICAgKiBBIGxvd2VyIHZhbHVlIHJlc3VsdHMgaW4gbW9yZSBlZGdlcyBiZWluZyBkZXRlY3RlZCBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cbiAgICpcbiAgICogRm9yIGx1bWEtIGFuZCBjaHJvbWEtYmFzZWQgZWRnZSBkZXRlY3Rpb24sIDAuMSBpcyBhIHJlYXNvbmFibGUgdmFsdWUgYW5kIGFsbG93cyB0byBjYXRjaCBtb3N0IHZpc2libGUgZWRnZXMuIDAuMDVcbiAgICogaXMgYSByYXRoZXIgb3ZlcmtpbGwgdmFsdWUgdGhhdCBhbGxvd3MgdG8gY2F0Y2ggJ2VtIGFsbC4gRGFya2VyIHNjZW5lcyBtYXkgcmVxdWlyZSBhbiBldmVuIGxvd2VyIHRocmVzaG9sZC5cbiAgICpcbiAgICogSWYgZGVwdGgtYmFzZWQgZWRnZSBkZXRlY3Rpb24gaXMgdXNlZCwgdGhlIHRocmVzaG9sZCB3aWxsIGRlcGVuZCBvbiB0aGUgc2NlbmUgZGVwdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZWRnZURldGVjdGlvblRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5FREdFX1RIUkVTSE9MRCk7XG4gIH1cbiAgc2V0IGVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuRURHRV9USFJFU0hPTEQgPSB2YWx1ZS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfVEhSRVNIT0xEID0gKHZhbHVlICogMC4xKS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvblRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB0aHJlc2hvbGQuXG4gICAqL1xuICBnZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC4gUmFuZ2U6IFswLjAsIDAuNV0uXG4gICAqL1xuICBzZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBtb2RlLlxuICAgKlxuICAgKiBQcmVkaWNhdGVkIHRocmVzaG9sZGluZyBhbGxvd3MgdG8gYmV0dGVyIHByZXNlcnZlIHRleHR1cmUgZGV0YWlscyBhbmQgdG8gaW1wcm92ZSBlZGdlIGRldGVjdGlvbiB1c2luZyBhbiBhZGRpdGlvbmFsXG4gICAqIGJ1ZmZlciBzdWNoIGFzIGEgbGlnaHQgYWNjdW11bGF0aW9uIG9yIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1ByZWRpY2F0aW9uTW9kZX1cbiAgICovXG4gIGdldCBwcmVkaWNhdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fTU9ERSk7XG4gIH1cbiAgc2V0IHByZWRpY2F0aW9uTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9NT0RFID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtQcmVkaWNhdGlvbk1vZGV9IFRoZSBtb2RlLlxuICAgKi9cbiAgZ2V0UHJlZGljYXRpb25Nb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uTW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ByZWRpY2F0aW9uTW9kZX0gdmFsdWUgLSBUaGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICovXG4gIHNldFByZWRpY2F0aW9uTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMucHJlZGljYXRpb25Nb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IHByZWRpY2F0aW9uQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5wcmVkaWNhdGlvbkJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIHByZWRpY2F0aW9uIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uQnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgcHJlZGljYXRpb24gYnVmZmVyLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25CdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByZWRpY2F0aW9uQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJlZGljYXRpb25UaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fVEhSRVNIT0xEKTtcbiAgfVxuICBzZXQgcHJlZGljYXRpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fVEhSRVNIT0xEID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWRpY2F0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uVGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIGdldFByZWRpY2F0aW9uVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uVGhyZXNob2xkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVkaWNhdGlvbiB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgdGhyZXNob2xkLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLnByZWRpY2F0aW9uVGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBzY2FsZS4gUmFuZ2U6IFsxLjAsIDUuMF0uXG4gICAqXG4gICAqIERldGVybWluZXMgaG93IG11Y2ggdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZCBzaG91bGQgYmUgc2NhbGVkIHdoZW4gdXNpbmcgcHJlZGljYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufFRleHR1cmV8TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByZWRpY2F0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fU0NBTEUpO1xuICB9XG4gIHNldCBwcmVkaWNhdGlvblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX1NDQUxFID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWRpY2F0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25TY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFByZWRpY2F0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRpb25TY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZGljYXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS4gUmFuZ2U6IFsxLjAsIDUuMF0uXG4gICAqL1xuICBzZXRQcmVkaWNhdGlvblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGlvblNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBzdHJlbmd0aC4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIERldGVybWluZXMgaG93IG11Y2ggdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZCBzaG91bGQgYmUgZGVjcmVhc2VkIGxvY2FsbHkgd2hlbiB1c2luZyBwcmVkaWNhdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwcmVkaWNhdGlvblN0cmVuZ3RoKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX1NUUkVOR1RIKTtcbiAgfVxuICBzZXQgcHJlZGljYXRpb25TdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9TVFJFTkdUSCA9IHZhbHVlLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVkaWNhdGlvbiBzdHJlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uU3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBnZXRQcmVkaWNhdGlvblN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uU3RyZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWRpY2F0aW9uIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25TdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3RyZW5ndGguIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25TdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZGljYXRpb25TdHJlbmd0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvRWZmZWN0TWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nNiwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTMsIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhNSwgUkVWSVNJT04gYXMgUkVWSVNJT04zLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDEzLCBVbmlmb3JtIGFzIFVuaWZvcm0xMywgVmVjdG9yMiBhcyBWZWN0b3IyOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZWZmZWN0LmZyYWdcbnZhciBlZmZlY3RfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2RlZmluZSBwYWNrRmxvYXRUb1JHQkEodikgcGFja0RlcHRoVG9SR0JBKHYpXFxuI2RlZmluZSB1bnBhY2tSR0JBVG9GbG9hdCh2KSB1bnBhY2tSR0JBVG9EZXB0aCh2KVxcbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbGlmIGRlZmluZWQoR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gpXFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO3VuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBjYW1lcmFOZWFyO3VuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO3VuaWZvcm0gZmxvYXQgYXNwZWN0O3VuaWZvcm0gZmxvYXQgdGltZTt2YXJ5aW5nIHZlYzIgdlV2O1xcbiNpZiBUSFJFRV9SRVZJU0lPTiA8IDE0M1xcbiNkZWZpbmUgbHVtaW5hbmNlKHYpIGxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UodilcXG4jZW5kaWZcXG4jaWYgVEhSRUVfUkVWSVNJT04gPj0gMTM3XFxudmVjNCBzUkdCVG9MaW5lYXIoY29uc3QgaW4gdmVjNCB2YWx1ZSl7cmV0dXJuIHZlYzQobWl4KHBvdyh2YWx1ZS5yZ2IqMC45NDc4NjcyOTg2K3ZlYzMoMC4wNTIxMzI3MDE0KSx2ZWMzKDIuNCkpLHZhbHVlLnJnYiowLjA3NzM5OTM4MDgsdmVjMyhsZXNzVGhhbkVxdWFsKHZhbHVlLnJnYix2ZWMzKDAuMDQwNDUpKSkpLHZhbHVlLmEpO31cXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxufWZsb2F0IGdldFZpZXdaKGNvbnN0IGluIGZsb2F0IGRlcHRoKXtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZWxzZVxcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xcbiNlbmRpZlxcbn12ZWMzIFJHQlRvSENWKGNvbnN0IGluIHZlYzMgUkdCKXt2ZWM0IFA9bWl4KHZlYzQoUkdCLmJnLC0xLjAsMi4wLzMuMCksdmVjNChSR0IuZ2IsMC4wLC0xLjAvMy4wKSxzdGVwKFJHQi5iLFJHQi5nKSk7dmVjNCBRPW1peCh2ZWM0KFAueHl3LFJHQi5yKSx2ZWM0KFJHQi5yLFAueXp4KSxzdGVwKFAueCxSR0IucikpO2Zsb2F0IEM9US54LW1pbihRLncsUS55KTtmbG9hdCBIPWFicygoUS53LVEueSkvKDYuMCpDK0VQU0lMT04pK1Eueik7cmV0dXJuIHZlYzMoSCxDLFEueCk7fXZlYzMgUkdCVG9IU0woY29uc3QgaW4gdmVjMyBSR0Ipe3ZlYzMgSENWPVJHQlRvSENWKFJHQik7ZmxvYXQgTD1IQ1Yuei1IQ1YueSowLjU7ZmxvYXQgUz1IQ1YueS8oMS4wLWFicyhMKjIuMC0xLjApK0VQU0lMT04pO3JldHVybiB2ZWMzKEhDVi54LFMsTCk7fXZlYzMgSHVlVG9SR0IoY29uc3QgaW4gZmxvYXQgSCl7ZmxvYXQgUj1hYnMoSCo2LjAtMy4wKS0xLjA7ZmxvYXQgRz0yLjAtYWJzKEgqNi4wLTIuMCk7ZmxvYXQgQj0yLjAtYWJzKEgqNi4wLTQuMCk7cmV0dXJuIGNsYW1wKHZlYzMoUixHLEIpLDAuMCwxLjApO312ZWMzIEhTTFRvUkdCKGNvbnN0IGluIHZlYzMgSFNMKXt2ZWMzIFJHQj1IdWVUb1JHQihIU0wueCk7ZmxvYXQgQz0oMS4wLWFicygyLjAqSFNMLnotMS4wKSkqSFNMLnk7cmV0dXJuKFJHQi0wLjUpKkMrSFNMLno7fUZSQUdNRU5UX0hFQUQgdm9pZCBtYWluKCl7RlJBR01FTlRfTUFJTl9VViB2ZWM0IGNvbG9yMD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsVVYpO3ZlYzQgY29sb3IxPXZlYzQoMC4wKTtGUkFHTUVOVF9NQUlOX0lNQUdFIGNvbG9yMC5hPWNsYW1wKGNvbG9yMC5hLDAuMCwxLjApO2dsX0ZyYWdDb2xvcj1jb2xvcjA7XFxuI2lmZGVmIEVOQ09ERV9PVVRQVVRcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG4jZW5kaWZcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VmZmVjdC52ZXJ0XG52YXIgZWZmZWN0X2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjt1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjt1bmlmb3JtIGZsb2F0IGFzcGVjdDt1bmlmb3JtIGZsb2F0IHRpbWU7dmFyeWluZyB2ZWMyIHZVdjtWRVJURVhfSEVBRCB2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTtWRVJURVhfTUFJTl9TVVBQT1JUIGdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0VmZmVjdE1hdGVyaWFsLmpzXG52YXIgRWZmZWN0TWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gW3NoYWRlclBhcnRzXSAtIERlcHJlY2F0ZWQuIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gW2RlZmluZXNdIC0gRGVwcmVjYXRlZC4gVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gW3VuaWZvcm1zXSAtIERlcHJlY2F0ZWQuIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkaXRoZXJpbmc9ZmFsc2VdIC0gRGVwcmVjYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNoYWRlclBhcnRzLCBkZWZpbmVzLCB1bmlmb3JtcywgY2FtZXJhLCBkaXRoZXJpbmcgPSBmYWxzZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRWZmZWN0TWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgVEhSRUVfUkVWSVNJT046IFJFVklTSU9OMy5yZXBsYWNlKC9cXEQrL2csIFwiXCIpLFxuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgRU5DT0RFX09VVFBVVDogXCIxXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xMyhudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMTMobnVsbCksXG4gICAgICAgIHJlc29sdXRpb246IG5ldyBVbmlmb3JtMTMobmV3IFZlY3RvcjI4KCkpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTMobmV3IFZlY3RvcjI4KCkpLFxuICAgICAgICBjYW1lcmFOZWFyOiBuZXcgVW5pZm9ybTEzKDAuMyksXG4gICAgICAgIGNhbWVyYUZhcjogbmV3IFVuaWZvcm0xMygxZTMpLFxuICAgICAgICBhc3BlY3Q6IG5ldyBVbmlmb3JtMTMoMSksXG4gICAgICAgIHRpbWU6IG5ldyBVbmlmb3JtMTMoMClcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzEzLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBkaXRoZXJpbmdcbiAgICB9KTtcbiAgICBpZiAoc2hhZGVyUGFydHMpIHtcbiAgICAgIHRoaXMuc2V0U2hhZGVyUGFydHMoc2hhZGVyUGFydHMpO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lcykge1xuICAgICAgdGhpcy5zZXREZWZpbmVzKGRlZmluZXMpO1xuICAgIH1cbiAgICBpZiAodW5pZm9ybXMpIHtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICAgIH1cbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgZGVwdGhCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWU7XG4gIH1cbiAgc2V0IGRlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9XG4gICAqL1xuICBnZXQgZGVwdGhQYWNraW5nKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkcpO1xuICB9XG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzYpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXIgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtFZmZlY3RTaGFkZXJEYXRhfSBkYXRhIC0gVGhlIHNoYWRlciBkYXRhLlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldFNoYWRlckRhdGEoZGF0YSkge1xuICAgIHRoaXMuc2V0U2hhZGVyUGFydHMoZGF0YS5zaGFkZXJQYXJ0cyk7XG4gICAgdGhpcy5zZXREZWZpbmVzKGRhdGEuZGVmaW5lcyk7XG4gICAgdGhpcy5zZXRVbmlmb3JtcyhkYXRhLnVuaWZvcm1zKTtcbiAgICB0aGlzLnNldEV4dGVuc2lvbnMoZGF0YS5leHRlbnNpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2hhZGVyIHBhcnRzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFN0cmluZz59IHNoYWRlclBhcnRzIC0gQSBjb2xsZWN0aW9uIG9mIHNoYWRlciBzbmlwcGV0cy4gU2VlIHtAbGluayBFZmZlY3RTaGFkZXJTZWN0aW9ufS5cbiAgICogQHJldHVybiB7RWZmZWN0TWF0ZXJpYWx9IFRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRTaGFkZXJQYXJ0cyhzaGFkZXJQYXJ0cykge1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBlZmZlY3RfZGVmYXVsdC5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCkgfHwgXCJcIikucmVwbGFjZShFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYsIHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYpIHx8IFwiXCIpLnJlcGxhY2UoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFLCBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFKSB8fCBcIlwiKTtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IGVmZmVjdF9kZWZhdWx0Mi5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX0hFQUQsIHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9IRUFEKSB8fCBcIlwiKS5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCkgfHwgXCJcIik7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXIgbWFjcm9zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFN0cmluZz59IGRlZmluZXMgLSBBIGNvbGxlY3Rpb24gb2YgcHJlcHJvY2Vzc29yIG1hY3JvIGRlZmluaXRpb25zLlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldERlZmluZXMoZGVmaW5lcykge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGVmaW5lcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRoaXMuZGVmaW5lc1tlbnRyeVswXV0gPSBlbnRyeVsxXTtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNoYWRlciB1bmlmb3Jtcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gdW5pZm9ybXMgLSBBIGNvbGxlY3Rpb24gb2YgdW5pZm9ybXMuXG4gICAqIEByZXR1cm4ge0VmZmVjdE1hdGVyaWFsfSBUaGlzIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0VW5pZm9ybXModW5pZm9ybXMpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHVuaWZvcm1zLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy51bmlmb3Jtc1tlbnRyeVswXV0gPSBlbnRyeVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlcXVpcmVkIHNoYWRlciBleHRlbnNpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1NldDxXZWJHTEV4dGVuc2lvbj59IGV4dGVuc2lvbnMgLSBBIGNvbGxlY3Rpb24gb2YgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybiB7RWZmZWN0TWF0ZXJpYWx9IFRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiBleHRlbnNpb25zKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvdXRwdXQgZW5jb2RpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZW5jb2RlT3V0cHV0KCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuRU5DT0RFX09VVFBVVCAhPT0gdm9pZCAwO1xuICB9XG4gIHNldCBlbmNvZGVPdXRwdXQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5lbmNvZGVPdXRwdXQgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLkVOQ09ERV9PVVRQVVQgPSBcIjFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuRU5DT0RFX09VVFBVVDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3V0cHV0IGVuY29kaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlbmNvZGVPdXRwdXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvdXRwdXQgZW5jb2RpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzT3V0cHV0RW5jb2RpbmdFbmFibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlT3V0cHV0O1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIG91dHB1dCBlbmNvZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVuY29kZU91dHB1dCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBvdXRwdXQgZW5jb2Rpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRPdXRwdXRFbmNvZGluZ0VuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmVuY29kZU91dHB1dCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGltZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZTtcbiAgfVxuICBzZXQgdGltZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWx0YSB0aW1lLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGltZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZGVsdGEgdGltZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0RGVsdGFUaW1lKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy50aW1lLnZhbHVlICs9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgdW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgdW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICAgIHVuaWZvcm1zLmFzcGVjdC52YWx1ZSA9IHdpZHRoIC8gaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBBbiBlbnVtZXJhdGlvbiBvZiBzaGFkZXIgY29kZSBwbGFjZWhvbGRlcnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBFZmZlY3RTaGFkZXJTZWN0aW9uIGluc3RlYWQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFNlY3Rpb24oKSB7XG4gICAgcmV0dXJuIEVmZmVjdFNoYWRlclNlY3Rpb247XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvR2F1c3NpYW5CbHVyTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE0LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE0LCBVbmlmb3JtIGFzIFVuaWZvcm0xNCwgVmVjdG9yMiBhcyBWZWN0b3IyOSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ2F1c3NpYW4uZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQgPSBcIiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMiBrZXJuZWxbU1RFUFNdO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0O3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCByZXN1bHQ9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikqa2VybmVsWzBdLnk7Zm9yKGludCBpPTE7aTxTVEVQUzsrK2kpe3ZlYzIgb2Zmc2V0PWtlcm5lbFtpXS54KnZPZmZzZXQ7dmVjNCBjMD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2K29mZnNldCk7dmVjNCBjMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2LW9mZnNldCk7cmVzdWx0Kz0oYzArYzEpKmtlcm5lbFtpXS55O31nbF9GcmFnQ29sb3I9cmVzdWx0O1xcbiNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmdhdXNzaWFuLnZlcnRcbnZhciBjb252b2x1dGlvbl9nYXVzc2lhbl9kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIHZlYzIgZGlyZWN0aW9uO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZPZmZzZXQ7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2T2Zmc2V0PWRpcmVjdGlvbip0ZXhlbFNpemUqc2NhbGU7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvR2F1c3NpYW5CbHVyTWF0ZXJpYWwuanNcbnZhciBHYXVzc2lhbkJsdXJNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxNCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnZvbHV0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPTM1XSAtIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsga2VybmVsU2l6ZSA9IDM1IH0gPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiR2F1c3NpYW5CbHVyTWF0ZXJpYWxcIixcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE0KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTQobmV3IFZlY3RvcjI5KCkpLFxuICAgICAgICBkaXJlY3Rpb246IG5ldyBVbmlmb3JtMTQobmV3IFZlY3RvcjI5KCkpLFxuICAgICAgICBrZXJuZWw6IG5ldyBVbmlmb3JtMTQobnVsbCksXG4gICAgICAgIHNjYWxlOiBuZXcgVW5pZm9ybTE0KDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxNCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMuX2tlcm5lbFNpemUgPSAwO1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2VybmVsU2l6ZTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuX2tlcm5lbFNpemUgPSB2YWx1ZTtcbiAgICB0aGlzLmdlbmVyYXRlS2VybmVsKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgZGlyZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGlyZWN0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBrZXJuZWwgc2NhbGUuIFZhbHVlcyBncmVhdGVyIHRoYW4gMS4wIG1heSBpbnRyb2R1Y2UgYXJ0aWZhY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBHYXVzcyBrZXJuZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0ga2VybmVsU2l6ZSAtIFRoZSBrZXJuZWwgc2l6ZS4gU2hvdWxkIGJlIGFuIG9kZCBudW1iZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZW5lcmF0ZUtlcm5lbChrZXJuZWxTaXplKSB7XG4gICAgY29uc3Qga2VybmVsID0gbmV3IEdhdXNzS2VybmVsKGtlcm5lbFNpemUpO1xuICAgIGNvbnN0IHN0ZXBzID0ga2VybmVsLmxpbmVhclN0ZXBzO1xuICAgIGNvbnN0IGtlcm5lbERhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHN0ZXBzICogMik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgc3RlcHM7ICsraSkge1xuICAgICAga2VybmVsRGF0YVtqKytdID0ga2VybmVsLmxpbmVhck9mZnNldHNbaV07XG4gICAgICBrZXJuZWxEYXRhW2orK10gPSBrZXJuZWwubGluZWFyV2VpZ2h0c1tpXTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5rZXJuZWwudmFsdWUgPSBrZXJuZWxEYXRhO1xuICAgIHRoaXMuZGVmaW5lcy5TVEVQUyA9IHN0ZXBzLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Hb2RSYXlzTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE1LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE1LCBVbmlmb3JtIGFzIFVuaWZvcm0xNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ29kLXJheXMuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2dvZF9yYXlzX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMiBsaWdodFBvc2l0aW9uO3VuaWZvcm0gZmxvYXQgZXhwb3N1cmU7dW5pZm9ybSBmbG9hdCBkZWNheTt1bmlmb3JtIGZsb2F0IGRlbnNpdHk7dW5pZm9ybSBmbG9hdCB3ZWlnaHQ7dW5pZm9ybSBmbG9hdCBjbGFtcE1heDt2YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe3ZlYzIgY29vcmQ9dlV2O3ZlYzIgZGVsdGE9bGlnaHRQb3NpdGlvbi1jb29yZDtkZWx0YSo9MS4wL1NBTVBMRVNfRkxPQVQqZGVuc2l0eTtmbG9hdCBpbGx1bWluYXRpb25EZWNheT0xLjA7dmVjNCBjb2xvcj12ZWM0KDAuMCk7Zm9yKGludCBpPTA7aTxTQU1QTEVTX0lOVDsrK2kpe2Nvb3JkKz1kZWx0YTt2ZWM0IHRleGVsPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZCk7dGV4ZWwqPWlsbHVtaW5hdGlvbkRlY2F5KndlaWdodDtjb2xvcis9dGV4ZWw7aWxsdW1pbmF0aW9uRGVjYXkqPWRlY2F5O31nbF9GcmFnQ29sb3I9Y2xhbXAoY29sb3IqZXhwb3N1cmUsMC4wLGNsYW1wTWF4KTtcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9Hb2RSYXlzTWF0ZXJpYWwuanNcbnZhciBHb2RSYXlzTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTUge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBnb2QgcmF5cyBtYXRlcmlhbC5cbiAgICpcbiAgICogVE9ETyBSZW1vdmUgbGlnaHRQb3NpdGlvbiBwYXJhbS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBsaWdodFBvc2l0aW9uIC0gRGVwcmVjYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxpZ2h0UG9zaXRpb24pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkdvZFJheXNNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBTQU1QTEVTX0lOVDogXCI2MFwiLFxuICAgICAgICBTQU1QTEVTX0ZMT0FUOiBcIjYwLjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE1KG51bGwpLFxuICAgICAgICBsaWdodFBvc2l0aW9uOiBuZXcgVW5pZm9ybTE1KGxpZ2h0UG9zaXRpb24pLFxuICAgICAgICBkZW5zaXR5OiBuZXcgVW5pZm9ybTE1KDEpLFxuICAgICAgICBkZWNheTogbmV3IFVuaWZvcm0xNSgxKSxcbiAgICAgICAgd2VpZ2h0OiBuZXcgVW5pZm9ybTE1KDEpLFxuICAgICAgICBleHBvc3VyZTogbmV3IFVuaWZvcm0xNSgxKSxcbiAgICAgICAgY2xhbXBNYXg6IG5ldyBVbmlmb3JtMTUoMSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE1LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fZ29kX3JheXNfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZS5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXQgbGlnaHRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5saWdodFBvc2l0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxpZ2h0UG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0TGlnaHRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5saWdodFBvc2l0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxpZ2h0UG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2YWx1ZSAtIFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIHNldExpZ2h0UG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmxpZ2h0UG9zaXRpb24udmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kZW5zaXR5LnZhbHVlO1xuICB9XG4gIHNldCBkZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZW5zaXR5LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZW5zaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRlbnNpdHkuXG4gICAqL1xuICBnZXREZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlbnNpdHkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZW5zaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkZW5zaXR5LlxuICAgKi9cbiAgc2V0RGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVjYXkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGVjYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVjYXkudmFsdWU7XG4gIH1cbiAgc2V0IGRlY2F5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWNheS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWNheS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlY2F5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRlY2F5LlxuICAgKi9cbiAgZ2V0RGVjYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVjYXkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlY2F5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVjYXkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGRlY2F5LlxuICAgKi9cbiAgc2V0RGVjYXkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlY2F5LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3ZWlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLndlaWdodC52YWx1ZTtcbiAgfVxuICBzZXQgd2VpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2VpZ2h0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugd2VpZ2h0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHdlaWdodC5cbiAgICovXG4gIGdldFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgd2VpZ2h0LlxuICAgKi9cbiAgc2V0V2VpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGV4cG9zdXJlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGV4cG9zdXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlO1xuICB9XG4gIHNldCBleHBvc3VyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZXhwb3N1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXhwb3N1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleHBvc3VyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBleHBvc3VyZS5cbiAgICovXG4gIGdldEV4cG9zdXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHBvc3VyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGV4cG9zdXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBleHBvc3VyZS5cbiAgICovXG4gIHNldEV4cG9zdXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5leHBvc3VyZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBsaWdodCBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4SW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlO1xuICB9XG4gIHNldCBtYXhJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF4SW50ZW5zaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKi9cbiAgZ2V0TWF4SW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXhpbXVtIGxpZ2h0IGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heEludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBsaWdodCBpbnRlbnNpdHkuXG4gICAqL1xuICBzZXRNYXhJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCk7XG4gIH1cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgdGhpcy5kZWZpbmVzLlNBTVBMRVNfSU5UID0gcy50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lcy5TQU1QTEVTX0ZMT0FUID0gcy50b0ZpeGVkKDEpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYW1wbGVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIGdldFNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2FtcGxlcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2FtcGxlIGNvdW50LlxuICAgKi9cbiAgc2V0U2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuc2FtcGxlcyA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0x1bWluYW5jZU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxNiwgUkVWSVNJT04gYXMgUkVWSVNJT040LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE2LCBVbmlmb3JtIGFzIFVuaWZvcm0xNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvbHVtaW5hbmNlLmZyYWdcbnZhciBsdW1pbmFuY2VfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaWYgVEhSRUVfUkVWSVNJT04gPCAxNDNcXG4jZGVmaW5lIGx1bWluYW5jZSh2KSBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKHYpXFxuI2VuZGlmXFxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxuI2lmZGVmIFJBTkdFXFxudW5pZm9ybSB2ZWMyIHJhbmdlO1xcbiNlbGlmIGRlZmluZWQoVEhSRVNIT0xEKVxcbnVuaWZvcm0gZmxvYXQgdGhyZXNob2xkO3VuaWZvcm0gZmxvYXQgc21vb3RoaW5nO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtmbG9hdCBsPWx1bWluYW5jZSh0ZXhlbC5yZ2IpO1xcbiNpZmRlZiBSQU5HRVxcbmZsb2F0IGxvdz1zdGVwKHJhbmdlLngsbCk7ZmxvYXQgaGlnaD1zdGVwKGwscmFuZ2UueSk7bCo9bG93KmhpZ2g7XFxuI2VsaWYgZGVmaW5lZChUSFJFU0hPTEQpXFxubD1zbW9vdGhzdGVwKHRocmVzaG9sZCx0aHJlc2hvbGQrc21vb3RoaW5nLGwpO1xcbiNlbmRpZlxcbiNpZmRlZiBDT0xPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KHRleGVsLnJnYipsLGwpO1xcbiNlbHNlXFxuZ2xfRnJhZ0NvbG9yPXZlYzQobCk7XFxuI2VuZGlmXFxufVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0x1bWluYW5jZU1hdGVyaWFsLmpzXG52YXIgTHVtaW5hbmNlTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTYge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbG9yT3V0cHV0PWZhbHNlXSAtIERlZmluZXMgd2hldGhlciB0aGUgc2hhZGVyIHNob3VsZCBvdXRwdXQgY29sb3JzIHNjYWxlZCB3aXRoIHRoZWlyIGx1bWluYW5jZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbbHVtaW5hbmNlUmFuZ2VdIC0gSWYgcHJvdmlkZWQsIHRoZSBzaGFkZXIgd2lsbCBtYXNrIG91dCB0ZXhlbHMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNwZWNpZmllZCBsdW1pbmFuY2UgcmFuZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2xvck91dHB1dCA9IGZhbHNlLCBsdW1pbmFuY2VSYW5nZSA9IG51bGwpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkx1bWluYW5jZU1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIFRIUkVFX1JFVklTSU9OOiBSRVZJU0lPTjQucmVwbGFjZSgvXFxEKy9nLCBcIlwiKVxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE2KG51bGwpLFxuICAgICAgICB0aHJlc2hvbGQ6IG5ldyBVbmlmb3JtMTYoMCksXG4gICAgICAgIHNtb290aGluZzogbmV3IFVuaWZvcm0xNigxKSxcbiAgICAgICAgcmFuZ2U6IG5ldyBVbmlmb3JtMTYobnVsbClcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE2LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogbHVtaW5hbmNlX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gICAgdGhpcy5jb2xvck91dHB1dCA9IGNvbG9yT3V0cHV0O1xuICAgIHRoaXMubHVtaW5hbmNlUmFuZ2UgPSBsdW1pbmFuY2VSYW5nZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50aHJlc2hvbGQudmFsdWU7XG4gIH1cbiAgc2V0IHRocmVzaG9sZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNtb290aGluZyA+IDAgfHwgdmFsdWUgPiAwKSB7XG4gICAgICB0aGlzLmRlZmluZXMuVEhSRVNIT0xEID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuVEhSRVNIT0xEO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnRocmVzaG9sZC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIGdldFRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIHNldFRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMudGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIHNtb290aGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzbW9vdGhpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc21vb3RoaW5nLnZhbHVlO1xuICB9XG4gIHNldCBzbW9vdGhpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy50aHJlc2hvbGQgPiAwIHx8IHZhbHVlID4gMCkge1xuICAgICAgdGhpcy5kZWZpbmVzLlRIUkVTSE9MRCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlRIUkVTSE9MRDtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5zbW9vdGhpbmcudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZCBzbW9vdGhpbmcgZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc21vb3RoaW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNtb290aGluZyBmYWN0b3IuXG4gICAqL1xuICBnZXRTbW9vdGhpbmdGYWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc21vb3RoaW5nO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIHNtb290aGluZyBmYWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzbW9vdGhpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNtb290aGluZyBmYWN0b3IuXG4gICAqL1xuICBzZXRTbW9vdGhpbmdGYWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnNtb290aGluZyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgQWRqdXN0IHRoZSB0aHJlc2hvbGQgb3Igc21vb3RoaW5nIGZhY3RvciBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHVzZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aHJlc2hvbGQgPiAwIHx8IHRoaXMuc21vb3RoaW5nID4gMDtcbiAgfVxuICBzZXQgdXNlVGhyZXNob2xkKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvbG9yIG91dHB1dCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBjb2xvck91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLkNPTE9SICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGNvbG9yT3V0cHV0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuQ09MT1IgPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5DT0xPUjtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvbG9yIG91dHB1dCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JPdXRwdXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBjb2xvciBvdXRwdXQgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzQ29sb3JPdXRwdXRFbmFibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JPdXRwdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgY29sb3Igb3V0cHV0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JPdXRwdXQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgY29sb3Igb3V0cHV0IHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0Q29sb3JPdXRwdXRFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvck91dHB1dCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBsdW1pbmFuY2UgbWFza2luZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCB1c2VSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VSYW5nZSAhPT0gbnVsbDtcbiAgfVxuICBzZXQgdXNlUmFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmx1bWluYW5jZVJhbmdlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSByYW5nZS4gU2V0IHRvIG51bGwgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbHVtaW5hbmNlUmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmFuZ2UudmFsdWU7XG4gIH1cbiAgc2V0IGx1bWluYW5jZVJhbmdlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuUkFOR0UgPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5SQU5HRTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5yYW5nZS52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGx1bWluYW5jZSByYW5nZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZVJhbmdlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBsdW1pbmFuY2UgcmFuZ2UuXG4gICAqL1xuICBnZXRMdW1pbmFuY2VSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VSYW5nZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIGx1bWluYW5jZSByYW5nZS4gU2V0IHRvIG51bGwgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZVJhbmdlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgbHVtaW5hbmNlIHJhbmdlLlxuICAgKi9cbiAgc2V0THVtaW5hbmNlUmFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmx1bWluYW5jZVJhbmdlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvTWFza01hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxNywgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxNywgVW5pZm9ybSBhcyBVbmlmb3JtMTcsIFVuc2lnbmVkQnl0ZVR5cGUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL21hc2suZnJhZ1xudmFyIG1hc2tfZGVmYXVsdCA9IFwiI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxuI2lmZGVmIE1BU0tfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG1hc2tUZXh0dXJlO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXNrVGV4dHVyZTtcXG4jZW5kaWZcXG4jaWYgTUFTS19GVU5DVElPTiAhPSAwXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG4jZW5kaWZcXG52YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe1xcbiNpZiBDT0xPUl9DSEFOTkVMID09IDBcXG5mbG9hdCBtYXNrPXRleHR1cmUyRChtYXNrVGV4dHVyZSx2VXYpLnI7XFxuI2VsaWYgQ09MT1JfQ0hBTk5FTCA9PSAxXFxuZmxvYXQgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdlV2KS5nO1xcbiNlbGlmIENPTE9SX0NIQU5ORUwgPT0gMlxcbmZsb2F0IG1hc2s9dGV4dHVyZTJEKG1hc2tUZXh0dXJlLHZVdikuYjtcXG4jZWxzZVxcbmZsb2F0IG1hc2s9dGV4dHVyZTJEKG1hc2tUZXh0dXJlLHZVdikuYTtcXG4jZW5kaWZcXG4jaWYgTUFTS19GVU5DVElPTiA9PSAwXFxuI2lmZGVmIElOVkVSVEVEXFxubWFzaz1zdGVwKG1hc2ssMC4wKTtcXG4jZWxzZVxcbm1hc2s9MS4wLXN0ZXAobWFzaywwLjApO1xcbiNlbmRpZlxcbiNlbHNlXFxubWFzaz1jbGFtcChtYXNrKnN0cmVuZ3RoLDAuMCwxLjApO1xcbiNpZmRlZiBJTlZFUlRFRFxcbm1hc2s9MS4wLW1hc2s7XFxuI2VuZGlmXFxuI2VuZGlmXFxuI2lmIE1BU0tfRlVOQ1RJT04gPT0gM1xcbnZlYzQgdGV4ZWw9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdik7Z2xfRnJhZ0NvbG9yPXZlYzQobWFzayp0ZXhlbC5yZ2IsdGV4ZWwuYSk7XFxuI2VsaWYgTUFTS19GVU5DVElPTiA9PSAyXFxuZ2xfRnJhZ0NvbG9yPXZlYzQobWFzayp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KS5yZ2IsbWFzayk7XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3I9bWFzayp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtcXG4jZW5kaWZcXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvTWFza01hdGVyaWFsLmpzXG52YXIgTWFza01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDE3IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbWFzayBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbbWFza1RleHR1cmVdIC0gVGhlIG1hc2sgdGV4dHVyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hc2tUZXh0dXJlID0gbnVsbCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiTWFza01hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBtYXNrVGV4dHVyZTogbmV3IFVuaWZvcm0xNyhtYXNrVGV4dHVyZSksXG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE3KG51bGwpLFxuICAgICAgICBzdHJlbmd0aDogbmV3IFVuaWZvcm0xNygxKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTcsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBtYXNrX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gICAgdGhpcy5jb2xvckNoYW5uZWwgPSBDb2xvckNoYW5uZWwuUkVEO1xuICAgIHRoaXMubWFza0Z1bmN0aW9uID0gTWFza0Z1bmN0aW9uLkRJU0NBUkQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWFzayB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBtYXNrVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWFza1RleHR1cmUudmFsdWUgPSB2YWx1ZTtcbiAgICBkZWxldGUgdGhpcy5kZWZpbmVzLk1BU0tfUFJFQ0lTSU9OX0hJR0g7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5NQVNLX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXNrIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXNrVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBzZXRNYXNrVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMubWFza1RleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3IgY2hhbm5lbCB0byB1c2UgZm9yIG1hc2tpbmcuIERlZmF1bHQgaXMgYENvbG9yQ2hhbm5lbC5SRURgLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3JDaGFubmVsfVxuICAgKi9cbiAgc2V0IGNvbG9yQ2hhbm5lbCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5DT0xPUl9DSEFOTkVMID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3IgY2hhbm5lbCB0byB1c2UgZm9yIG1hc2tpbmcuIERlZmF1bHQgaXMgYENvbG9yQ2hhbm5lbC5SRURgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JDaGFubmVsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q29sb3JDaGFubmVsfSB2YWx1ZSAtIFRoZSBjaGFubmVsLlxuICAgKi9cbiAgc2V0Q29sb3JDaGFubmVsKHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvckNoYW5uZWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hc2tpbmcgdGVjaG5pcXVlLiBEZWZhdWx0IGlzIGBNYXNrRnVuY3Rpb24uRElTQ0FSRGAuXG4gICAqXG4gICAqIEB0eXBlIHtNYXNrRnVuY3Rpb259XG4gICAqL1xuICBzZXQgbWFza0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk1BU0tfRlVOQ1RJT04gPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXNraW5nIHRlY2huaXF1ZS4gRGVmYXVsdCBpcyBgTWFza0Z1bmN0aW9uLkRJU0NBUkRgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWFza0Z1bmN0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFza0Z1bmN0aW9ufSB2YWx1ZSAtIFRoZSBmdW5jdGlvbi5cbiAgICovXG4gIHNldE1hc2tGdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMubWFza0Z1bmN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXNraW5nIGlzIGludmVydGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLklOVkVSVEVEICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52ZXJ0ZWQgJiYgIXZhbHVlKSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLklOVkVSVEVEO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5JTlZFUlRFRCA9IFwiMVwiO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1hc2tpbmcgaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBtYXNraW5nIGlzIGludmVydGVkLlxuICAgKi9cbiAgaXNJbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZlcnRlZDtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtYXNraW5nIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBtYXNraW5nIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICovXG4gIHNldEludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnRlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBtYXNrIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBJbmRpdmlkdWFsIG1hc2sgdmFsdWVzIHdpbGwgYmUgY2xhbXBlZCB0byBbMC4wLCAxLjBdLiBIYXMgbm8gZWZmZWN0IHdoZW4gdGhlIG1hc2sgZnVuY3Rpb24gaXMgc2V0IHRvIGBESVNDQVJEYC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZTtcbiAgfVxuICBzZXQgc3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWFzayBzdHJlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1hc2sgc3RyZW5ndGguXG4gICAqL1xuICBnZXRTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFzayBzdHJlbmd0aC5cbiAgICpcbiAgICogSGFzIG5vIGVmZmVjdCB3aGVuIHRoZSBtYXNrIGZ1bmN0aW9uIGlzIHNldCB0byBgRElTQ0FSRGAuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWFzayBzdHJlbmd0aC5cbiAgICovXG4gIHNldFN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL091dGxpbmVNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTgsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTgsIFVuaWZvcm0gYXMgVW5pZm9ybTE4LCBWZWN0b3IyIGFzIFZlY3RvcjIxMCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvb3V0bGluZS5mcmFnXG52YXIgb3V0bGluZV9kZWZhdWx0ID0gXCJ1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzIgYzA9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjApLnJnO3ZlYzIgYzE9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpLnJnO3ZlYzIgYzI9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjIpLnJnO3ZlYzIgYzM9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjMpLnJnO2Zsb2F0IGQwPShjMC54LWMxLngpKjAuNTtmbG9hdCBkMT0oYzIueC1jMy54KSowLjU7ZmxvYXQgZD1sZW5ndGgodmVjMihkMCxkMSkpO2Zsb2F0IGEwPW1pbihjMC55LGMxLnkpO2Zsb2F0IGExPW1pbihjMi55LGMzLnkpO2Zsb2F0IHZpc2liaWxpdHlGYWN0b3I9bWluKGEwLGExKTtnbF9GcmFnQ29sb3Iucmc9KDEuMC12aXNpYmlsaXR5RmFjdG9yPjAuMDAxKT92ZWMyKGQsMC4wKTp2ZWMyKDAuMCxkKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9vdXRsaW5lLnZlcnRcbnZhciBvdXRsaW5lX2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXZlYzIodXYueCt0ZXhlbFNpemUueCx1di55KTt2VXYxPXZlYzIodXYueC10ZXhlbFNpemUueCx1di55KTt2VXYyPXZlYzIodXYueCx1di55K3RleGVsU2l6ZS55KTt2VXYzPXZlYzIodXYueCx1di55LXRleGVsU2l6ZS55KTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9PdXRsaW5lTWF0ZXJpYWwuanNcbnZhciBPdXRsaW5lTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTgge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBvdXRsaW5lIG1hdGVyaWFsLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSB0ZXhlbFNpemUgcGFyYW0uXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW3RleGVsU2l6ZV0gLSBUaGUgc2NyZWVuIHRleGVsIHNpemUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXhlbFNpemUgPSBuZXcgVmVjdG9yMjEwKCkpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIk91dGxpbmVNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMTgobnVsbCksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0xOChuZXcgVmVjdG9yMjEwKCkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxOCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IG91dGxpbmVfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogb3V0bGluZV9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCh0ZXhlbFNpemUueCwgdGV4ZWxTaXplLnkpO1xuICAgIHRoaXMudW5pZm9ybXMubWFza1RleHR1cmUgPSB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9TTUFBV2VpZ2h0c01hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxOSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxOSwgVW5pZm9ybSBhcyBVbmlmb3JtMTksIFZlY3RvcjIgYXMgVmVjdG9yMjExIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9zbWFhLXdlaWdodHMuZnJhZ1xudmFyIHNtYWFfd2VpZ2h0c19kZWZhdWx0ID0gXCIjZGVmaW5lIHNhbXBsZUxldmVsWmVyb09mZnNldCh0LCBjb29yZCwgb2Zmc2V0KSB0ZXh0dXJlMkQodCwgY29vcmQgKyBvZmZzZXQgKiB0ZXhlbFNpemUpXFxuI2lmIF9fVkVSU0lPTl9fIDwgMzAwXFxuI2RlZmluZSByb3VuZCh2KSBmbG9vcih2ICsgMC41KVxcbiNlbmRpZlxcbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgYXJlYVRleHR1cmU7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBzZWFyY2hUZXh0dXJlO3VuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzQgdk9mZnNldFszXTt2YXJ5aW5nIHZlYzIgdlBpeENvb3JkO3ZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzIgYyxpbm91dCB2ZWMyIHZhcmlhYmxlLGNvbnN0IGluIHZlYzIgdmFsdWUpe2lmKGMueCl7dmFyaWFibGUueD12YWx1ZS54O31pZihjLnkpe3ZhcmlhYmxlLnk9dmFsdWUueTt9fXZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzQgYyxpbm91dCB2ZWM0IHZhcmlhYmxlLGNvbnN0IGluIHZlYzQgdmFsdWUpe21vdmVjKGMueHksdmFyaWFibGUueHksdmFsdWUueHkpO21vdmVjKGMuencsdmFyaWFibGUuencsdmFsdWUuencpO312ZWMyIGRlY29kZURpYWdCaWxpbmVhckFjY2VzcyhpbiB2ZWMyIGUpe2Uucj1lLnIqYWJzKDUuMCplLnItNS4wKjAuNzUpO3JldHVybiByb3VuZChlKTt9dmVjNCBkZWNvZGVEaWFnQmlsaW5lYXJBY2Nlc3MoaW4gdmVjNCBlKXtlLnJiPWUucmIqYWJzKDUuMCplLnJiLTUuMCowLjc1KTtyZXR1cm4gcm91bmQoZSk7fXZlYzIgc2VhcmNoRGlhZzEoY29uc3QgaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGRpcixvdXQgdmVjMiBlKXt2ZWM0IGNvb3JkPXZlYzQodGV4Q29vcmQsLTEuMCwxLjApO3ZlYzMgdD12ZWMzKHRleGVsU2l6ZSwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKGNvb3JkLno8ZmxvYXQoTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVC0xKSYmY29vcmQudz4wLjkpKXticmVhazt9Y29vcmQueHl6PXQqdmVjMyhkaXIsMS4wKStjb29yZC54eXo7ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmQueHkpLnJnO2Nvb3JkLnc9ZG90KGUsdmVjMigwLjUpKTt9cmV0dXJuIGNvb3JkLnp3O312ZWMyIHNlYXJjaERpYWcyKGNvbnN0IGluIHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gdmVjMiBkaXIsb3V0IHZlYzIgZSl7dmVjNCBjb29yZD12ZWM0KHRleENvb3JkLC0xLjAsMS4wKTtjb29yZC54Kz0wLjI1KnRleGVsU2l6ZS54O3ZlYzMgdD12ZWMzKHRleGVsU2l6ZSwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKGNvb3JkLno8ZmxvYXQoTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVC0xKSYmY29vcmQudz4wLjkpKXticmVhazt9Y29vcmQueHl6PXQqdmVjMyhkaXIsMS4wKStjb29yZC54eXo7ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmQueHkpLnJnO2U9ZGVjb2RlRGlhZ0JpbGluZWFyQWNjZXNzKGUpO2Nvb3JkLnc9ZG90KGUsdmVjMigwLjUpKTt9cmV0dXJuIGNvb3JkLnp3O312ZWMyIGFyZWFEaWFnKGNvbnN0IGluIHZlYzIgZGlzdCxjb25zdCBpbiB2ZWMyIGUsY29uc3QgaW4gZmxvYXQgb2Zmc2V0KXt2ZWMyIHRleENvb3JkPXZlYzIoQVJFQVRFWF9NQVhfRElTVEFOQ0VfRElBRyxBUkVBVEVYX01BWF9ESVNUQU5DRV9ESUFHKSplK2Rpc3Q7dGV4Q29vcmQ9QVJFQVRFWF9QSVhFTF9TSVpFKnRleENvb3JkKzAuNSpBUkVBVEVYX1BJWEVMX1NJWkU7dGV4Q29vcmQueCs9MC41O3RleENvb3JkLnkrPUFSRUFURVhfU1VCVEVYX1NJWkUqb2Zmc2V0O3JldHVybiB0ZXh0dXJlMkQoYXJlYVRleHR1cmUsdGV4Q29vcmQpLnJnO312ZWMyIGNhbGN1bGF0ZURpYWdXZWlnaHRzKGNvbnN0IGluIHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gdmVjMiBlLGNvbnN0IGluIHZlYzQgc3Vic2FtcGxlSW5kaWNlcyl7dmVjMiB3ZWlnaHRzPXZlYzIoMC4wKTt2ZWM0IGQ7dmVjMiBlbmQ7aWYoZS5yPjAuMCl7ZC54ej1zZWFyY2hEaWFnMSh0ZXhDb29yZCx2ZWMyKC0xLjAsMS4wKSxlbmQpO2QueCs9ZmxvYXQoZW5kLnk+MC45KTt9ZWxzZXtkLnh6PXZlYzIoMC4wKTt9ZC55dz1zZWFyY2hEaWFnMSh0ZXhDb29yZCx2ZWMyKDEuMCwtMS4wKSxlbmQpO2lmKGQueCtkLnk+Mi4wKXt2ZWM0IGNvb3Jkcz12ZWM0KC1kLngrMC4yNSxkLngsZC55LC1kLnktMC4yNSkqdGV4ZWxTaXplLnh5eHkrdGV4Q29vcmQueHl4eTt2ZWM0IGM7Yy54eT1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnh5LHZlYzIoLTEsMCkpLnJnO2Muenc9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy56dyx2ZWMyKDEsMCkpLnJnO2MueXh3ej1kZWNvZGVEaWFnQmlsaW5lYXJBY2Nlc3MoYy54eXp3KTt2ZWMyIGNjPXZlYzIoMi4wKSpjLnh6K2MueXc7bW92ZWMoYnZlYzIoc3RlcCgwLjksZC56dykpLGNjLHZlYzIoMC4wKSk7d2VpZ2h0cys9YXJlYURpYWcoZC54eSxjYyxzdWJzYW1wbGVJbmRpY2VzLnopO31kLnh6PXNlYXJjaERpYWcyKHRleENvb3JkLHZlYzIoLTEuMCwtMS4wKSxlbmQpO2lmKHNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZCx2ZWMyKDEsMCkpLnI+MC4wKXtkLnl3PXNlYXJjaERpYWcyKHRleENvb3JkLHZlYzIoMS4wKSxlbmQpO2QueSs9ZmxvYXQoZW5kLnk+MC45KTt9ZWxzZXtkLnl3PXZlYzIoMC4wKTt9aWYoZC54K2QueT4yLjApe3ZlYzQgY29vcmRzPXZlYzQoLWQueCwtZC54LGQueSxkLnkpKnRleGVsU2l6ZS54eXh5K3RleENvb3JkLnh5eHk7dmVjNCBjO2MueD1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnh5LHZlYzIoLTEsMCkpLmc7Yy55PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMueHksdmVjMigwLC0xKSkucjtjLnp3PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMuencsdmVjMigxLDApKS5ncjt2ZWMyIGNjPXZlYzIoMi4wKSpjLnh6K2MueXc7bW92ZWMoYnZlYzIoc3RlcCgwLjksZC56dykpLGNjLHZlYzIoMC4wKSk7d2VpZ2h0cys9YXJlYURpYWcoZC54eSxjYyxzdWJzYW1wbGVJbmRpY2VzLncpLmdyO31yZXR1cm4gd2VpZ2h0czt9ZmxvYXQgc2VhcmNoTGVuZ3RoKGNvbnN0IGluIHZlYzIgZSxjb25zdCBpbiBmbG9hdCBvZmZzZXQpe3ZlYzIgc2NhbGU9U0VBUkNIVEVYX1NJWkUqdmVjMigwLjUsLTEuMCk7dmVjMiBiaWFzPVNFQVJDSFRFWF9TSVpFKnZlYzIob2Zmc2V0LDEuMCk7c2NhbGUrPXZlYzIoLTEuMCwxLjApO2JpYXMrPXZlYzIoMC41LC0wLjUpO3NjYWxlKj0xLjAvU0VBUkNIVEVYX1BBQ0tFRF9TSVpFO2JpYXMqPTEuMC9TRUFSQ0hURVhfUEFDS0VEX1NJWkU7cmV0dXJuIHRleHR1cmUyRChzZWFyY2hUZXh0dXJlLHNjYWxlKmUrYmlhcykucjt9ZmxvYXQgc2VhcmNoWExlZnQoaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDAuMCwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKHRleENvb3JkLng+ZW5kJiZlLmc+MC44MjgxJiZlLnI9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9dmVjMigtMi4wLDAuMCkqdGV4ZWxTaXplK3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUsMC4wKSszLjI1O3JldHVybiB0ZXhlbFNpemUueCpvZmZzZXQrdGV4Q29vcmQueDt9ZmxvYXQgc2VhcmNoWFJpZ2h0KHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gZmxvYXQgZW5kKXt2ZWMyIGU9dmVjMigwLjAsMS4wKTtmb3IoaW50IGk9MDtpPE1BWF9TRUFSQ0hfU1RFUFNfSU5UOysraSl7aWYoISh0ZXhDb29yZC54PGVuZCYmZS5nPjAuODI4MSYmZS5yPT0wLjApKXticmVhazt9ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdGV4Q29vcmQpLnJnO3RleENvb3JkPXZlYzIoMi4wLDAuMCkqdGV4ZWxTaXplLnh5K3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUsMC41KSszLjI1O3JldHVybi10ZXhlbFNpemUueCpvZmZzZXQrdGV4Q29vcmQueDt9ZmxvYXQgc2VhcmNoWVVwKHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gZmxvYXQgZW5kKXt2ZWMyIGU9dmVjMigxLjAsMC4wKTtmb3IoaW50IGk9MDtpPE1BWF9TRUFSQ0hfU1RFUFNfSU5UOysraSl7aWYoISh0ZXhDb29yZC55PmVuZCYmZS5yPjAuODI4MSYmZS5nPT0wLjApKXticmVhazt9ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdGV4Q29vcmQpLnJnO3RleENvb3JkPS12ZWMyKDAuMCwyLjApKnRleGVsU2l6ZS54eSt0ZXhDb29yZDt9ZmxvYXQgb2Zmc2V0PS0oMjU1LjAvMTI3LjApKnNlYXJjaExlbmd0aChlLmdyLDAuMCkrMy4yNTtyZXR1cm4gdGV4ZWxTaXplLnkqb2Zmc2V0K3RleENvb3JkLnk7fWZsb2F0IHNlYXJjaFlEb3duKHZlYzIgdGV4Q29vcmQsY29uc3QgaW4gZmxvYXQgZW5kKXt2ZWMyIGU9dmVjMigxLjAsMC4wKTtmb3IoaW50IGk9MDtpPE1BWF9TRUFSQ0hfU1RFUFNfSU5UO2krKyl7aWYoISh0ZXhDb29yZC55PGVuZCYmZS5yPjAuODI4MSYmZS5nPT0wLjApKXticmVhazt9ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdGV4Q29vcmQpLnJnO3RleENvb3JkPXZlYzIoMC4wLDIuMCkqdGV4ZWxTaXplLnh5K3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUuZ3IsMC41KSszLjI1O3JldHVybi10ZXhlbFNpemUueSpvZmZzZXQrdGV4Q29vcmQueTt9dmVjMiBhcmVhKGNvbnN0IGluIHZlYzIgZGlzdCxjb25zdCBpbiBmbG9hdCBlMSxjb25zdCBpbiBmbG9hdCBlMixjb25zdCBpbiBmbG9hdCBvZmZzZXQpe3ZlYzIgdGV4Q29vcmQ9dmVjMihBUkVBVEVYX01BWF9ESVNUQU5DRSkqcm91bmQoNC4wKnZlYzIoZTEsZTIpKStkaXN0O3RleENvb3JkPUFSRUFURVhfUElYRUxfU0laRSp0ZXhDb29yZCswLjUqQVJFQVRFWF9QSVhFTF9TSVpFO3RleENvb3JkLnk9QVJFQVRFWF9TVUJURVhfU0laRSpvZmZzZXQrdGV4Q29vcmQueTtyZXR1cm4gdGV4dHVyZTJEKGFyZWFUZXh0dXJlLHRleENvb3JkKS5yZzt9dm9pZCBkZXRlY3RIb3Jpem9udGFsQ29ybmVyUGF0dGVybihpbm91dCB2ZWMyIHdlaWdodHMsY29uc3QgaW4gdmVjNCB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGQpe1xcbiNpZiAhZGVmaW5lZChESVNBQkxFX0NPUk5FUl9ERVRFQ1RJT04pXFxudmVjMiBsZWZ0UmlnaHQ9c3RlcChkLnh5LGQueXgpO3ZlYzIgcm91bmRpbmc9KDEuMC1DT1JORVJfUk9VTkRJTkdfTk9STSkqbGVmdFJpZ2h0O3JvdW5kaW5nLz1sZWZ0UmlnaHQueCtsZWZ0UmlnaHQueTt2ZWMyIGZhY3Rvcj12ZWMyKDEuMCk7ZmFjdG9yLngtPXJvdW5kaW5nLngqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnh5LHZlYzIoMCwxKSkucjtmYWN0b3IueC09cm91bmRpbmcueSpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQuencsdmVjMigxLDEpKS5yO2ZhY3Rvci55LT1yb3VuZGluZy54KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC54eSx2ZWMyKDAsLTIpKS5yO2ZhY3Rvci55LT1yb3VuZGluZy55KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC56dyx2ZWMyKDEsLTIpKS5yO3dlaWdodHMqPWNsYW1wKGZhY3RvciwwLjAsMS4wKTtcXG4jZW5kaWZcXG59dm9pZCBkZXRlY3RWZXJ0aWNhbENvcm5lclBhdHRlcm4oaW5vdXQgdmVjMiB3ZWlnaHRzLGNvbnN0IGluIHZlYzQgdGV4Q29vcmQsY29uc3QgaW4gdmVjMiBkKXtcXG4jaWYgIWRlZmluZWQoRElTQUJMRV9DT1JORVJfREVURUNUSU9OKVxcbnZlYzIgbGVmdFJpZ2h0PXN0ZXAoZC54eSxkLnl4KTt2ZWMyIHJvdW5kaW5nPSgxLjAtQ09STkVSX1JPVU5ESU5HX05PUk0pKmxlZnRSaWdodDtyb3VuZGluZy89bGVmdFJpZ2h0LngrbGVmdFJpZ2h0Lnk7dmVjMiBmYWN0b3I9dmVjMigxLjApO2ZhY3Rvci54LT1yb3VuZGluZy54KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC54eSx2ZWMyKDEsMCkpLmc7ZmFjdG9yLngtPXJvdW5kaW5nLnkqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnp3LHZlYzIoMSwxKSkuZztmYWN0b3IueS09cm91bmRpbmcueCpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQueHksdmVjMigtMiwwKSkuZztmYWN0b3IueS09cm91bmRpbmcueSpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQuencsdmVjMigtMiwxKSkuZzt3ZWlnaHRzKj1jbGFtcChmYWN0b3IsMC4wLDEuMCk7XFxuI2VuZGlmXFxufXZvaWQgbWFpbigpe3ZlYzQgd2VpZ2h0cz12ZWM0KDAuMCk7dmVjNCBzdWJzYW1wbGVJbmRpY2VzPXZlYzQoMC4wKTt2ZWMyIGU9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikucmc7aWYoZS5nPjAuMCl7XFxuI2lmICFkZWZpbmVkKERJU0FCTEVfRElBR19ERVRFQ1RJT04pXFxud2VpZ2h0cy5yZz1jYWxjdWxhdGVEaWFnV2VpZ2h0cyh2VXYsZSxzdWJzYW1wbGVJbmRpY2VzKTtpZih3ZWlnaHRzLnI9PS13ZWlnaHRzLmcpe1xcbiNlbmRpZlxcbnZlYzIgZDt2ZWMzIGNvb3Jkcztjb29yZHMueD1zZWFyY2hYTGVmdCh2T2Zmc2V0WzBdLnh5LHZPZmZzZXRbMl0ueCk7Y29vcmRzLnk9dk9mZnNldFsxXS55O2QueD1jb29yZHMueDtmbG9hdCBlMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzLnh5KS5yO2Nvb3Jkcy56PXNlYXJjaFhSaWdodCh2T2Zmc2V0WzBdLnp3LHZPZmZzZXRbMl0ueSk7ZC55PWNvb3Jkcy56O2Q9cm91bmQocmVzb2x1dGlvbi54eCpkKy12UGl4Q29vcmQueHgpO3ZlYzIgc3FydEQ9c3FydChhYnMoZCkpO2Zsb2F0IGUyPXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMuenksdmVjMigxLDApKS5yO3dlaWdodHMucmc9YXJlYShzcXJ0RCxlMSxlMixzdWJzYW1wbGVJbmRpY2VzLnkpO2Nvb3Jkcy55PXZVdi55O2RldGVjdEhvcml6b250YWxDb3JuZXJQYXR0ZXJuKHdlaWdodHMucmcsY29vcmRzLnh5enksZCk7XFxuI2lmICFkZWZpbmVkKERJU0FCTEVfRElBR19ERVRFQ1RJT04pXFxufWVsc2V7ZS5yPTAuMDt9XFxuI2VuZGlmXFxufWlmKGUucj4wLjApe3ZlYzIgZDt2ZWMzIGNvb3Jkcztjb29yZHMueT1zZWFyY2hZVXAodk9mZnNldFsxXS54eSx2T2Zmc2V0WzJdLnopO2Nvb3Jkcy54PXZPZmZzZXRbMF0ueDtkLng9Y29vcmRzLnk7ZmxvYXQgZTE9dGV4dHVyZTJEKGlucHV0QnVmZmVyLGNvb3Jkcy54eSkuZztjb29yZHMuej1zZWFyY2hZRG93bih2T2Zmc2V0WzFdLnp3LHZPZmZzZXRbMl0udyk7ZC55PWNvb3Jkcy56O2Q9cm91bmQocmVzb2x1dGlvbi55eSpkLXZQaXhDb29yZC55eSk7dmVjMiBzcXJ0RD1zcXJ0KGFicyhkKSk7ZmxvYXQgZTI9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy54eix2ZWMyKDAsMSkpLmc7d2VpZ2h0cy5iYT1hcmVhKHNxcnRELGUxLGUyLHN1YnNhbXBsZUluZGljZXMueCk7Y29vcmRzLng9dlV2Lng7ZGV0ZWN0VmVydGljYWxDb3JuZXJQYXR0ZXJuKHdlaWdodHMuYmEsY29vcmRzLnh5eHosZCk7fWdsX0ZyYWdDb2xvcj13ZWlnaHRzO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL3NtYWEtd2VpZ2h0cy52ZXJ0XG52YXIgc21hYV93ZWlnaHRzX2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gdmVjMiByZXNvbHV0aW9uO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWM0IHZPZmZzZXRbM107dmFyeWluZyB2ZWMyIHZQaXhDb29yZDt2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTt2UGl4Q29vcmQ9dlV2KnJlc29sdXRpb247dk9mZnNldFswXT12VXYueHl4eSt0ZXhlbFNpemUueHl4eSp2ZWM0KC0wLjI1LC0wLjEyNSwxLjI1LC0wLjEyNSk7dk9mZnNldFsxXT12VXYueHl4eSt0ZXhlbFNpemUueHl4eSp2ZWM0KC0wLjEyNSwtMC4yNSwtMC4xMjUsMS4yNSk7dk9mZnNldFsyXT12ZWM0KHZPZmZzZXRbMF0ueHosdk9mZnNldFsxXS55dykrdmVjNCgtMi4wLDIuMCwtMi4wLDIuMCkqdGV4ZWxTaXplLnh4eXkqTUFYX1NFQVJDSF9TVEVQU19GTE9BVDtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9TTUFBV2VpZ2h0c01hdGVyaWFsLmpzXG52YXIgU01BQVdlaWdodHNNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxOSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNNQUEgd2VpZ2h0cyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbdGV4ZWxTaXplXSAtIFRoZSBhYnNvbHV0ZSBzY3JlZW4gdGV4ZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbcmVzb2x1dGlvbl0gLSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyMTEoKSwgcmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyMTEoKSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiU01BQVdlaWdodHNNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICAvLyBDb25maWd1cmFibGUgc2V0dGluZ3M6XG4gICAgICAgIE1BWF9TRUFSQ0hfU1RFUFNfSU5UOiBcIjE2XCIsXG4gICAgICAgIE1BWF9TRUFSQ0hfU1RFUFNfRkxPQVQ6IFwiMTYuMFwiLFxuICAgICAgICBNQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5UOiBcIjhcIixcbiAgICAgICAgTUFYX1NFQVJDSF9TVEVQU19ESUFHX0ZMT0FUOiBcIjguMFwiLFxuICAgICAgICBDT1JORVJfUk9VTkRJTkc6IFwiMjVcIixcbiAgICAgICAgQ09STkVSX1JPVU5ESU5HX05PUk06IFwiMC4yNVwiLFxuICAgICAgICAvLyBOb24tY29uZmlndXJhYmxlIHNldHRpbmdzOlxuICAgICAgICBBUkVBVEVYX01BWF9ESVNUQU5DRTogXCIxNi4wXCIsXG4gICAgICAgIEFSRUFURVhfTUFYX0RJU1RBTkNFX0RJQUc6IFwiMjAuMFwiLFxuICAgICAgICBBUkVBVEVYX1BJWEVMX1NJWkU6IFwiKDEuMCAvIHZlYzIoMTYwLjAsIDU2MC4wKSlcIixcbiAgICAgICAgQVJFQVRFWF9TVUJURVhfU0laRTogXCIoMS4wIC8gNy4wKVwiLFxuICAgICAgICBTRUFSQ0hURVhfU0laRTogXCJ2ZWMyKDY2LjAsIDMzLjApXCIsXG4gICAgICAgIFNFQVJDSFRFWF9QQUNLRURfU0laRTogXCJ2ZWMyKDY0LjAsIDE2LjApXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xOShudWxsKSxcbiAgICAgICAgc2VhcmNoVGV4dHVyZTogbmV3IFVuaWZvcm0xOShudWxsKSxcbiAgICAgICAgYXJlYVRleHR1cmU6IG5ldyBVbmlmb3JtMTkobnVsbCksXG4gICAgICAgIHJlc29sdXRpb246IG5ldyBVbmlmb3JtMTkocmVzb2x1dGlvbiksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0xOSh0ZXhlbFNpemUpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxOSxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IHNtYWFfd2VpZ2h0c19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBzbWFhX3dlaWdodHNfZGVmYXVsdDJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzZWFyY2ggbG9va3VwIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHNlYXJjaFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2VhcmNoVGV4dHVyZS52YWx1ZTtcbiAgfVxuICBzZXQgc2VhcmNoVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc2VhcmNoVGV4dHVyZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYXJlYSBsb29rdXAgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgYXJlYVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYXJlYVRleHR1cmUudmFsdWU7XG4gIH1cbiAgc2V0IGFyZWFUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5hcmVhVGV4dHVyZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWFyY2ggYW5kIGFyZWEgbG9va3VwIHRleHR1cmVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VhcmNoVGV4dHVyZSBhbmQgYXJlYVRleHR1cmUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBzZWFyY2ggLSBUaGUgc2VhcmNoIGxvb2t1cCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGFyZWEgLSBUaGUgYXJlYSBsb29rdXAgdGV4dHVyZS5cbiAgICovXG4gIHNldExvb2t1cFRleHR1cmVzKHNlYXJjaCwgYXJlYTIpIHtcbiAgICB0aGlzLnNlYXJjaFRleHR1cmUgPSBzZWFyY2g7XG4gICAgdGhpcy5hcmVhVGV4dHVyZSA9IGFyZWEyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2Ygc3RlcHMgcGVyZm9ybWVkIGluIHRoZSBob3Jpem9udGFsL3ZlcnRpY2FsIHBhdHRlcm4gc2VhcmNoZXMsIGF0IGVhY2ggc2lkZSBvZiB0aGUgcGl4ZWwuXG4gICAqIFJhbmdlOiBbMCwgMTEyXS5cbiAgICpcbiAgICogSW4gbnVtYmVyIG9mIHBpeGVscywgaXQncyBhY3R1YWxseSB0aGUgZG91YmxlLiBTbyB0aGUgbWF4aW11bSBsaW5lIGxlbmd0aCBwZXJmZWN0bHkgaGFuZGxlZCBieSwgZm9yIGV4YW1wbGUgMTYsIGlzXG4gICAqIDY0IChwZXJmZWN0bHkgbWVhbnMgdGhhdCBsb25nZXIgbGluZXMgd29uJ3QgbG9vayBhcyBnb29kLCBidXQgYXJlIHN0aWxsIGFudGlhbGlhc2VkKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBvcnRob2dvbmFsU2VhcmNoU3RlcHMoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19JTlQpO1xuICB9XG4gIHNldCBvcnRob2dvbmFsU2VhcmNoU3RlcHModmFsdWUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxMTIpO1xuICAgIHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0lOVCA9IHMudG9GaXhlZChcIjBcIik7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfRkxPQVQgPSBzLnRvRml4ZWQoXCIxXCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBzdGVwcyBwZXJmb3JtZWQgaW4gdGhlIGhvcml6b250YWwvdmVydGljYWwgcGF0dGVybiBzZWFyY2hlcywgYXQgZWFjaCBzaWRlIG9mIHRoZSBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9ydGhvZ29uYWxTZWFyY2hTdGVwcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2VhcmNoIHN0ZXBzLiBSYW5nZTogWzAsIDExMl0uXG4gICAqL1xuICBzZXRPcnRob2dvbmFsU2VhcmNoU3RlcHModmFsdWUpIHtcbiAgICB0aGlzLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBzdGVwcyBwZXJmb3JtZWQgaW4gdGhlIGRpYWdvbmFsIHBhdHRlcm4gc2VhcmNoZXMsIGF0IGVhY2ggc2lkZSBvZiB0aGUgcGl4ZWwuIFRoaXMgc2VhcmNoXG4gICAqIGp1bXBzIG9uZSBwaXhlbCBhdCBhIHRpbWUuIFJhbmdlOiBbMCwgMjBdLlxuICAgKlxuICAgKiBPbiBoaWdoLWVuZCBtYWNoaW5lcyB0aGlzIHNlYXJjaCBpcyBjaGVhcCAoYmV0d2VlbiAwLjh4IGFuZCAwLjl4IHNsb3dlciBmb3IgMTYgc3RlcHMpLCBidXQgaXQgY2FuIGhhdmUgYVxuICAgKiBzaWduaWZpY2FudCBpbXBhY3Qgb24gb2xkZXIgbWFjaGluZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGlhZ29uYWxTZWFyY2hTdGVwcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5UKTtcbiAgfVxuICBzZXQgZGlhZ29uYWxTZWFyY2hTdGVwcyh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDIwKTtcbiAgICB0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVCA9IHMudG9GaXhlZChcIjBcIik7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfRElBR19GTE9BVCA9IHMudG9GaXhlZChcIjFcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbWF4aW11bSBzdGVwcyBwZXJmb3JtZWQgaW4gdGhlIGRpYWdvbmFsIHBhdHRlcm4gc2VhcmNoZXMsIGF0IGVhY2ggc2lkZSBvZiB0aGUgcGl4ZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkaWFnb25hbFNlYXJjaFN0ZXBzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzZWFyY2ggc3RlcHMuIFJhbmdlOiBbMCwgMjBdLlxuICAgKi9cbiAgc2V0RGlhZ29uYWxTZWFyY2hTdGVwcyh2YWx1ZSkge1xuICAgIHRoaXMuZGlhZ29uYWxTZWFyY2hTdGVwcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaWFnb25hbCBwYXR0ZXJuIGRldGVjdGlvbiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkaWFnb25hbERldGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLkRJU0FCTEVfRElBR19ERVRFQ1RJT04gPT09IHZvaWQgMDtcbiAgfVxuICBzZXQgZGlhZ29uYWxEZXRlY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuRElTQUJMRV9ESUFHX0RFVEVDVElPTjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZpbmVzLkRJU0FCTEVfRElBR19ERVRFQ1RJT04gPSBcIjFcIjtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpYWdvbmFsIHBhdHRlcm4gZGV0ZWN0aW9uIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkaWFnb25hbERldGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGRpYWdvbmFsIHBhdHRlcm4gZGV0ZWN0aW9uIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc0RpYWdvbmFsRGV0ZWN0aW9uRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaWFnb25hbERldGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBkaWFnb25hbCBwYXR0ZXJuIGRldGVjdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRpYWdvbmFsRGV0ZWN0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIGRpYWdvbmFsIHBhdHRlcm4gZGV0ZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGlhZ29uYWxEZXRlY3Rpb25FbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5kaWFnb25hbERldGVjdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgaG93IG11Y2ggc2hhcnAgY29ybmVycyB3aWxsIGJlIHJvdW5kZWQuIFJhbmdlOiBbMCwgMTAwXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb3JuZXJSb3VuZGluZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5DT1JORVJfUk9VTkRJTkcpO1xuICB9XG4gIHNldCBjb3JuZXJSb3VuZGluZyh2YWx1ZSkge1xuICAgIGNvbnN0IHIgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEwMCk7XG4gICAgdGhpcy5kZWZpbmVzLkNPUk5FUl9ST1VORElORyA9IHIudG9GaXhlZChcIjRcIik7XG4gICAgdGhpcy5kZWZpbmVzLkNPUk5FUl9ST1VORElOR19OT1JNID0gKHIgLyAxMDApLnRvRml4ZWQoXCI0XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgaG93IG11Y2ggc2hhcnAgY29ybmVycyB3aWxsIGJlIHJvdW5kZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3JuZXJSb3VuZGluZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgY29ybmVyIHJvdW5kaW5nIGFtb3VudC4gUmFuZ2U6IFswLCAxMDBdLlxuICAgKi9cbiAgc2V0Q29ybmVyUm91bmRpbmcodmFsdWUpIHtcbiAgICB0aGlzLmNvcm5lclJvdW5kaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvcm5lciBkZXRlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb3JuZXJEZXRlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5ESVNBQkxFX0NPUk5FUl9ERVRFQ1RJT04gPT09IHZvaWQgMDtcbiAgfVxuICBzZXQgY29ybmVyRGV0ZWN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkRJU0FCTEVfQ09STkVSX0RFVEVDVElPTjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZpbmVzLkRJU0FCTEVfQ09STkVSX0RFVEVDVElPTiA9IFwiMVwiO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgY29ybmVyIHJvdW5kaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3JuZXJEZXRlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBjb3JuZXIgcm91bmRpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzQ29ybmVyUm91bmRpbmdFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvcm5lckRldGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBjb3JuZXIgcm91bmRpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3JuZXJEZXRlY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgY29ybmVyIHJvdW5kaW5nIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0Q29ybmVyUm91bmRpbmdFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5jb3JuZXJEZXRlY3Rpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICB1bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gICAgdW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvU1NBT01hdGVyaWFsLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzcsIE1hdHJpeDQsIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzIwLCBQZXJzcGVjdGl2ZUNhbWVyYSBhcyBQZXJzcGVjdGl2ZUNhbWVyYTYsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMjAsIFVuaWZvcm0gYXMgVW5pZm9ybTIwLCBWZWN0b3IyIGFzIFZlY3RvcjIxMiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvc3Nhby5mcmFnXG52YXIgc3Nhb19kZWZhdWx0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpZmRlZiBOT1JNQUxfREVQVEhcXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbm9ybWFsRGVwdGhCdWZmZXI7XFxuI2VuZGlmXFxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe3JldHVybiB0ZXh0dXJlMkQobm9ybWFsRGVwdGhCdWZmZXIsdXYpLmE7fVxcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBub3JtYWxCdWZmZXI7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XFxuI2VsaWYgZGVmaW5lZChHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSClcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XFxuI2VuZGlmXFxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XFxuI2Vsc2VcXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG5vaXNlVGV4dHVyZTt1bmlmb3JtIG1hdDQgaW52ZXJzZVByb2plY3Rpb25NYXRyaXg7dW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7dW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIHZlYzIgY2FtZXJhTmVhckZhcjt1bmlmb3JtIGZsb2F0IGludGVuc2l0eTt1bmlmb3JtIGZsb2F0IG1pblJhZGl1c1NjYWxlO3VuaWZvcm0gZmxvYXQgZmFkZTt1bmlmb3JtIGZsb2F0IGJpYXM7dW5pZm9ybSB2ZWMyIGRpc3RhbmNlQ3V0b2ZmO3VuaWZvcm0gdmVjMiBwcm94aW1pdHlDdXRvZmY7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2MjtmbG9hdCBnZXRWaWV3Wihjb25zdCBpbiBmbG9hdCBkZXB0aCl7XFxuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxcbnJldHVybiBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZWxzZVxcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XFxuI2VuZGlmXFxufXZlYzMgZ2V0Vmlld1Bvc2l0aW9uKGNvbnN0IGluIHZlYzIgc2NyZWVuUG9zaXRpb24sY29uc3QgaW4gZmxvYXQgZGVwdGgsY29uc3QgaW4gZmxvYXQgdmlld1ope3ZlYzQgY2xpcFBvc2l0aW9uPXZlYzQodmVjMyhzY3JlZW5Qb3NpdGlvbixkZXB0aCkqMi4wLTEuMCwxLjApO2Zsb2F0IGNsaXBXPXByb2plY3Rpb25NYXRyaXhbMl1bM10qdmlld1orcHJvamVjdGlvbk1hdHJpeFszXVszXTtjbGlwUG9zaXRpb24qPWNsaXBXO3JldHVybihpbnZlcnNlUHJvamVjdGlvbk1hdHJpeCpjbGlwUG9zaXRpb24pLnh5ejt9ZmxvYXQgZ2V0QW1iaWVudE9jY2x1c2lvbihjb25zdCBpbiB2ZWMzIHAsY29uc3QgaW4gdmVjMyBuLGNvbnN0IGluIGZsb2F0IGRlcHRoLGNvbnN0IGluIHZlYzIgdXYpe2Zsb2F0IHJhZGl1c1NjYWxlPTEuMC1zbW9vdGhzdGVwKDAuMCxkaXN0YW5jZUN1dG9mZi55LGRlcHRoKTtyYWRpdXNTY2FsZT1yYWRpdXNTY2FsZSooMS4wLW1pblJhZGl1c1NjYWxlKSttaW5SYWRpdXNTY2FsZTtmbG9hdCByYWRpdXM9UkFESVVTKnJhZGl1c1NjYWxlO2Zsb2F0IG5vaXNlPXRleHR1cmUyRChub2lzZVRleHR1cmUsdlV2MikucjtmbG9hdCBiYXNlQW5nbGU9bm9pc2UqUEkyO2Zsb2F0IHJpbmdzPVNQSVJBTF9UVVJOUypQSTI7ZmxvYXQgb2NjbHVzaW9uPTAuMDtpbnQgdGFwcz0wO2ZvcihpbnQgaT0wO2k8U0FNUExFU19JTlQ7KytpKXtmbG9hdCBhbHBoYT0oZmxvYXQoaSkrMC41KSpJTlZfU0FNUExFU19GTE9BVDtmbG9hdCBhbmdsZT1hbHBoYSpyaW5ncytiYXNlQW5nbGU7dmVjMiByb3RhdGlvbj12ZWMyKGNvcyhhbmdsZSksc2luKGFuZ2xlKSk7dmVjMiBjb29yZHM9YWxwaGEqcmFkaXVzKnJvdGF0aW9uKnRleGVsU2l6ZSt1djtpZihjb29yZHMuczwwLjB8fGNvb3Jkcy5zPjEuMHx8Y29vcmRzLnQ8MC4wfHxjb29yZHMudD4xLjApe2NvbnRpbnVlO31mbG9hdCBzYW1wbGVEZXB0aD1yZWFkRGVwdGgoY29vcmRzKTtmbG9hdCB2aWV3Wj1nZXRWaWV3WihzYW1wbGVEZXB0aCk7XFxuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxcbmZsb2F0IGxpbmVhclNhbXBsZURlcHRoPXZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WixjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZWxzZVxcbmZsb2F0IGxpbmVhclNhbXBsZURlcHRoPXNhbXBsZURlcHRoO1xcbiNlbmRpZlxcbmZsb2F0IHByb3hpbWl0eT1hYnMoZGVwdGgtbGluZWFyU2FtcGxlRGVwdGgpO2lmKHByb3hpbWl0eTxwcm94aW1pdHlDdXRvZmYueSl7ZmxvYXQgZmFsbG9mZj0xLjAtc21vb3Roc3RlcChwcm94aW1pdHlDdXRvZmYueCxwcm94aW1pdHlDdXRvZmYueSxwcm94aW1pdHkpO3ZlYzMgUT1nZXRWaWV3UG9zaXRpb24oY29vcmRzLHNhbXBsZURlcHRoLHZpZXdaKTt2ZWMzIHY9US1wO2Zsb2F0IHZ2PWRvdCh2LHYpO2Zsb2F0IHZuPWRvdCh2LG4pLWJpYXM7ZmxvYXQgZj1tYXgoUkFESVVTX1NRLXZ2LDAuMCkvUkFESVVTX1NRO29jY2x1c2lvbis9KGYqZipmKm1heCh2bi8oZmFkZSt2diksMC4wKSkqZmFsbG9mZjt9Kyt0YXBzO31yZXR1cm4gb2NjbHVzaW9uLyg0LjAqbWF4KGZsb2F0KHRhcHMpLDEuMCkpO312b2lkIG1haW4oKXtcXG4jaWZkZWYgTk9STUFMX0RFUFRIXFxudmVjNCBub3JtYWxEZXB0aD10ZXh0dXJlMkQobm9ybWFsRGVwdGhCdWZmZXIsdlV2KTtcXG4jZWxzZVxcbnZlYzQgbm9ybWFsRGVwdGg9dmVjNCh0ZXh0dXJlMkQobm9ybWFsQnVmZmVyLHZVdikueHl6LHJlYWREZXB0aCh2VXYpKTtcXG4jZW5kaWZcXG5mbG9hdCBhbz0wLjA7ZmxvYXQgZGVwdGg9bm9ybWFsRGVwdGguYTtmbG9hdCB2aWV3Wj1nZXRWaWV3WihkZXB0aCk7XFxuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxcbmZsb2F0IGxpbmVhckRlcHRoPXZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WixjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZWxzZVxcbmZsb2F0IGxpbmVhckRlcHRoPWRlcHRoO1xcbiNlbmRpZlxcbmlmKGxpbmVhckRlcHRoPGRpc3RhbmNlQ3V0b2ZmLnkpe3ZlYzMgdmlld1Bvc2l0aW9uPWdldFZpZXdQb3NpdGlvbih2VXYsZGVwdGgsdmlld1opO3ZlYzMgdmlld05vcm1hbD11bnBhY2tSR0JUb05vcm1hbChub3JtYWxEZXB0aC5yZ2IpO2FvKz1nZXRBbWJpZW50T2NjbHVzaW9uKHZpZXdQb3NpdGlvbix2aWV3Tm9ybWFsLGxpbmVhckRlcHRoLHZVdik7ZmxvYXQgZD1zbW9vdGhzdGVwKGRpc3RhbmNlQ3V0b2ZmLngsZGlzdGFuY2VDdXRvZmYueSxsaW5lYXJEZXB0aCk7YW89bWl4KGFvLDAuMCxkKTtcXG4jaWZkZWYgTEVHQUNZX0lOVEVOU0lUWVxcbmFvPWNsYW1wKDEuMC1wb3coMS4wLWFvLGFicyhpbnRlbnNpdHkpKSwwLjAsMS4wKTtcXG4jZW5kaWZcXG59Z2xfRnJhZ0NvbG9yLnI9YW87fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvc3Nhby52ZXJ0XG52YXIgc3Nhb19kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIG5vaXNlU2NhbGU7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2Mjt2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYyPXZVdipub2lzZVNjYWxlO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1NTQU9NYXRlcmlhbC5qc1xudmFyIFNTQU9NYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwyMCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNTQU8gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiU1NBT01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIFNBTVBMRVNfSU5UOiBcIjBcIixcbiAgICAgICAgSU5WX1NBTVBMRVNfRkxPQVQ6IFwiMC4wXCIsXG4gICAgICAgIFNQSVJBTF9UVVJOUzogXCIwLjBcIixcbiAgICAgICAgUkFESVVTOiBcIjEuMFwiLFxuICAgICAgICBSQURJVVNfU1E6IFwiMS4wXCIsXG4gICAgICAgIERJU1RBTkNFX1NDQUxJTkc6IFwiMVwiLFxuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTIwKG51bGwpLFxuICAgICAgICBub3JtYWxCdWZmZXI6IG5ldyBVbmlmb3JtMjAobnVsbCksXG4gICAgICAgIG5vcm1hbERlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTIwKG51bGwpLFxuICAgICAgICBub2lzZVRleHR1cmU6IG5ldyBVbmlmb3JtMjAobnVsbCksXG4gICAgICAgIGludmVyc2VQcm9qZWN0aW9uTWF0cml4OiBuZXcgVW5pZm9ybTIwKG5ldyBNYXRyaXg0KCkpLFxuICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiBuZXcgVW5pZm9ybTIwKG5ldyBNYXRyaXg0KCkpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMjAobmV3IFZlY3RvcjIxMigpKSxcbiAgICAgICAgY2FtZXJhTmVhckZhcjogbmV3IFVuaWZvcm0yMChuZXcgVmVjdG9yMjEyKCkpLFxuICAgICAgICBkaXN0YW5jZUN1dG9mZjogbmV3IFVuaWZvcm0yMChuZXcgVmVjdG9yMjEyKCkpLFxuICAgICAgICBwcm94aW1pdHlDdXRvZmY6IG5ldyBVbmlmb3JtMjAobmV3IFZlY3RvcjIxMigpKSxcbiAgICAgICAgbm9pc2VTY2FsZTogbmV3IFVuaWZvcm0yMChuZXcgVmVjdG9yMjEyKCkpLFxuICAgICAgICBtaW5SYWRpdXNTY2FsZTogbmV3IFVuaWZvcm0yMCgwLjMzKSxcbiAgICAgICAgaW50ZW5zaXR5OiBuZXcgVW5pZm9ybTIwKDEpLFxuICAgICAgICBmYWRlOiBuZXcgVW5pZm9ybTIwKDAuMDEpLFxuICAgICAgICBiaWFzOiBuZXcgVW5pZm9ybTIwKDApXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcyMCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IHNzYW9fZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogc3Nhb19kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIxMigpO1xuICAgIHRoaXMuciA9IDE7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IG5lYXIgcGxhbmUgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBuZWFyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUueDtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZmFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZmFyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUueTtcbiAgfVxuICAvKipcbiAgICogQSBjb21iaW5lZCBub3JtYWwtZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub3JtYWxEZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubm9ybWFsRGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5OT1JNQUxfREVQVEggPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5OT1JNQUxfREVQVEg7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21iaW5lZCBub3JtYWwtZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugbm9ybWFsRGVwdGhCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldE5vcm1hbERlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5ub3JtYWxEZXB0aEJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9ybWFsIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbm9ybWFsQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub3JtYWxCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbm9ybWFsIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5vcm1hbEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0Tm9ybWFsQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub3JtYWxCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzcpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9pc2UgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbm9pc2VUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub2lzZVRleHR1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbm9pc2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5vaXNlVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIHNldE5vaXNlVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubm9pc2VUZXh0dXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzYW1wbGUgY291bnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCk7XG4gIH1cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuU0FNUExFU19JTlQgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lcy5JTlZfU0FNUExFU19GTE9BVCA9ICgxIC8gdmFsdWUpLnRvRml4ZWQoOSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBvY2NsdXNpb24gc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYW1wbGVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIGdldFNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYW1vdW50IG9mIG9jY2x1c2lvbiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhbXBsZXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIHNldFNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLnNhbXBsZXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNhbXBsaW5nIHNwaXJhbCByaW5nIGNvdW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJpbmdzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLlNQSVJBTF9UVVJOUyk7XG4gIH1cbiAgc2V0IHJpbmdzKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLlNQSVJBTF9UVVJOUyA9IHZhbHVlLnRvRml4ZWQoMSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBzcGlyYWwgdHVybnMgaW4gdGhlIG9jY2x1c2lvbiBzYW1wbGluZyBwYXR0ZXJuLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmluZ3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmFkaXVzLlxuICAgKi9cbiAgZ2V0UmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmluZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFtb3VudCBvZiBzcGlyYWwgdHVybnMgaW4gdGhlIG9jY2x1c2lvbiBzYW1wbGluZyBwYXR0ZXJuLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJhZGl1cy5cbiAgICovXG4gIHNldFJpbmdzKHZhbHVlKSB7XG4gICAgdGhpcy5yaW5ncyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgU1NBT0VmZmVjdC5pbnRlbnNpdHkgaW5zdGVhZC5cbiAgICovXG4gIGdldCBpbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuaW50ZW5zaXR5LnZhbHVlO1xuICB9XG4gIHNldCBpbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmludGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmRlZmluZXMuTEVHQUNZX0lOVEVOU0lUWSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmRlZmluZXMuTEVHQUNZX0lOVEVOU0lUWSA9IFwiMVwiO1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBTU0FPRWZmZWN0LmludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBnZXRJbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuaW50ZW5zaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBTU0FPRWZmZWN0LmludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgaW50ZW5zaXR5LlxuICAgKi9cbiAgc2V0SW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnRlbnNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGZhZGUgZmFjdG9yLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZhZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZmFkZS52YWx1ZTtcbiAgfVxuICBzZXQgZmFkZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZmFkZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXB0aCBmYWRlIGZhY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZhZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZmFkZSBmYWN0b3IuXG4gICAqL1xuICBnZXRGYWRlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmZhZGUudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGZhZGUgZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZmFkZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZmFkZSBmYWN0b3IuXG4gICAqL1xuICBzZXRGYWRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mYWRlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBiaWFzLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiaWFzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJpYXMudmFsdWU7XG4gIH1cbiAgc2V0IGJpYXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmJpYXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVwdGggYmlhcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJpYXMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYmlhcy5cbiAgICovXG4gIGdldEJpYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmlhcy52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYmlhcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJpYXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJpYXMuXG4gICAqL1xuICBzZXRCaWFzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5iaWFzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHJhZGl1cyBzY2FsZSBmb3IgZGlzdGFuY2Ugc2NhbGluZy4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluUmFkaXVzU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWluUmFkaXVzU2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IG1pblJhZGl1c1NjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5taW5SYWRpdXNTY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHJhZGl1cyBzY2FsZSBmb3IgZGlzdGFuY2Ugc2NhbGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblJhZGl1c1NjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlLlxuICAgKi9cbiAgZ2V0TWluUmFkaXVzU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWluUmFkaXVzU2NhbGUudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlIGZvciBkaXN0YW5jZSBzY2FsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluUmFkaXVzU2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlLlxuICAgKi9cbiAgc2V0TWluUmFkaXVzU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1pblJhZGl1c1NjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGFic29sdXRlIHJhZGl1cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLnIgKiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMuZGVmaW5lcy5SQURJVVMgPSByYWRpdXMudG9GaXhlZCgxMSk7XG4gICAgdGhpcy5kZWZpbmVzLlJBRElVU19TUSA9IChyYWRpdXMgKiByYWRpdXMpLnRvRml4ZWQoMTEpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIHNhbXBsaW5nIHJhZGl1cy4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnI7XG4gIH1cbiAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMuciA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAxZS02KSwgMSk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHJhZGl1cy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJhZGl1cyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYWRpdXMuXG4gICAqL1xuICBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmFkaXVzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSByYWRpdXMuIFJhbmdlIFsxZS02LCAxLjBdLlxuICAgKi9cbiAgc2V0UmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy5yYWRpdXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGlzdGFuY2VTY2FsaW5nKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldCBkaXN0YW5jZVNjYWxpbmcodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBkaXN0YW5jZSBzY2FsaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc0Rpc3RhbmNlU2NhbGluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTY2FsaW5nO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGRpc3RhbmNlLWJhc2VkIHJhZGl1cyBzY2FsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBkaXN0YW5jZSBzY2FsaW5nIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGlzdGFuY2VTY2FsaW5nRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZGlzdGFuY2VTY2FsaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gZGlzdGFuY2UgdGhyZXNob2xkLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkaXN0YW5jZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kaXN0YW5jZUN1dG9mZi52YWx1ZS54O1xuICB9XG4gIHNldCBkaXN0YW5jZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUuc2V0KFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHZhbHVlICsgdGhpcy5kaXN0YW5jZUZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gZGlzdGFuY2UgdGhyZXNob2xkIGluIHdvcmxkIHVuaXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5kaXN0YW5jZVRocmVzaG9sZCwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRpc3RhbmNlVGhyZXNob2xkID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gZGlzdGFuY2UgZmFsbG9mZi4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGlzdGFuY2VGYWxsb2ZmKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpc3RhbmNlQ3V0b2ZmLnZhbHVlLnkgLSB0aGlzLmRpc3RhbmNlVGhyZXNob2xkO1xuICB9XG4gIHNldCBkaXN0YW5jZUZhbGxvZmYodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRpc3RhbmNlQ3V0b2ZmLnZhbHVlLnkgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmRpc3RhbmNlVGhyZXNob2xkICsgdmFsdWUsIDApLCAxKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBmYWxsb2ZmIGluIHdvcmxkIHVuaXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdvcmxkRGlzdGFuY2VGYWxsb2ZmKCkge1xuICAgIHJldHVybiAtb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKHRoaXMuZGlzdGFuY2VGYWxsb2ZmLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGREaXN0YW5jZUZhbGxvZmYodmFsdWUpIHtcbiAgICB0aGlzLmRpc3RhbmNlRmFsbG9mZiA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtdmFsdWUsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gZGlzdGFuY2UgY3V0b2ZmLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGlzdGFuY2VUaHJlc2hvbGQgYW5kIGRpc3RhbmNlRmFsbG9mZiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIGRpc3RhbmNlIHRocmVzaG9sZC4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhbGxvZmYgLSBUaGUgZmFsbG9mZi4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICovXG4gIHNldERpc3RhbmNlQ3V0b2ZmKHRocmVzaG9sZCwgZmFsbG9mZikge1xuICAgIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUuc2V0KFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodGhyZXNob2xkLCAwKSwgMSksXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh0aHJlc2hvbGQgKyBmYWxsb2ZmLCAwKSwgMSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIHByb3hpbWl0eSB0aHJlc2hvbGQuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByb3hpbWl0eVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUueDtcbiAgfVxuICBzZXQgcHJveGltaXR5VGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUuc2V0KFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHZhbHVlICsgdGhpcy5wcm94aW1pdHlGYWxsb2ZmLCAwKSwgMSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIHByb3hpbWl0eSB0aHJlc2hvbGQgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGRQcm94aW1pdHlUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5wcm94aW1pdHlUaHJlc2hvbGQsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIHNldCB3b3JsZFByb3hpbWl0eVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMucHJveGltaXR5VGhyZXNob2xkID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IGZhbGxvZmYuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByb3hpbWl0eUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucHJveGltaXR5Q3V0b2ZmLnZhbHVlLnkgLSB0aGlzLnByb3hpbWl0eVRocmVzaG9sZDtcbiAgfVxuICBzZXQgcHJveGltaXR5RmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMucHJveGltaXR5Q3V0b2ZmLnZhbHVlLnkgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLnByb3hpbWl0eVRocmVzaG9sZCArIHZhbHVlLCAwKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IGZhbGxvZmYgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGRQcm94aW1pdHlGYWxsb2ZmKCkge1xuICAgIHJldHVybiAtb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKHRoaXMucHJveGltaXR5RmFsbG9mZiwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkUHJveGltaXR5RmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMucHJveGltaXR5RmFsbG9mZiA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtdmFsdWUsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gcHJveGltaXR5IGN1dG9mZi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3hpbWl0eVRocmVzaG9sZCBhbmQgcHJveGltaXR5RmFsbG9mZiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIHJhbmdlIHRocmVzaG9sZC4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhbGxvZmYgLSBUaGUgZmFsbG9mZi4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICovXG4gIHNldFByb3hpbWl0eUN1dG9mZih0aHJlc2hvbGQsIGZhbGxvZmYpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByb3hpbWl0eUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh0aHJlc2hvbGQsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHRocmVzaG9sZCArIGZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleGVsIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaXplKCkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgdGV4ZWwgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHRleGVsIGhlaWdodC5cbiAgICovXG4gIHNldFRleGVsU2l6ZSh4LCB5KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHgsIHkpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUuc2V0KGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgICAgIHRoaXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZS5jb3B5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIHRoaXMudW5pZm9ybXMuaW52ZXJzZVByb2plY3Rpb25NYXRyaXgudmFsdWUuY29weShjYW1lcmEucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG4gICAgICBpZiAoY2FtZXJhIGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmE2KSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkEgPSBcIjFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IG5vaXNlVGV4dHVyZSA9IHVuaWZvcm1zLm5vaXNlVGV4dHVyZS52YWx1ZTtcbiAgICBpZiAobm9pc2VUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB1bmlmb3Jtcy5ub2lzZVNjYWxlLnZhbHVlLnNldChcbiAgICAgICAgd2lkdGggLyBub2lzZVRleHR1cmUuaW1hZ2Uud2lkdGgsXG4gICAgICAgIGhlaWdodCAvIG5vaXNlVGV4dHVyZS5pbWFnZS5oZWlnaHRcbiAgICAgICk7XG4gICAgfVxuICAgIHVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvVGlsdFNoaWZ0Qmx1ck1hdGVyaWFsLmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0yMSwgVmVjdG9yMiBhcyBWZWN0b3IyMTMsIFZlY3RvcjQgYXMgVmVjdG9yNDIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLnRpbHQtc2hpZnQuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdCA9IFwiI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxudW5pZm9ybSB2ZWM0IG1hc2tQYXJhbXM7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdk9mZnNldDtmbG9hdCBsaW5lYXJHcmFkaWVudE1hc2soY29uc3QgaW4gZmxvYXQgeCl7cmV0dXJuIHNtb290aHN0ZXAobWFza1BhcmFtcy54LG1hc2tQYXJhbXMueSx4KS1zbW9vdGhzdGVwKG1hc2tQYXJhbXMudyxtYXNrUGFyYW1zLnoseCk7fXZvaWQgbWFpbigpe3ZlYzIgZFV2PXZPZmZzZXQqKDEuMC1saW5lYXJHcmFkaWVudE1hc2sodlV2Mi55KSk7dmVjNCBzdW09dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZlYzIodlV2LngtZFV2LngsdlV2LnkrZFV2LnkpKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2ZWMyKHZVdi54K2RVdi54LHZVdi55K2RVdi55KSk7c3VtKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdmVjMih2VXYueCtkVXYueCx2VXYueS1kVXYueSkpO3N1bSs9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZlYzIodlV2LngtZFV2LngsdlV2LnktZFV2LnkpKTtnbF9GcmFnQ29sb3I9c3VtKjAuMjU7XFxuI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxufVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24udGlsdC1zaGlmdC52ZXJ0XG52YXIgY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWM0IHRleGVsU2l6ZTt1bmlmb3JtIGZsb2F0IGtlcm5lbDt1bmlmb3JtIGZsb2F0IHNjYWxlO3VuaWZvcm0gZmxvYXQgYXNwZWN0O3VuaWZvcm0gdmVjMiByb3RhdGlvbjt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0O3ZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXY9dXY7dlV2Mj0odXYtMC41KSoyLjAqdmVjMihhc3BlY3QsMS4wKTt2VXYyPXZlYzIoZG90KHJvdGF0aW9uLHZVdjIpLGRvdChyb3RhdGlvbix2ZWMyKHZVdjIueSwtdlV2Mi54KSkpO3ZPZmZzZXQ9KHRleGVsU2l6ZS54eSp2ZWMyKGtlcm5lbCkrdGV4ZWxTaXplLnp3KSpzY2FsZTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9UaWx0U2hpZnRCbHVyTWF0ZXJpYWwuanNcbnZhciBUaWx0U2hpZnRCbHVyTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIEthd2FzZUJsdXJNYXRlcmlhbCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHRpbHQgc2hpZnQgYmx1ciBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTAuMF0gLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MC4wXSAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZm9jdXMgYXJlYSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNBcmVhPTAuNF0gLSBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZlYXRoZXI9MC4zXSAtIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU0sXG4gICAgb2Zmc2V0ID0gMCxcbiAgICByb3RhdGlvbiA9IDAsXG4gICAgZm9jdXNBcmVhID0gMC40LFxuICAgIGZlYXRoZXIgPSAwLjNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0O1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0MjtcbiAgICB0aGlzLmtlcm5lbFNpemUgPSBrZXJuZWxTaXplO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB1cGRhdGVGcmFnbWVudFNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgICB0aGlzLnVuaWZvcm1zLmFzcGVjdCA9IG5ldyBVbmlmb3JtMjEoMSk7XG4gICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvbiA9IG5ldyBVbmlmb3JtMjEobmV3IFZlY3RvcjIxMygpKTtcbiAgICB0aGlzLnVuaWZvcm1zLm1hc2tQYXJhbXMgPSBuZXcgVW5pZm9ybTIxKG5ldyBWZWN0b3I0MigpKTtcbiAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5fZm9jdXNBcmVhID0gZm9jdXNBcmVhO1xuICAgIHRoaXMuX2ZlYXRoZXIgPSBmZWF0aGVyO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUGFyYW1zKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMudW5pZm9ybXMubWFza1BhcmFtcy52YWx1ZTtcbiAgICBjb25zdCBhID0gTWF0aC5tYXgodGhpcy5mb2N1c0FyZWEsIDApO1xuICAgIGNvbnN0IGIgPSBNYXRoLm1heChhIC0gdGhpcy5mZWF0aGVyLCAwKTtcbiAgICBwYXJhbXMuc2V0KFxuICAgICAgdGhpcy5vZmZzZXQgLSBhLFxuICAgICAgdGhpcy5vZmZzZXQgLSBiLFxuICAgICAgdGhpcy5vZmZzZXQgKyBhLFxuICAgICAgdGhpcy5vZmZzZXQgKyBiXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBmb2N1cyBhcmVhIGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLnVuaWZvcm1zLnJvdGF0aW9uLnZhbHVlLngpO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMucm90YXRpb24udmFsdWUuc2V0KE1hdGguY29zKHZhbHVlKSwgTWF0aC5zaW4odmFsdWUpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5fb2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNBcmVhKCkge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c0FyZWE7XG4gIH1cbiAgc2V0IGZvY3VzQXJlYSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvY3VzQXJlYSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBmZWF0aGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9mZWF0aGVyO1xuICB9XG4gIHNldCBmZWF0aGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fZmVhdGhlciA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBzdXBlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMuYXNwZWN0LnZhbHVlID0gd2lkdGggLyBoZWlnaHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvVXBzYW1wbGluZ01hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcyMSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwyMSwgVW5pZm9ybSBhcyBVbmlmb3JtMjIsIFZlY3RvcjIgYXMgVmVjdG9yMjE0IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi51cHNhbXBsaW5nLmZyYWdcbnZhciBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQgPSBcIiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7dW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBzdXBwb3J0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHN1cHBvcnRCdWZmZXI7XFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCByYWRpdXM7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2YXJ5aW5nIHZlYzIgdlV2NDt2YXJ5aW5nIHZlYzIgdlV2NTt2YXJ5aW5nIHZlYzIgdlV2Njt2YXJ5aW5nIHZlYzIgdlV2Nzt2b2lkIG1haW4oKXt2ZWM0IGM9dmVjNCgwLjApO2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjMpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpKjAuMjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjQpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY1KSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjYpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY3KSowLjA2MjU7dmVjNCBiYXNlQ29sb3I9dGV4dHVyZTJEKHN1cHBvcnRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9bWl4KGJhc2VDb2xvcixjLHJhZGl1cyk7XFxuI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxufVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24udXBzYW1wbGluZy52ZXJ0XG52YXIgY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZhcnlpbmcgdmVjMiB2VXY0O3ZhcnlpbmcgdmVjMiB2VXY1O3ZhcnlpbmcgdmVjMiB2VXY2O3ZhcnlpbmcgdmVjMiB2VXY3O3ZvaWQgbWFpbigpe3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdjA9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsMS4wKTt2VXYxPXZVdit0ZXhlbFNpemUqdmVjMigwLjAsMS4wKTt2VXYyPXZVdit0ZXhlbFNpemUqdmVjMigxLjAsMS4wKTt2VXYzPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLDAuMCk7dlV2ND12VXYrdGV4ZWxTaXplKnZlYzIoMS4wLDAuMCk7dlV2NT12VXYrdGV4ZWxTaXplKnZlYzIoLTEuMCwtMS4wKTt2VXY2PXZVdit0ZXhlbFNpemUqdmVjMigwLjAsLTEuMCk7dlV2Nz12VXYrdGV4ZWxTaXplKnZlYzIoMS4wLC0xLjApO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1Vwc2FtcGxpbmdNYXRlcmlhbC5qc1xudmFyIFVwc2FtcGxpbmdNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwyMSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHVwc2FtcGxpbmcgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIlVwc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMjIobnVsbCksXG4gICAgICAgIHN1cHBvcnRCdWZmZXI6IG5ldyBVbmlmb3JtMjIobnVsbCksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0yMihuZXcgVmVjdG9yMjE0KCkpLFxuICAgICAgICByYWRpdXM6IG5ldyBVbmlmb3JtMjIoMC44NSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzIxLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQSBzdXBwb3J0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgc3VwcG9ydEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc3VwcG9ydEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciByYWRpdXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZTtcbiAgfVxuICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0NvcHlQYXNzLmpzXG5pbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTIsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvcGFzc2VzL1Bhc3MuanNcbmltcG9ydCB7XG4gIEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nOCxcbiAgQnVmZmVyQXR0cmlidXRlLFxuICBCdWZmZXJHZW9tZXRyeSxcbiAgQ2FtZXJhLFxuICBNYXRlcmlhbCxcbiAgTWVzaCxcbiAgU2NlbmUsXG4gIFRleHR1cmUsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0XG59IGZyb20gXCJ0aHJlZVwiO1xudmFyIGR1bW15Q2FtZXJhID0gLyogQF9fUFVSRV9fICovIG5ldyBDYW1lcmEoKTtcbnZhciBnZW9tZXRyeSA9IG51bGw7XG5mdW5jdGlvbiBnZXRGdWxsc2NyZWVuVHJpYW5nbGUoKSB7XG4gIGlmIChnZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAwLCAzLCAtMSwgMCwgLTEsIDMsIDBdKTtcbiAgICBjb25zdCB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSk7XG4gICAgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkuc2V0QXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShcInV2XCIsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9tZXRyeTtcbn1cbnZhciBQYXNzID0gY2xhc3MgX1Bhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gVGhlIG5hbWUgb2YgdGhpcyBwYXNzLiBEb2VzIG5vdCBoYXZlIHRvIGJlIHVuaXF1ZS5cbiAgICogQHBhcmFtIHtTY2VuZX0gW3NjZW5lXSAtIFRoZSBzY2VuZSB0byByZW5kZXIuIFRoZSBkZWZhdWx0IHNjZW5lIGNvbnRhaW5zIGEgc2luZ2xlIG1lc2ggdGhhdCBmaWxscyB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gW2NhbWVyYV0gLSBBIGNhbWVyYS4gRnVsbHNjcmVlbiBlZmZlY3QgcGFzc2VzIGRvbid0IHJlcXVpcmUgYSBjYW1lcmEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lID0gXCJQYXNzXCIsIHNjZW5lID0gbmV3IFNjZW5lKCksIGNhbWVyYSA9IGR1bW15Q2FtZXJhKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgIHRoaXMucnR0ID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IHRydWU7XG4gICAgdGhpcy5uZWVkc0RlcHRoVGV4dHVyZSA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlciB0byBzY3JlZW4gZmxhZy5cbiAgICpcbiAgICogSWYgdGhpcyBmbGFnIGlzIGNoYW5nZWQsIHRoZSBmdWxsc2NyZWVuIG1hdGVyaWFsIHdpbGwgYmUgdXBkYXRlZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCByZW5kZXJUb1NjcmVlbigpIHtcbiAgICByZXR1cm4gIXRoaXMucnR0O1xuICB9XG4gIHNldCByZW5kZXJUb1NjcmVlbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLnJ0dCA9PT0gdmFsdWUpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgICBpZiAobWF0ZXJpYWwgIT09IG51bGwpIHtcbiAgICAgICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5ydHQgPSAhdmFsdWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYWluIHNjZW5lLlxuICAgKlxuICAgKiBAdHlwZSB7U2NlbmV9XG4gICAqL1xuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1haW4gY2FtZXJhLlxuICAgKlxuICAgKiBAdHlwZSB7Q2FtZXJhfVxuICAgKi9cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyZXJcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICovXG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHBhc3MgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVuYWJsZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGlzIHBhc3MgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVuYWJsZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHBhc3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmdWxsc2NyZWVuIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgZnVsbHNjcmVlbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbiAhPT0gbnVsbCA/IHRoaXMuc2NyZWVuLm1hdGVyaWFsIDogbnVsbDtcbiAgfVxuICBzZXQgZnVsbHNjcmVlbk1hdGVyaWFsKHZhbHVlKSB7XG4gICAgbGV0IHNjcmVlbiA9IHRoaXMuc2NyZWVuO1xuICAgIGlmIChzY3JlZW4gIT09IG51bGwpIHtcbiAgICAgIHNjcmVlbi5tYXRlcmlhbCA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JlZW4gPSBuZXcgTWVzaChnZXRGdWxsc2NyZWVuVHJpYW5nbGUoKSwgdmFsdWUpO1xuICAgICAgc2NyZWVuLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnNjZW5lID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgU2NlbmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NlbmUuYWRkKHNjcmVlbik7XG4gICAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZnVsbHNjcmVlbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtNYXRlcmlhbH0gVGhlIGN1cnJlbnQgZnVsbHNjcmVlbiBtYXRlcmlhbCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lLlxuICAgKi9cbiAgZ2V0RnVsbHNjcmVlbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZnVsbHNjcmVlbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7TWF0ZXJpYWx9IHZhbHVlIC0gQSBmdWxsc2NyZWVuIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0RnVsbHNjcmVlbk1hdGVyaWFsKHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAqL1xuICBnZXREZXB0aFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0uXG4gICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91ciBwYXNzIHJlbGllcyBvbiB0aGUgZGVwdGggaW5mb3JtYXRpb24gb2YgYSBwcmVjZWRpbmcge0BsaW5rIFJlbmRlclBhc3N9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVneX0gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nOCkge1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgcGFzcy5cbiAgICpcbiAgICogVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QgdGhhdCBtdXN0IGJlIG92ZXJyaWRkZW4uXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4uXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlbmRlciBtZXRob2Qgbm90IGltcGxlbWVudGVkIVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZS5cbiAgICpcbiAgICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0byBiZSBpbmZvcm1lZCBhYm91dCB0aGUgc2l6ZSBvZiB0aGUgYmFja2J1ZmZlci9jYW52YXMuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBiZWZvcmUge0BsaW5rIGluaXRpYWxpemV9IGFuZCBldmVyeSB0aW1lIHRoZSBzaXplIG9mIHRoZSB7QGxpbmsgRWZmZWN0Q29tcG9zZXJ9IGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoaXMgcGFzcyBpcyBhZGRlZCB0byBhbiB7QGxpbmsgRWZmZWN0Q29tcG9zZXJ9LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIHNoYWxsb3cgc2VhcmNoIGZvciBkaXNwb3NhYmxlIHByb3BlcnRpZXMgYW5kIGRlbGV0ZXMgdGhlbS5cbiAgICpcbiAgICogVGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0gY2FsbHMgdGhpcyBtZXRob2Qgd2hlbiBpdCBpcyBiZWluZyBkZXN0cm95ZWQuIFlvdSBjYW4gdXNlIGl0IGluZGVwZW5kZW50bHkgdG8gZnJlZVxuICAgKiBtZW1vcnkgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHlvdSBkb24ndCBuZWVkIHRoaXMgcGFzcyBhbnltb3JlLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzW2tleV07XG4gICAgICBjb25zdCBpc0Rpc3Bvc2FibGUgPSBwcm9wZXJ0eSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyVGFyZ2V0IHx8IHByb3BlcnR5IGluc3RhbmNlb2YgTWF0ZXJpYWwgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBUZXh0dXJlIHx8IHByb3BlcnR5IGluc3RhbmNlb2YgX1Bhc3M7XG4gICAgICBpZiAoaXNEaXNwb3NhYmxlKSB7XG4gICAgICAgIHRoaXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0NvcHlQYXNzLmpzXG52YXIgQ29weVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzYXZlIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtyZW5kZXJUYXJnZXRdIC0gQSByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthdXRvUmVzaXplPXRydWVdIC0gV2hldGhlciB0aGUgcmVuZGVyIHRhcmdldCBzaXplIHNob3VsZCBiZSB1cGRhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJUYXJnZXQsIGF1dG9SZXNpemUgPSB0cnVlKSB7XG4gICAgc3VwZXIoXCJDb3B5UGFzc1wiKTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgIGlmIChyZW5kZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQyKDEsIDEsIHtcbiAgICAgICAgbWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxuICAgICAgICBzdGVuY2lsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiQ29weVBhc3MuVGFyZ2V0XCI7XG4gICAgfVxuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IGF1dG9SZXNpemU7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYXV0byByZXNpemluZyBvZiB0aGUgcmVuZGVyIHRhcmdldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGF1dG9SZXNpemUgaW5zdGVhZC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgcmVzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmF1dG9SZXNpemU7XG4gIH1cbiAgc2V0IHJlc2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG91dHB1dCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYXV0byByZXNpemluZyBvZiB0aGUgcmVuZGVyIHRhcmdldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGF1dG9SZXNpemUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2l6ZSBzaG91bGQgYmUgdXBkYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgKi9cbiAgc2V0QXV0b1Jlc2l6ZUVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9SZXNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2F2ZXMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBpbnB1dEJ1ZmZlci50ZXh0dXJlO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh0aGlzLmF1dG9SZXNpemUpIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUyKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgIH0gZWxzZSBpZiAoZ2V0T3V0cHV0Q29sb3JTcGFjZShyZW5kZXJlcikgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQWRhcHRpdmVMdW1pbmFuY2VQYXNzLmpzXG52YXIgQWRhcHRpdmVMdW1pbmFuY2VQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYWRhcHRpdmUgbHVtaW5hbmNlIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gbHVtaW5hbmNlQnVmZmVyIC0gQSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgY3VycmVudCBzY2VuZSBsdW1pbmFuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbkx1bWluYW5jZT0wLjAxXSAtIFRoZSBtaW5pbXVtIGx1bWluYW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFkYXB0YXRpb25SYXRlPTEuMF0gLSBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGx1bWluYW5jZUJ1ZmZlciwgeyBtaW5MdW1pbmFuY2UgPSAwLjAxLCBhZGFwdGF0aW9uUmF0ZSA9IDEgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJBZGFwdGl2ZUx1bWluYW5jZVBhc3NcIik7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBuZXcgQWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCgpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDMoMSwgMSwge1xuICAgICAgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cy50ZXh0dXJlLm5hbWUgPSBcIkx1bWluYW5jZS5QcmV2aW91c1wiO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgbWF0ZXJpYWwubHVtaW5hbmNlQnVmZmVyMCA9IHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMudGV4dHVyZTtcbiAgICBtYXRlcmlhbC5sdW1pbmFuY2VCdWZmZXIxID0gbHVtaW5hbmNlQnVmZmVyO1xuICAgIG1hdGVyaWFsLm1pbkx1bWluYW5jZSA9IG1pbkx1bWluYW5jZTtcbiAgICBtYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSA9IGFkYXB0YXRpb25SYXRlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZCA9IHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQudGV4dHVyZS5uYW1lID0gXCJMdW1pbmFuY2UuQWRhcHRlZFwiO1xuICAgIHRoaXMuY29weVBhc3MgPSBuZXcgQ29weVBhc3ModGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cywgZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYWRhcHRpdmUgbHVtaW5hbmNlIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhZGFwdGl2ZSAxeDEgbHVtaW5hbmNlIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIDF4MSBtaXBtYXAgbGV2ZWwuXG4gICAqXG4gICAqIFRoaXMgbGV2ZWwgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgc21hbGxlc3QgbWlwbWFwIG9mIHRoZSBtYWluIGx1bWluYW5jZSB0ZXh0dXJlIHdoaWNoIGNvbnRhaW5zIHRoZSBkb3duc2FtcGxlZFxuICAgKiBhdmVyYWdlIHNjZW5lIGx1bWluYW5jZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbC5taXBMZXZlbDF4MSBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IG1pcExldmVsMXgxKHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwubWlwTGV2ZWwxeDEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBmdWxsc2NyZWVuTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhZGFwdGF0aW9uUmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBmdWxsc2NyZWVuTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICovXG4gIHNldCBhZGFwdGF0aW9uUmF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmFkYXB0YXRpb25SYXRlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNjZW5lIG5vcm1hbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlbHRhVGltZSA9IGRlbHRhVGltZTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQpO1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgdGhpcy5jb3B5UGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQm94Qmx1clBhc3MuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nOSwgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMywgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQ0IH0gZnJvbSBcInRocmVlXCI7XG52YXIgQm94Qmx1clBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBib3ggYmx1ciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPTVdIC0gTXVzdCBiZSBhbiBvZGQgbnVtYmVyLiBUaGUgc2l6ZXMgMyBhbmQgNSB1c2Ugb3B0aW1pemVkIGNvZGUgcGF0aHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTFdIC0gVGhlIGFtb3VudCBvZiB0aW1lcyB0aGUgYmx1ciBzaG91bGQgYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpbGF0ZXJhbD1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIGJpbGF0ZXJhbCBibHVycmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAga2VybmVsU2l6ZSA9IDUsXG4gICAgaXRlcmF0aW9ucyA9IDEsXG4gICAgYmlsYXRlcmFsID0gZmFsc2UsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICByZXNvbHV0aW9uWCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25ZID0gUmVzb2x1dGlvbi5BVVRPX1NJWkVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJCb3hCbHVyUGFzc1wiKTtcbiAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gYmlsYXRlcmFsO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDQoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQVwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QiA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDQoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQlwiO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsID0gbmV3IEJveEJsdXJNYXRlcmlhbCh7IGJpbGF0ZXJhbCwga2VybmVsU2l6ZSB9KTtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nOSkge1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEEgPSB0aGlzLnJlbmRlclRhcmdldEE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QjtcbiAgICBjb25zdCBibHVyTWF0ZXJpYWwgPSB0aGlzLmJsdXJNYXRlcmlhbDtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IGJsdXJNYXRlcmlhbDtcbiAgICBsZXQgcHJldmlvdXNCdWZmZXIgPSBpbnB1dEJ1ZmZlcjtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHRoaXMuaXRlcmF0aW9ucywgMSk7IGkgPCBsOyArK2kpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IChpICYgMSkgPT09IDAgPyByZW5kZXJUYXJnZXRBIDogcmVuZGVyVGFyZ2V0QjtcbiAgICAgIGJsdXJNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoYnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHByZXZpb3VzQnVmZmVyID0gYnVmZmVyO1xuICAgIH1cbiAgICB0aGlzLmNvcHlNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB0aGlzLmNvcHlNYXRlcmlhbDtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBvdXRwdXRCdWZmZXIpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5tYXhWYXJ5aW5nVmVjdG9ycyA9IHJlbmRlcmVyLmNhcGFiaWxpdGllcy5tYXhWYXJ5aW5ncztcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTMpIHtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgfSBlbHNlIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQ2xlYXJNYXNrUGFzcy5qc1xudmFyIENsZWFyTWFza1Bhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjbGVhciBtYXNrIHBhc3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkNsZWFyTWFza1Bhc3NcIiwgbnVsbCwgbnVsbCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGdsb2JhbCBzdGVuY2lsIHRlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHN0ZW5jaWwgPSByZW5kZXJlci5zdGF0ZS5idWZmZXJzLnN0ZW5jaWw7XG4gICAgc3RlbmNpbC5zZXRMb2NrZWQoZmFsc2UpO1xuICAgIHN0ZW5jaWwuc2V0VGVzdChmYWxzZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQ2xlYXJQYXNzLmpzXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIGNvbG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBDb2xvcigpO1xudmFyIENsZWFyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNsZWFyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbG9yPXRydWVdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb2xvciBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlcHRoPXRydWVdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBkZXB0aCBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWw9ZmFsc2VdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdGVuY2lsIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbG9yMiA9IHRydWUsIGRlcHRoID0gdHJ1ZSwgc3RlbmNpbCA9IGZhbHNlKSB7XG4gICAgc3VwZXIoXCJDbGVhclBhc3NcIiwgbnVsbCwgbnVsbCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3IyO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLnN0ZW5jaWwgPSBzdGVuY2lsO1xuICAgIHRoaXMub3ZlcnJpZGVDbGVhckNvbG9yID0gbnVsbDtcbiAgICB0aGlzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjbGVhciBmbGFncy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb2xvciAtIFdoZXRoZXIgdGhlIGNvbG9yIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBkZXB0aCAtIFdoZXRoZXIgdGhlIGRlcHRoIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBzdGVuY2lsIC0gV2hldGhlciB0aGUgc3RlbmNpbCBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAqL1xuICBzZXRDbGVhckZsYWdzKGNvbG9yMiwgZGVwdGgsIHN0ZW5jaWwpIHtcbiAgICB0aGlzLmNvbG9yID0gY29sb3IyO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLnN0ZW5jaWwgPSBzdGVuY2lsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdmVycmlkZSBjbGVhciBjb2xvci4gRGVmYXVsdCBpcyBudWxsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVDbGVhckNvbG9yIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0NvbG9yfSBUaGUgY2xlYXIgY29sb3IuXG4gICAqL1xuICBnZXRPdmVycmlkZUNsZWFyQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcnJpZGVDbGVhckNvbG9yO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdmVycmlkZSBjbGVhciBjb2xvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlQ2xlYXJDb2xvciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NvbG9yfSB2YWx1ZSAtIFRoZSBjbGVhciBjb2xvci5cbiAgICovXG4gIHNldE92ZXJyaWRlQ2xlYXJDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMub3ZlcnJpZGVDbGVhckNvbG9yID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG92ZXJyaWRlIGNsZWFyIGFscGhhLiBEZWZhdWx0IGlzIC0xLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVDbGVhckFscGhhIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNsZWFyIGFscGhhLlxuICAgKi9cbiAgZ2V0T3ZlcnJpZGVDbGVhckFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJyaWRlQ2xlYXJBbHBoYTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3ZlcnJpZGUgY2xlYXIgYWxwaGEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZUNsZWFyQWxwaGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGNsZWFyIGFscGhhLlxuICAgKi9cbiAgc2V0T3ZlcnJpZGVDbGVhckFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy5vdmVycmlkZUNsZWFyQWxwaGEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBpbnB1dCBidWZmZXIgb3IgdGhlIHNjcmVlbi5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVDbGVhckNvbG9yID0gdGhpcy5vdmVycmlkZUNsZWFyQ29sb3I7XG4gICAgY29uc3Qgb3ZlcnJpZGVDbGVhckFscGhhID0gdGhpcy5vdmVycmlkZUNsZWFyQWxwaGE7XG4gICAgY29uc3QgY2xlYXJBbHBoYSA9IHJlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcbiAgICBjb25zdCBoYXNPdmVycmlkZUNsZWFyQ29sb3IgPSBvdmVycmlkZUNsZWFyQ29sb3IgIT09IG51bGw7XG4gICAgY29uc3QgaGFzT3ZlcnJpZGVDbGVhckFscGhhID0gb3ZlcnJpZGVDbGVhckFscGhhID49IDA7XG4gICAgaWYgKGhhc092ZXJyaWRlQ2xlYXJDb2xvcikge1xuICAgICAgcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcihjb2xvcik7XG4gICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKG92ZXJyaWRlQ2xlYXJDb2xvciwgaGFzT3ZlcnJpZGVDbGVhckFscGhhID8gb3ZlcnJpZGVDbGVhckFscGhhIDogY2xlYXJBbHBoYSk7XG4gICAgfSBlbHNlIGlmIChoYXNPdmVycmlkZUNsZWFyQWxwaGEpIHtcbiAgICAgIHJlbmRlcmVyLnNldENsZWFyQWxwaGEob3ZlcnJpZGVDbGVhckFscGhhKTtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogaW5wdXRCdWZmZXIpO1xuICAgIHJlbmRlcmVyLmNsZWFyKHRoaXMuY29sb3IsIHRoaXMuZGVwdGgsIHRoaXMuc3RlbmNpbCk7XG4gICAgaWYgKGhhc092ZXJyaWRlQ2xlYXJDb2xvcikge1xuICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihjb2xvciwgY2xlYXJBbHBoYSk7XG4gICAgfSBlbHNlIGlmIChoYXNPdmVycmlkZUNsZWFyQWxwaGEpIHtcbiAgICAgIHJlbmRlcmVyLnNldENsZWFyQWxwaGEoY2xlYXJBbHBoYSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoUGFzcy5qc1xuaW1wb3J0IHsgQ29sb3IgYXMgQ29sb3IyLCBNZXNoRGVwdGhNYXRlcmlhbCwgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyMiwgUkdCQURlcHRoUGFja2luZyBhcyBSR0JBRGVwdGhQYWNraW5nMiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQ1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9wYXNzZXMvUmVuZGVyUGFzcy5qc1xudmFyIFJlbmRlclBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyByZW5kZXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UgdG8gcmVuZGVyIHRoZSBzY2VuZS5cbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gW292ZXJyaWRlTWF0ZXJpYWw9bnVsbF0gLSBBbiBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsKSB7XG4gICAgc3VwZXIoXCJSZW5kZXJQYXNzXCIsIHNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKCk7XG4gICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsTWFuYWdlciA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IG51bGwgPyBudWxsIDogbmV3IE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyKG92ZXJyaWRlTWF0ZXJpYWwpO1xuICAgIHRoaXMuaWdub3JlQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMuc2tpcFNoYWRvd01hcFVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5zY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcmVuZGVyVG9TY3JlZW4oKSB7XG4gICAgcmV0dXJuIHN1cGVyLnJlbmRlclRvU2NyZWVuO1xuICB9XG4gIHNldCByZW5kZXJUb1NjcmVlbih2YWx1ZSkge1xuICAgIHN1cGVyLnJlbmRlclRvU2NyZWVuID0gdmFsdWU7XG4gICAgdGhpcy5jbGVhclBhc3MucmVuZGVyVG9TY3JlZW4gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgb3ZlcnJpZGUgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICovXG4gIGdldCBvdmVycmlkZU1hdGVyaWFsKCkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyO1xuICAgIHJldHVybiBtYW5hZ2VyICE9PSBudWxsID8gbWFuYWdlci5tYXRlcmlhbCA6IG51bGw7XG4gIH1cbiAgc2V0IG92ZXJyaWRlTWF0ZXJpYWwodmFsdWUpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdGhpcy5vdmVycmlkZU1hdGVyaWFsTWFuYWdlcjtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChtYW5hZ2VyICE9PSBudWxsKSB7XG4gICAgICAgIG1hbmFnZXIuc2V0TWF0ZXJpYWwodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsTWFuYWdlciA9IG5ldyBPdmVycmlkZU1hdGVyaWFsTWFuYWdlcih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYW5hZ2VyICE9PSBudWxsKSB7XG4gICAgICBtYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldE92ZXJyaWRlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcnJpZGVNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3ZlcnJpZGUgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZU1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge01hdGVyaWFsfSB2YWx1ZSAtIFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIHNldE92ZXJyaWRlTWF0ZXJpYWwodmFsdWUpIHtcbiAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBjbGVhclBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmNsZWFyUGFzcy5lbmFibGVkO1xuICB9XG4gIHNldCBjbGVhcih2YWx1ZSkge1xuICAgIHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2VsZWN0aW9uLiBEZWZhdWx0IGlzIGBudWxsYCAobm8gcmVzdHJpY3Rpb24pLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIGdldFNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdGlvbi4gU2V0IHRvIGBudWxsYCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSB2YWx1ZSAtIFRoZSBzZWxlY3Rpb24uXG4gICAqL1xuICBzZXRTZWxlY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2NlbmUgYmFja2dyb3VuZCBpcyBkaXNhYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlnbm9yZUJhY2tncm91bmQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgc2NlbmUgYmFja2dyb3VuZCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzQmFja2dyb3VuZERpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlnbm9yZUJhY2tncm91bmQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNjZW5lIGJhY2tncm91bmQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpZ25vcmVCYWNrZ3JvdW5kIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBzY2VuZSBiYWNrZ3JvdW5kIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIHNldEJhY2tncm91bmREaXNhYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuaWdub3JlQmFja2dyb3VuZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2hhZG93IG1hcCBhdXRvIHVwZGF0ZSBpcyBkaXNhYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNraXBTaGFkb3dNYXBVcGRhdGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgc2hhZG93IG1hcCB1cGRhdGUgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBpc1NoYWRvd01hcERpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNraXBTaGFkb3dNYXBVcGRhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdyBtYXAgYXV0byB1cGRhdGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBza2lwU2hhZG93TWFwVXBkYXRlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBzaGFkb3cgbWFwIGF1dG8gdXBkYXRlIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIHNldFNoYWRvd01hcERpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5za2lwU2hhZG93TWFwVXBkYXRlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsZWFyIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjbGVhclBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtDbGVhclBhc3N9IFRoZSBjbGVhciBwYXNzLlxuICAgKi9cbiAgZ2V0Q2xlYXJQYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNsZWFyUGFzcztcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2NlbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICBjb25zdCBtYXNrID0gY2FtZXJhLmxheWVycy5tYXNrO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuICAgIGNvbnN0IHNoYWRvd01hcEF1dG9VcGRhdGUgPSByZW5kZXJlci5zaGFkb3dNYXAuYXV0b1VwZGF0ZTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IGlucHV0QnVmZmVyO1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIGNhbWVyYS5sYXllcnMuc2V0KHNlbGVjdGlvbi5nZXRMYXllcigpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2tpcFNoYWRvd01hcFVwZGF0ZSkge1xuICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLmF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWdub3JlQmFja2dyb3VuZCB8fCB0aGlzLmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgIT09IG51bGwpIHtcbiAgICAgIHNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5jbGVhclBhc3MuZW5hYmxlZCkge1xuICAgICAgdGhpcy5jbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlcik7XG4gICAgfVxuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyLnJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICB9XG4gICAgY2FtZXJhLmxheWVycy5tYXNrID0gbWFzaztcbiAgICBzY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICByZW5kZXJlci5zaGFkb3dNYXAuYXV0b1VwZGF0ZSA9IHNoYWRvd01hcEF1dG9VcGRhdGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhQYXNzLmpzXG52YXIgRGVwdGhQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UgdG8gcmVuZGVyIHRoZSBzY2VuZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBbb3B0aW9ucy5yZW5kZXJUYXJnZXRdIC0gQSBjdXN0b20gcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIHtcbiAgICByZW5kZXJUYXJnZXQsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEZXB0aFBhc3NcIik7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhLCBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoe1xuICAgICAgZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nMlxuICAgIH0pKTtcbiAgICBjb25zdCByZW5kZXJQYXNzID0gdGhpcy5yZW5kZXJQYXNzO1xuICAgIHJlbmRlclBhc3Muc2tpcFNoYWRvd01hcFVwZGF0ZSA9IHRydWU7XG4gICAgcmVuZGVyUGFzcy5pZ25vcmVCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICBjb25zdCBjbGVhclBhc3MgPSByZW5kZXJQYXNzLmNsZWFyUGFzcztcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yMigxNjc3NzIxNSk7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IDE7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgaWYgKHRoaXMucmVuZGVyVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0NSgxLCAxLCB7XG4gICAgICAgIG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcjIsXG4gICAgICAgIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcjJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJEZXB0aFBhc3MuVGFyZ2V0XCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLnJlbmRlclBhc3MubWFpblNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLnJlbmRlclBhc3MubWFpbkNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvblNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBuZXcgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIHNldFJlc29sdXRpb25TY2FsZShzY2FsZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zY2FsZSA9IHNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzY2VuZSBkZXB0aC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldDtcbiAgICB0aGlzLnJlbmRlclBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aERvd25zYW1wbGluZ1Bhc3MuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTAsIEZsb2F0VHlwZSwgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyMywgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQ2IH0gZnJvbSBcInRocmVlXCI7XG52YXIgRGVwdGhEb3duc2FtcGxpbmdQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggZG93bnNhbXBsaW5nIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbb3B0aW9ucy5ub3JtYWxCdWZmZXI9bnVsbF0gLSBBIHRleHR1cmUgdGhhdCBjb250YWlucyB2aWV3IHNwYWNlIG5vcm1hbHMuIFNlZSB7QGxpbmsgTm9ybWFsUGFzc30uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbm9ybWFsQnVmZmVyID0gbnVsbCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRGVwdGhEb3duc2FtcGxpbmdQYXNzXCIpO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IERlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWwoKTtcbiAgICBtYXRlcmlhbC5ub3JtYWxCdWZmZXIgPSBub3JtYWxCdWZmZXI7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0NigxLCAxLCB7XG4gICAgICBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIzLFxuICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyMyxcbiAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgIHR5cGU6IEZsb2F0VHlwZVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiRGVwdGhEb3duc2FtcGxpbmdQYXNzLlRhcmdldFwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwoUkdCKSArIGRlcHRoKEEpIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vcm1hbChSR0IpICsgZGVwdGgoQSkgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTApIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIERvd25zYW1wbGVzIGRlcHRoIGFuZCBzY2VuZSBub3JtYWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgcmVuZGVyYWJsZSA9IGdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpO1xuICAgIGlmICghcmVuZGVyYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyaW5nIHRvIGZsb2F0IHRleHR1cmUgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoUGlja2luZ1Bhc3MuanNcbmltcG9ydCB7IEZsb2F0VHlwZSBhcyBGbG9hdFR5cGUzLCBSR0JBRGVwdGhQYWNraW5nIGFzIFJHQkFEZXB0aFBhY2tpbmc0IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhDb3B5UGFzcy5qc1xuaW1wb3J0IHtcbiAgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxMSxcbiAgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTIsXG4gIE5lYXJlc3RGaWx0ZXIgYXMgTmVhcmVzdEZpbHRlcjQsXG4gIFJHQkFEZXB0aFBhY2tpbmcgYXMgUkdCQURlcHRoUGFja2luZzMsXG4gIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTQsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0N1xufSBmcm9tIFwidGhyZWVcIjtcbnZhciBEZXB0aENvcHlQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggc2F2ZSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW29wdGlvbnMuZGVwdGhQYWNraW5nPVJHQkFEZXB0aFBhY2tpbmddIC0gVGhlIG91dHB1dCBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nMyB9ID0ge30pIHtcbiAgICBzdXBlcihcIkRlcHRoQ29weVBhc3NcIik7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgRGVwdGhDb3B5TWF0ZXJpYWwoKTtcbiAgICBtYXRlcmlhbC5vdXRwdXREZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0NygxLCAxLCB7XG4gICAgICB0eXBlOiBkZXB0aFBhY2tpbmcgPT09IFJHQkFEZXB0aFBhY2tpbmczID8gVW5zaWduZWRCeXRlVHlwZTQgOiBGbG9hdFR5cGUyLFxuICAgICAgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyNCxcbiAgICAgIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcjQsXG4gICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRlcHRoQ29weVBhc3MuVGFyZ2V0XCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG91dHB1dCBkZXB0aCBwYWNraW5nLlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIGdldCBkZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm91dHB1dERlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBnZXREZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm91dHB1dERlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTEpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5pbnB1dERlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGRlcHRoIGZyb20gYSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoUGlja2luZ1Bhc3MuanNcbnZhciB1bnBhY2tGYWN0b3JzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIDI1NSAvIDI1NiAvIDI1NiAqKiAzLFxuICAyNTUgLyAyNTYgLyAyNTYgKiogMixcbiAgMjU1IC8gMjU2IC8gMjU2LFxuICAyNTUgLyAyNTZcbl0pO1xuZnVuY3Rpb24gdW5wYWNrUkdCQVRvRGVwdGgocGFja2VkRGVwdGgpIHtcbiAgcmV0dXJuIChwYWNrZWREZXB0aFswXSAqIHVucGFja0ZhY3RvcnNbMF0gKyBwYWNrZWREZXB0aFsxXSAqIHVucGFja0ZhY3RvcnNbMV0gKyBwYWNrZWREZXB0aFsyXSAqIHVucGFja0ZhY3RvcnNbMl0gKyBwYWNrZWREZXB0aFszXSAqIHVucGFja0ZhY3RvcnNbM10pIC8gMjU1O1xufVxudmFyIERlcHRoUGlja2luZ1Bhc3MgPSBjbGFzcyBleHRlbmRzIERlcHRoQ29weVBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBwaWNraW5nIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbb3B0aW9ucy5kZXB0aFBhY2tpbmc9UkdCQURlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1vZGU9RGVwdGhDb3B5TW9kZS5TSU5HTEVdIC0gVGhlIGRlcHRoIGNvcHkgbW9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZzQsIG1vZGUgPSBEZXB0aENvcHlNb2RlLlNJTkdMRSB9ID0ge30pIHtcbiAgICBzdXBlcih7IGRlcHRoUGFja2luZyB9KTtcbiAgICB0aGlzLm5hbWUgPSBcIkRlcHRoUGlja2luZ1Bhc3NcIjtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5tb2RlID0gbW9kZTtcbiAgICB0aGlzLnBpeGVsQnVmZmVyID0gZGVwdGhQYWNraW5nID09PSBSR0JBRGVwdGhQYWNraW5nNCA/IG5ldyBVaW50OEFycmF5KDQpIDogbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVhZHMgZGVwdGggYXQgYSBzcGVjaWZpYyBzY3JlZW4gcG9zaXRpb24uXG4gICAqXG4gICAqIE9ubHkgb25lIGRlcHRoIHZhbHVlIGNhbiBiZSBwaWNrZWQgcGVyIGZyYW1lLiBDYWxsaW5nIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZSB3aWxsIG92ZXJ3cml0ZSB0aGVcbiAgICogcGlja2luZyBjb29yZGluYXRlcy4gVW5yZXNvbHZlZCBwcm9taXNlcyB3aWxsIGJlIGFiYW5kb25lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbmRjID0gbmV3IFZlY3RvcjMoKTtcbiAgICogY29uc3QgY2xpZW50UmVjdCA9IG15Vmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAqIGNvbnN0IGNsaWVudFggPSBwb2ludGVyRXZlbnQuY2xpZW50WCAtIGNsaWVudFJlY3QubGVmdDtcbiAgICogY29uc3QgY2xpZW50WSA9IHBvaW50ZXJFdmVudC5jbGllbnRZIC0gY2xpZW50UmVjdC50b3A7XG4gICAqIG5kYy54ID0gKGNsaWVudFggLyBteVZpZXdwb3J0LmNsaWVudFdpZHRoKSAqIDIuMCAtIDEuMDtcbiAgICogbmRjLnkgPSAtKGNsaWVudFkgLyBteVZpZXdwb3J0LmNsaWVudEhlaWdodCkgKiAyLjAgKyAxLjA7XG4gICAqIGNvbnN0IGRlcHRoID0gYXdhaXQgZGVwdGhQaWNraW5nUGFzcy5yZWFkRGVwdGgobmRjKTtcbiAgICogbmRjLnogPSBkZXB0aCAqIDIuMCAtIDEuMDtcbiAgICpcbiAgICogY29uc3Qgd29ybGRQb3NpdGlvbiA9IG5kYy51bnByb2plY3QoY2FtZXJhKTtcbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3IyfFZlY3RvcjN9IG5kYyAtIE5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzLiBPbmx5IFggYW5kIFkgYXJlIHJlbGV2YW50LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE51bWJlcj59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIGRlcHRoIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgKi9cbiAgcmVhZERlcHRoKG5kYykge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLnRleGVsUG9zaXRpb24uc2V0KG5kYy54ICogMC41ICsgMC41LCBuZGMueSAqIDAuNSArIDAuNSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGRlcHRoIGFuZCByZXNvbHZlcyBkZXB0aCBwaWNraW5nIHByb21pc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIGNvbnN0IG1vZGUgPSBtYXRlcmlhbC5tb2RlO1xuICAgIGlmIChtb2RlID09PSBEZXB0aENvcHlNb2RlLkZVTEwpIHtcbiAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICAgIGNvbnN0IHBpeGVsQnVmZmVyID0gdGhpcy5waXhlbEJ1ZmZlcjtcbiAgICAgIGNvbnN0IHBhY2tlZCA9IHJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgIT09IEZsb2F0VHlwZTM7XG4gICAgICBsZXQgeCA9IDAsIHkgPSAwO1xuICAgICAgaWYgKG1vZGUgPT09IERlcHRoQ29weU1vZGUuU0lOR0xFKSB7XG4gICAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXhlbFBvc2l0aW9uID0gbWF0ZXJpYWwudGV4ZWxQb3NpdGlvbjtcbiAgICAgICAgeCA9IE1hdGgucm91bmQodGV4ZWxQb3NpdGlvbi54ICogcmVuZGVyVGFyZ2V0LndpZHRoKTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQodGV4ZWxQb3NpdGlvbi55ICogcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzKHJlbmRlclRhcmdldCwgeCwgeSwgMSwgMSwgcGl4ZWxCdWZmZXIpO1xuICAgICAgdGhpcy5jYWxsYmFjayhwYWNrZWQgPyB1bnBhY2tSR0JBVG9EZXB0aChwaXhlbEJ1ZmZlcikgOiBwaXhlbEJ1ZmZlclswXSk7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm1vZGUgPT09IERlcHRoQ29weU1vZGUuRlVMTCkge1xuICAgICAgc3VwZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvRWZmZWN0UGFzcy5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxMiwgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlNSB9IGZyb20gXCJ0aHJlZVwiO1xuZnVuY3Rpb24gcHJlZml4U3Vic3RyaW5ncyhwcmVmaXgsIHN1YnN0cmluZ3MsIHN0cmluZ3MpIHtcbiAgZm9yIChjb25zdCBzdWJzdHJpbmcgb2Ygc3Vic3RyaW5ncykge1xuICAgIGNvbnN0IHByZWZpeGVkID0gXCIkMVwiICsgcHJlZml4ICsgc3Vic3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3Vic3RyaW5nLnNsaWNlKDEpO1xuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCIoW15cXFxcLl0pKFxcXFxiXCIgKyBzdWJzdHJpbmcgKyBcIlxcXFxiKVwiLCBcImdcIik7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBzdHJpbmdzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGVudHJ5WzFdICE9PSBudWxsKSB7XG4gICAgICAgIHN0cmluZ3Muc2V0KGVudHJ5WzBdLCBlbnRyeVsxXS5yZXBsYWNlKHJlZ0V4cCwgcHJlZml4ZWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVncmF0ZUVmZmVjdChwcmVmaXgsIGVmZmVjdCwgZGF0YSkge1xuICBsZXQgZnJhZ21lbnRTaGFkZXIgPSBlZmZlY3QuZ2V0RnJhZ21lbnRTaGFkZXIoKTtcbiAgbGV0IHZlcnRleFNoYWRlciA9IGVmZmVjdC5nZXRWZXJ0ZXhTaGFkZXIoKTtcbiAgY29uc3QgbWFpbkltYWdlRXhpc3RzID0gZnJhZ21lbnRTaGFkZXIgIT09IHZvaWQgMCAmJiAvbWFpbkltYWdlLy50ZXN0KGZyYWdtZW50U2hhZGVyKTtcbiAgY29uc3QgbWFpblV2RXhpc3RzID0gZnJhZ21lbnRTaGFkZXIgIT09IHZvaWQgMCAmJiAvbWFpblV2Ly50ZXN0KGZyYWdtZW50U2hhZGVyKTtcbiAgZGF0YS5hdHRyaWJ1dGVzIHw9IGVmZmVjdC5nZXRBdHRyaWJ1dGVzKCk7XG4gIGlmIChmcmFnbWVudFNoYWRlciA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGZyYWdtZW50IHNoYWRlciAoJHtlZmZlY3QubmFtZX0pYCk7XG4gIH0gZWxzZSBpZiAobWFpblV2RXhpc3RzICYmIChkYXRhLmF0dHJpYnV0ZXMgJiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04pICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFZmZlY3RzIHRoYXQgdHJhbnNmb3JtIFVWcyBhcmUgaW5jb21wYXRpYmxlIHdpdGggY29udm9sdXRpb24gZWZmZWN0cyAoJHtlZmZlY3QubmFtZX0pYCk7XG4gIH0gZWxzZSBpZiAoIW1haW5JbWFnZUV4aXN0cyAmJiAhbWFpblV2RXhpc3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBtYWluSW1hZ2Ugb3IgbWFpblV2IGZ1bmN0aW9uICgke2VmZmVjdC5uYW1lfSlgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmdW5jdGlvblJlZ0V4cCA9IC9cXHcrXFxzKyhcXHcrKVxcKFtcXHdcXHMsXSpcXClcXHMqey9nO1xuICAgIGNvbnN0IHNoYWRlclBhcnRzID0gZGF0YS5zaGFkZXJQYXJ0cztcbiAgICBsZXQgZnJhZ21lbnRIZWFkID0gc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCkgfHwgXCJcIjtcbiAgICBsZXQgZnJhZ21lbnRNYWluVXYgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWKSB8fCBcIlwiO1xuICAgIGxldCBmcmFnbWVudE1haW5JbWFnZSA9IHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UpIHx8IFwiXCI7XG4gICAgbGV0IHZlcnRleEhlYWQgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfSEVBRCkgfHwgXCJcIjtcbiAgICBsZXQgdmVydGV4TWFpblN1cHBvcnQgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JUKSB8fCBcIlwiO1xuICAgIGNvbnN0IHZhcnlpbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBuYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgaWYgKG1haW5VdkV4aXN0cykge1xuICAgICAgZnJhZ21lbnRNYWluVXYgKz0gYFx0JHtwcmVmaXh9TWFpblV2KFVWKTtcbmA7XG4gICAgICBkYXRhLnV2VHJhbnNmb3JtYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodmVydGV4U2hhZGVyICE9PSBudWxsICYmIC9tYWluU3VwcG9ydC8udGVzdCh2ZXJ0ZXhTaGFkZXIpKSB7XG4gICAgICBjb25zdCBuZWVkc1V2ID0gL21haW5TdXBwb3J0ICpcXChbXFx3XFxzXSo/dXZcXHMqP1xcKS8udGVzdCh2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgdmVydGV4TWFpblN1cHBvcnQgKz0gYFx0JHtwcmVmaXh9TWFpblN1cHBvcnQoYDtcbiAgICAgIHZlcnRleE1haW5TdXBwb3J0ICs9IG5lZWRzVXYgPyBcInZVdik7XFxuXCIgOiBcIik7XFxuXCI7XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIHZlcnRleFNoYWRlci5tYXRjaEFsbCgvKD86dmFyeWluZ1xccytcXHcrXFxzKyhbXFxTXFxzXSo/KTspL2cpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBtMlsxXS5zcGxpdCgvXFxzKixcXHMqLykpIHtcbiAgICAgICAgICBkYXRhLnZhcnlpbmdzLmFkZChuKTtcbiAgICAgICAgICB2YXJ5aW5ncy5hZGQobik7XG4gICAgICAgICAgbmFtZXMuYWRkKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIHZlcnRleFNoYWRlci5tYXRjaEFsbChmdW5jdGlvblJlZ0V4cCkpIHtcbiAgICAgICAgbmFtZXMuYWRkKG0yWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBtMiBvZiBmcmFnbWVudFNoYWRlci5tYXRjaEFsbChmdW5jdGlvblJlZ0V4cCkpIHtcbiAgICAgIG5hbWVzLmFkZChtMlsxXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZCBvZiBlZmZlY3QuZGVmaW5lcy5rZXlzKCkpIHtcbiAgICAgIG5hbWVzLmFkZChkLnJlcGxhY2UoL1xcKFtcXHdcXHMsXSpcXCkvZywgXCJcIikpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHUgb2YgZWZmZWN0LnVuaWZvcm1zLmtleXMoKSkge1xuICAgICAgbmFtZXMuYWRkKHUpO1xuICAgIH1cbiAgICBuYW1lcy5kZWxldGUoXCJ3aGlsZVwiKTtcbiAgICBuYW1lcy5kZWxldGUoXCJmb3JcIik7XG4gICAgbmFtZXMuZGVsZXRlKFwiaWZcIik7XG4gICAgZWZmZWN0LnVuaWZvcm1zLmZvckVhY2goKHZhbCwga2V5KSA9PiBkYXRhLnVuaWZvcm1zLnNldChwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSksIHZhbCkpO1xuICAgIGVmZmVjdC5kZWZpbmVzLmZvckVhY2goKHZhbCwga2V5KSA9PiBkYXRhLmRlZmluZXMuc2V0KHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKSwgdmFsKSk7XG4gICAgY29uc3Qgc2hhZGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbXCJmcmFnbWVudFwiLCBmcmFnbWVudFNoYWRlcl0sIFtcInZlcnRleFwiLCB2ZXJ0ZXhTaGFkZXJdXSk7XG4gICAgcHJlZml4U3Vic3RyaW5ncyhwcmVmaXgsIG5hbWVzLCBkYXRhLmRlZmluZXMpO1xuICAgIHByZWZpeFN1YnN0cmluZ3MocHJlZml4LCBuYW1lcywgc2hhZGVycyk7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJzLmdldChcImZyYWdtZW50XCIpO1xuICAgIHZlcnRleFNoYWRlciA9IHNoYWRlcnMuZ2V0KFwidmVydGV4XCIpO1xuICAgIGNvbnN0IGJsZW5kTW9kZSA9IGVmZmVjdC5ibGVuZE1vZGU7XG4gICAgZGF0YS5ibGVuZE1vZGVzLnNldChibGVuZE1vZGUuYmxlbmRGdW5jdGlvbiwgYmxlbmRNb2RlKTtcbiAgICBpZiAobWFpbkltYWdlRXhpc3RzKSB7XG4gICAgICBpZiAoZWZmZWN0LmlucHV0Q29sb3JTcGFjZSAhPT0gbnVsbCAmJiBlZmZlY3QuaW5wdXRDb2xvclNwYWNlICE9PSBkYXRhLmNvbG9yU3BhY2UpIHtcbiAgICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgKz0gZWZmZWN0LmlucHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgPyBcImNvbG9yMCA9IExpbmVhclRvc1JHQihjb2xvcjApO1xcblx0XCIgOiBcImNvbG9yMCA9IHNSR0JUb0xpbmVhcihjb2xvcjApO1xcblx0XCI7XG4gICAgICB9XG4gICAgICBpZiAoZWZmZWN0Lm91dHB1dENvbG9yU3BhY2UgIT09IE5vQ29sb3JTcGFjZSkge1xuICAgICAgICBkYXRhLmNvbG9yU3BhY2UgPSBlZmZlY3Qub3V0cHV0Q29sb3JTcGFjZTtcbiAgICAgIH0gZWxzZSBpZiAoZWZmZWN0LmlucHV0Q29sb3JTcGFjZSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhLmNvbG9yU3BhY2UgPSBlZmZlY3QuaW5wdXRDb2xvclNwYWNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVwdGhQYXJhbVJlZ0V4cCA9IC9NYWluSW1hZ2UgKlxcKFtcXHdcXHMsXSo/ZGVwdGhbXFx3XFxzLF0qP1xcKS87XG4gICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBgJHtwcmVmaXh9TWFpbkltYWdlKGNvbG9yMCwgVVYsIGA7XG4gICAgICBpZiAoKGRhdGEuYXR0cmlidXRlcyAmIEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCkgIT09IDAgJiYgZGVwdGhQYXJhbVJlZ0V4cC50ZXN0KGZyYWdtZW50U2hhZGVyKSkge1xuICAgICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBcImRlcHRoLCBcIjtcbiAgICAgICAgZGF0YS5yZWFkRGVwdGggPSB0cnVlO1xuICAgICAgfVxuICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgKz0gXCJjb2xvcjEpO1xcblx0XCI7XG4gICAgICBjb25zdCBibGVuZE9wYWNpdHkgPSBwcmVmaXggKyBcIkJsZW5kT3BhY2l0eVwiO1xuICAgICAgZGF0YS51bmlmb3Jtcy5zZXQoYmxlbmRPcGFjaXR5LCBibGVuZE1vZGUub3BhY2l0eSk7XG4gICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBgY29sb3IwID0gYmxlbmQke2JsZW5kTW9kZS5ibGVuZEZ1bmN0aW9ufShjb2xvcjAsIGNvbG9yMSwgJHtibGVuZE9wYWNpdHl9KTtcblxuXHRgO1xuICAgICAgZnJhZ21lbnRIZWFkICs9IGB1bmlmb3JtIGZsb2F0ICR7YmxlbmRPcGFjaXR5fTtcblxuYDtcbiAgICB9XG4gICAgZnJhZ21lbnRIZWFkICs9IGZyYWdtZW50U2hhZGVyICsgXCJcXG5cIjtcbiAgICBpZiAodmVydGV4U2hhZGVyICE9PSBudWxsKSB7XG4gICAgICB2ZXJ0ZXhIZWFkICs9IHZlcnRleFNoYWRlciArIFwiXFxuXCI7XG4gICAgfVxuICAgIHNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX0hFQUQsIGZyYWdtZW50SGVhZCk7XG4gICAgc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VViwgZnJhZ21lbnRNYWluVXYpO1xuICAgIHNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UsIGZyYWdtZW50TWFpbkltYWdlKTtcbiAgICBzaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfSEVBRCwgdmVydGV4SGVhZCk7XG4gICAgc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCwgdmVydGV4TWFpblN1cHBvcnQpO1xuICAgIGlmIChlZmZlY3QuZXh0ZW5zaW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgZWZmZWN0LmV4dGVuc2lvbnMpIHtcbiAgICAgICAgZGF0YS5leHRlbnNpb25zLmFkZChleHRlbnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIEVmZmVjdFBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHsuLi5FZmZlY3R9IGVmZmVjdHMgLSBUaGUgZWZmZWN0cyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYnkgdGhpcyBwYXNzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhLCAuLi5lZmZlY3RzKSB7XG4gICAgc3VwZXIoXCJFZmZlY3RQYXNzXCIpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbmV3IEVmZmVjdE1hdGVyaWFsKG51bGwsIG51bGwsIG51bGwsIGNhbWVyYSk7XG4gICAgdGhpcy5saXN0ZW5lciA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVFdmVudChldmVudCk7XG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgdGhpcy5zZXRFZmZlY3RzKGVmZmVjdHMpO1xuICAgIHRoaXMuc2tpcFJlbmRlcmluZyA9IGZhbHNlO1xuICAgIHRoaXMubWluVGltZSA9IDE7XG4gICAgdGhpcy5tYXhUaW1lID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMudGltZVNjYWxlID0gMTtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QubWFpblNjZW5lID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHBhc3MgZW5jb2RlcyBpdHMgb3V0cHV0IHdoZW4gcmVuZGVyaW5nIHRvIHNjcmVlbi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBmdWxsc2NyZWVuTWF0ZXJpYWwuZW5jb2RlT3V0cHV0IGluc3RlYWQuXG4gICAqL1xuICBnZXQgZW5jb2RlT3V0cHV0KCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5lbmNvZGVPdXRwdXQ7XG4gIH1cbiAgc2V0IGVuY29kZU91dHB1dCh2YWx1ZSkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmVuY29kZU91dHB1dCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXRoZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGl0aGVyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kaXRoZXJpbmc7XG4gIH1cbiAgc2V0IGRpdGhlcmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgbWF0ZXJpYWwuZGl0aGVyaW5nID0gdmFsdWU7XG4gICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlZmZlY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VmZmVjdFtdfSBlZmZlY3RzIC0gVGhlIGVmZmVjdHMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldEVmZmVjdHMoZWZmZWN0cykge1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHMuc29ydCgoYSwgYikgPT4gYi5hdHRyaWJ1dGVzIC0gYS5hdHRyaWJ1dGVzKTtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG91bmQgc2hhZGVyIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVNYXRlcmlhbCgpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IEVmZmVjdFNoYWRlckRhdGEoKTtcbiAgICBsZXQgaWQgPSAwO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgaWYgKGVmZmVjdC5ibGVuZE1vZGUuYmxlbmRGdW5jdGlvbiA9PT0gQmxlbmRGdW5jdGlvbi5EU1QpIHtcbiAgICAgICAgZGF0YS5hdHRyaWJ1dGVzIHw9IGVmZmVjdC5nZXRBdHRyaWJ1dGVzKCkgJiBFZmZlY3RBdHRyaWJ1dGUuREVQVEg7XG4gICAgICB9IGVsc2UgaWYgKChkYXRhLmF0dHJpYnV0ZXMgJiBlZmZlY3QuZ2V0QXR0cmlidXRlcygpICYgRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OKSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZvbHV0aW9uIGVmZmVjdHMgY2Fubm90IGJlIG1lcmdlZCAoJHtlZmZlY3QubmFtZX0pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlZ3JhdGVFZmZlY3QoXCJlXCIgKyBpZCsrLCBlZmZlY3QsIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZnJhZ21lbnRIZWFkID0gZGF0YS5zaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFEKTtcbiAgICBsZXQgZnJhZ21lbnRNYWluSW1hZ2UgPSBkYXRhLnNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UpO1xuICAgIGxldCBmcmFnbWVudE1haW5VdiA9IGRhdGEuc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VVik7XG4gICAgY29uc3QgYmxlbmRSZWdFeHAgPSAvXFxiYmxlbmRcXGIvZztcbiAgICBmb3IgKGNvbnN0IGJsZW5kTW9kZSBvZiBkYXRhLmJsZW5kTW9kZXMudmFsdWVzKCkpIHtcbiAgICAgIGZyYWdtZW50SGVhZCArPSBibGVuZE1vZGUuZ2V0U2hhZGVyQ29kZSgpLnJlcGxhY2UoYmxlbmRSZWdFeHAsIGBibGVuZCR7YmxlbmRNb2RlLmJsZW5kRnVuY3Rpb259YCkgKyBcIlxcblwiO1xuICAgIH1cbiAgICBpZiAoKGRhdGEuYXR0cmlidXRlcyAmIEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCkgIT09IDApIHtcbiAgICAgIGlmIChkYXRhLnJlYWREZXB0aCkge1xuICAgICAgICBmcmFnbWVudE1haW5JbWFnZSA9IFwiZmxvYXQgZGVwdGggPSByZWFkRGVwdGgoVVYpO1xcblxcblx0XCIgKyBmcmFnbWVudE1haW5JbWFnZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSB0aGlzLmdldERlcHRoVGV4dHVyZSgpID09PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBcImNvbG9yMCA9IHNSR0JUb0xpbmVhcihjb2xvcjApO1xcblx0XCI7XG4gICAgfVxuICAgIGlmIChkYXRhLnV2VHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIGZyYWdtZW50TWFpblV2ID0gXCJ2ZWMyIHRyYW5zZm9ybWVkVXYgPSB2VXY7XFxuXCIgKyBmcmFnbWVudE1haW5VdjtcbiAgICAgIGRhdGEuZGVmaW5lcy5zZXQoXCJVVlwiLCBcInRyYW5zZm9ybWVkVXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuZGVmaW5lcy5zZXQoXCJVVlwiLCBcInZVdlwiKTtcbiAgICB9XG4gICAgZGF0YS5zaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFELCBmcmFnbWVudEhlYWQpO1xuICAgIGRhdGEuc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSwgZnJhZ21lbnRNYWluSW1hZ2UpO1xuICAgIGRhdGEuc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VViwgZnJhZ21lbnRNYWluVXYpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEuc2hhZGVyUGFydHMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhLnNoYWRlclBhcnRzLnNldChrZXksIHZhbHVlLnRyaW0oKS5yZXBsYWNlKC9eIy8sIFwiXFxuI1wiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2tpcFJlbmRlcmluZyA9IGlkID09PSAwO1xuICAgIHRoaXMubmVlZHNTd2FwID0gIXRoaXMuc2tpcFJlbmRlcmluZztcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaGFkZXJEYXRhKGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBSZWJ1aWxkcyB0aGUgc2hhZGVyIG1hdGVyaWFsLlxuICAgKi9cbiAgcmVjb21waWxlKCkge1xuICAgIHRoaXMudXBkYXRlTWF0ZXJpYWwoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAqL1xuICBnZXREZXB0aFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoQnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxMikge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5zZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC51cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2tpcFJlbmRlcmluZyB8fCB0aGlzLnJlbmRlclRvU2NyZWVuKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgICAgbWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBpbnB1dEJ1ZmZlci50ZXh0dXJlO1xuICAgICAgbWF0ZXJpYWwudGltZSArPSBkZWx0YVRpbWUgKiB0aGlzLnRpbWVTY2FsZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IG91dHB1dEJ1ZmZlcik7XG4gICAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTWF0ZXJpYWwoKTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDAgJiYgZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlNSkge1xuICAgICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBkaXNwb3NhYmxlIG9iamVjdHMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgZWZmZWN0LmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIEFuIGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJjaGFuZ2VcIjpcbiAgICAgICAgdGhpcy5yZWNvbXBpbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0dhdXNzaWFuQmx1clBhc3MuanNcbmltcG9ydCB7IFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTYsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0OCB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIEdhdXNzaWFuQmx1clBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBHYXVzc2lhbiBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9MzVdIC0gVGhlIGtlcm5lbCBzaXplLiBTaG91bGQgYmUgYW4gb2RkIG51bWJlciBpbiB0aGUgcmFuZ2UgWzMsIDEwMjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaXRlcmF0aW9ucz0xXSAtIFRoZSBhbW91bnQgb2YgdGltZXMgdGhlIGJsdXIgc2hvdWxkIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGtlcm5lbFNpemUgPSAzNSxcbiAgICBpdGVyYXRpb25zID0gMSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHJlc29sdXRpb25YID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblkgPSBSZXNvbHV0aW9uLkFVVE9fU0laRVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdhdXNzaWFuQmx1clBhc3NcIik7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0OCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRBLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQlwiO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsID0gbmV3IEdhdXNzaWFuQmx1ck1hdGVyaWFsKHsga2VybmVsU2l6ZSB9KTtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGJsdXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRBID0gdGhpcy5yZW5kZXJUYXJnZXRBO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEIgPSB0aGlzLnJlbmRlclRhcmdldEI7XG4gICAgY29uc3QgYmx1ck1hdGVyaWFsID0gdGhpcy5ibHVyTWF0ZXJpYWw7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBibHVyTWF0ZXJpYWw7XG4gICAgbGV0IHByZXZpb3VzQnVmZmVyID0gaW5wdXRCdWZmZXI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBNYXRoLm1heCh0aGlzLml0ZXJhdGlvbnMsIDEpOyBpIDwgbDsgKytpKSB7XG4gICAgICBibHVyTWF0ZXJpYWwuZGlyZWN0aW9uLnNldCgxLCAwKTtcbiAgICAgIGJsdXJNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0QSk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBibHVyTWF0ZXJpYWwuZGlyZWN0aW9uLnNldCgwLCAxKTtcbiAgICAgIGJsdXJNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHJlbmRlclRhcmdldEEudGV4dHVyZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXRCKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIGlmIChpID09PSAwICYmIGwgPiAxKSB7XG4gICAgICAgIHByZXZpb3VzQnVmZmVyID0gcmVuZGVyVGFyZ2V0QjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB0aGlzLmNvcHlNYXRlcmlhbDtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBvdXRwdXRCdWZmZXIpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTYpIHtcbiAgICAgICAgdGhpcy5ibHVyTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgICB0aGlzLmNvcHlNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKGdldE91dHB1dENvbG9yU3BhY2UocmVuZGVyZXIpID09PSBTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9LYXdhc2VCbHVyUGFzcy5qc1xuaW1wb3J0IHsgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlNywgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQ5IH0gZnJvbSBcInRocmVlXCI7XG52YXIgS2F3YXNlQmx1clBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBLYXdhc2UgYmx1ciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLk1FRElVTV0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU0sXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkthd2FzZUJsdXJQYXNzXCIpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDkoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQVwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QS5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0LkJcIjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLl9ibHVyTWF0ZXJpYWwgPSBuZXcgS2F3YXNlQmx1ck1hdGVyaWFsKCk7XG4gICAgdGhpcy5fYmx1ck1hdGVyaWFsLmtlcm5lbFNpemUgPSBrZXJuZWxTaXplO1xuICAgIHRoaXMuY29weU1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtLYXdhc2VCbHVyTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgYmx1ck1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLl9ibHVyTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7S2F3YXNlQmx1ck1hdGVyaWFsfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXQgYmx1ck1hdGVyaWFsKHZhbHVlKSB7XG4gICAgdGhpcy5fYmx1ck1hdGVyaWFsID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpdGhlcmluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlNYXRlcmlhbC5kaXRoZXJpbmcgaW5zdGVhZC5cbiAgICovXG4gIGdldCBkaXRoZXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weU1hdGVyaWFsLmRpdGhlcmluZztcbiAgfVxuICBzZXQgZGl0aGVyaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5jb3B5TWF0ZXJpYWwuZGl0aGVyaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0tlcm5lbFNpemV9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1ck1hdGVyaWFsLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ud2lkdGggaW5zdGVhZC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXIgd2lkdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLnByZWZlcnJlZFdpZHRoIGluc3RlYWQuXG4gICAqL1xuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24uaGVpZ2h0IGluc3RlYWQuXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXIgaGVpZ2h0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwuc2NhbGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1ck1hdGVyaWFsLnNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1ck1hdGVyaWFsLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1ck1hdGVyaWFsLnNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtLZXJuZWxTaXplfSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBnZXRLZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmtlcm5lbFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBMYXJnZXIga2VybmVscyByZXF1aXJlIG1vcmUgcHJvY2Vzc2luZyBwb3dlciBidXQgc2NhbGUgd2VsbCB3aXRoIGxhcmdlciByZW5kZXIgcmVzb2x1dGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IHZhbHVlIC0gVGhlIGtlcm5lbCBzaXplLlxuICAgKi9cbiAgc2V0S2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGJsdXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRBID0gdGhpcy5yZW5kZXJUYXJnZXRBO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEIgPSB0aGlzLnJlbmRlclRhcmdldEI7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmJsdXJNYXRlcmlhbDtcbiAgICBjb25zdCBrZXJuZWxTZXF1ZW5jZSA9IG1hdGVyaWFsLmtlcm5lbFNlcXVlbmNlO1xuICAgIGxldCBwcmV2aW91c0J1ZmZlciA9IGlucHV0QnVmZmVyO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXJuZWxTZXF1ZW5jZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IChpICYgMSkgPT09IDAgPyByZW5kZXJUYXJnZXRBIDogcmVuZGVyVGFyZ2V0QjtcbiAgICAgIG1hdGVyaWFsLmtlcm5lbCA9IGtlcm5lbFNlcXVlbmNlW2ldO1xuICAgICAgbWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGJ1ZmZlcik7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBwcmV2aW91c0J1ZmZlciA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB0aGlzLmNvcHlNYXRlcmlhbDtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogb3V0cHV0QnVmZmVyKTtcbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGU3KSB7XG4gICAgICAgIHRoaXMuYmx1ck1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgICAgdGhpcy5jb3B5TWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgfSBlbHNlIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFuIGF1dG8gc2l6aW5nIGZsYWcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgUmVzb2x1dGlvbi5BVVRPX1NJWkV9IGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgZ2V0IEFVVE9fU0laRSgpIHtcbiAgICByZXR1cm4gUmVzb2x1dGlvbi5BVVRPX1NJWkU7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTGFtYmRhUGFzcy5qc1xudmFyIExhbWJkYVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBsYW1iZGEgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiAtIEEgZnVuY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmKSB7XG4gICAgc3VwZXIoXCJMYW1iZGFQYXNzXCIsIG51bGwsIG51bGwpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICB0aGlzLmYoKTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9MdW1pbmFuY2VQYXNzLmpzXG5pbXBvcnQgeyBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU4LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDEwIH0gZnJvbSBcInRocmVlXCI7XG52YXIgTHVtaW5hbmNlUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGx1bWluYW5jZSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuIFNlZSB7QGxpbmsgTHVtaW5hbmNlTWF0ZXJpYWx9IGZvciBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtvcHRpb25zLnJlbmRlclRhcmdldF0gLSBBIGN1c3RvbSByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTEuMF0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlbmRlclRhcmdldCxcbiAgICBsdW1pbmFuY2VSYW5nZSxcbiAgICBjb2xvck91dHB1dCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkx1bWluYW5jZVBhc3NcIik7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBuZXcgTHVtaW5hbmNlTWF0ZXJpYWwoY29sb3JPdXRwdXQsIGx1bWluYW5jZVJhbmdlKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgIGlmICh0aGlzLnJlbmRlclRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDEwKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJMdW1pbmFuY2VQYXNzLlRhcmdldFwiO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmlucHV0QnVmZmVyID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCAmJiBmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGU4KSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL01hc2tQYXNzLmpzXG52YXIgTWFza1Bhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBtYXNrIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBjYW1lcmEgdG8gdXNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSkge1xuICAgIHN1cGVyKFwiTWFza1Bhc3NcIiwgc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyUGFzcyA9IG5ldyBDbGVhclBhc3MoZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmludmVyc2UgPSBmYWxzZTtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5zY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1hc2sgc2hvdWxkIGJlIGludmVydGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZlcnNlO1xuICB9XG4gIHNldCBpbnZlcnRlZCh2YWx1ZSkge1xuICAgIHRoaXMuaW52ZXJzZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHBhc3Mgc2hvdWxkIGNsZWFyIHRoZSBzdGVuY2lsIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBjbGVhclBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmNsZWFyUGFzcy5lbmFibGVkO1xuICB9XG4gIHNldCBjbGVhcih2YWx1ZSkge1xuICAgIHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgY2xlYXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0NsZWFyUGFzc30gVGhlIGNsZWFyIHBhc3MuXG4gICAqL1xuICBnZXRDbGVhclBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWFzayBpcyBpbnZlcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG1hc2sgaXMgaW52ZXJ0ZWQuXG4gICAqL1xuICBpc0ludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmludmVydGVkO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGUgbWFzayBpbnZlcnNpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgbWFzayBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqL1xuICBzZXRJbnZlcnRlZCh2YWx1ZSkge1xuICAgIHRoaXMuaW52ZXJ0ZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSByZW5kZXJlci5zdGF0ZS5idWZmZXJzO1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCBjbGVhclBhc3MgPSB0aGlzLmNsZWFyUGFzcztcbiAgICBjb25zdCB3cml0ZVZhbHVlID0gdGhpcy5pbnZlcnRlZCA/IDAgOiAxO1xuICAgIGNvbnN0IGNsZWFyVmFsdWUgPSAxIC0gd3JpdGVWYWx1ZTtcbiAgICBidWZmZXJzLmNvbG9yLnNldE1hc2soZmFsc2UpO1xuICAgIGJ1ZmZlcnMuZGVwdGguc2V0TWFzayhmYWxzZSk7XG4gICAgYnVmZmVycy5jb2xvci5zZXRMb2NrZWQodHJ1ZSk7XG4gICAgYnVmZmVycy5kZXB0aC5zZXRMb2NrZWQodHJ1ZSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldFRlc3QodHJ1ZSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldE9wKGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFLCBjb250ZXh0LlJFUExBQ0UpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRGdW5jKGNvbnRleHQuQUxXQVlTLCB3cml0ZVZhbHVlLCA0Mjk0OTY3Mjk1KTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0Q2xlYXIoY2xlYXJWYWx1ZSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldExvY2tlZCh0cnVlKTtcbiAgICBpZiAodGhpcy5jbGVhclBhc3MuZW5hYmxlZCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgICAgY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlcik7XG4gICAgICAgIGNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIG91dHB1dEJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbmRlclRvU2NyZWVuKSB7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChpbnB1dEJ1ZmZlcik7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQob3V0cHV0QnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICB9XG4gICAgYnVmZmVycy5jb2xvci5zZXRMb2NrZWQoZmFsc2UpO1xuICAgIGJ1ZmZlcnMuZGVwdGguc2V0TG9ja2VkKGZhbHNlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0TG9ja2VkKGZhbHNlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0RnVuYyhjb250ZXh0LkVRVUFMLCAxLCA0Mjk0OTY3Mjk1KTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0T3AoY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVAsIGNvbnRleHQuS0VFUCk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldExvY2tlZCh0cnVlKTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9NaXBtYXBCbHVyUGFzcy5qc1xuaW1wb3J0IHsgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlOSwgVmVjdG9yMiBhcyBWZWN0b3IyMTUsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTEgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBNaXBtYXBCbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG1pcG1hcCBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiTWlwbWFwQmx1clBhc3NcIik7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDExKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiVXBzYW1wbGluZy5NaXBtYXAwXCI7XG4gICAgdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgdGhpcy51cHNhbXBsaW5nTWlwbWFwcyA9IFtdO1xuICAgIHRoaXMuZG93bnNhbXBsaW5nTWF0ZXJpYWwgPSBuZXcgRG93bnNhbXBsaW5nTWF0ZXJpYWwoKTtcbiAgICB0aGlzLnVwc2FtcGxpbmdNYXRlcmlhbCA9IG5ldyBVcHNhbXBsaW5nTWF0ZXJpYWwoKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBuZXcgVmVjdG9yMjE1KCk7XG4gIH1cbiAgLyoqXG4gICAqIEEgdGV4dHVyZSB0aGF0IGNvbnRhaW5zIHRoZSBibHVycmVkIHJlc3VsdC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIE1JUCBsZXZlbHMuIERlZmF1bHQgaXMgOC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBsZXZlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcy5sZW5ndGg7XG4gIH1cbiAgc2V0IGxldmVscyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmxldmVscyAhPT0gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMgPSBbXTtcbiAgICAgIHRoaXMudXBzYW1wbGluZ01pcG1hcHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWU7ICsraSkge1xuICAgICAgICBjb25zdCBtaXBtYXAgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcbiAgICAgICAgbWlwbWFwLnRleHR1cmUubmFtZSA9IFwiRG93bnNhbXBsaW5nLk1pcG1hcFwiICsgaTtcbiAgICAgICAgdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzLnB1c2gobWlwbWFwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBzYW1wbGluZ01pcG1hcHMucHVzaChyZW5kZXJUYXJnZXQpO1xuICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSB2YWx1ZSAtIDE7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgbWlwbWFwID0gcmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgICAgIG1pcG1hcC50ZXh0dXJlLm5hbWUgPSBcIlVwc2FtcGxpbmcuTWlwbWFwXCIgKyBpO1xuICAgICAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzLnB1c2gobWlwbWFwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U2l6ZSh0aGlzLnJlc29sdXRpb24ueCwgdGhpcy5yZXNvbHV0aW9uLnkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgcmFkaXVzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51cHNhbXBsaW5nTWF0ZXJpYWwucmFkaXVzO1xuICB9XG4gIHNldCByYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnVwc2FtcGxpbmdNYXRlcmlhbC5yYWRpdXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3QgeyBzY2VuZSwgY2FtZXJhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZG93bnNhbXBsaW5nTWF0ZXJpYWwsIHVwc2FtcGxpbmdNYXRlcmlhbCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGRvd25zYW1wbGluZ01pcG1hcHMsIHVwc2FtcGxpbmdNaXBtYXBzIH0gPSB0aGlzO1xuICAgIGxldCBwcmV2aW91c0J1ZmZlciA9IGlucHV0QnVmZmVyO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gZG93bnNhbXBsaW5nTWF0ZXJpYWw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBkb3duc2FtcGxpbmdNaXBtYXBzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgY29uc3QgbWlwbWFwID0gZG93bnNhbXBsaW5nTWlwbWFwc1tpXTtcbiAgICAgIGRvd25zYW1wbGluZ01hdGVyaWFsLnNldFNpemUocHJldmlvdXNCdWZmZXIud2lkdGgsIHByZXZpb3VzQnVmZmVyLmhlaWdodCk7XG4gICAgICBkb3duc2FtcGxpbmdNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobWlwbWFwKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHByZXZpb3VzQnVmZmVyID0gbWlwbWFwO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHVwc2FtcGxpbmdNYXRlcmlhbDtcbiAgICBmb3IgKGxldCBpID0gdXBzYW1wbGluZ01pcG1hcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IG1pcG1hcCA9IHVwc2FtcGxpbmdNaXBtYXBzW2ldO1xuICAgICAgdXBzYW1wbGluZ01hdGVyaWFsLnNldFNpemUocHJldmlvdXNCdWZmZXIud2lkdGgsIHByZXZpb3VzQnVmZmVyLmhlaWdodCk7XG4gICAgICB1cHNhbXBsaW5nTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgICAgdXBzYW1wbGluZ01hdGVyaWFsLnN1cHBvcnRCdWZmZXIgPSBkb3duc2FtcGxpbmdNaXBtYXBzW2ldLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobWlwbWFwKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHByZXZpb3VzQnVmZmVyID0gbWlwbWFwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIGxldCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgdyA9IE1hdGgucm91bmQodyAqIDAuNSk7XG4gICAgICBoID0gTWF0aC5yb3VuZChoICogMC41KTtcbiAgICAgIHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwc1tpXS5zZXRTaXplKHcsIGgpO1xuICAgICAgaWYgKGkgPCB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzW2ldLnNldFNpemUodywgaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG1pcG1hcHMgPSB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMuY29uY2F0KHRoaXMudXBzYW1wbGluZ01pcG1hcHMpO1xuICAgICAgZm9yIChjb25zdCBtaXBtYXAgb2YgbWlwbWFwcykge1xuICAgICAgICBtaXBtYXAudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTkpIHtcbiAgICAgICAgdGhpcy5kb3duc2FtcGxpbmdNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICAgIHRoaXMudXBzYW1wbGluZ01hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgIH0gZWxzZSBpZiAoZ2V0T3V0cHV0Q29sb3JTcGFjZShyZW5kZXJlcikgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWlwbWFwIG9mIG1pcG1hcHMpIHtcbiAgICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZShtaXBtYXAudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGludGVybmFsIHJlbmRlciB0YXJnZXRzIGFuZCB0ZXh0dXJlcy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIGZvciAoY29uc3QgbWlwbWFwIG9mIHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcy5jb25jYXQodGhpcy51cHNhbXBsaW5nTWlwbWFwcykpIHtcbiAgICAgIG1pcG1hcC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL05vcm1hbFBhc3MuanNcbmltcG9ydCB7IENvbG9yIGFzIENvbG9yMywgTWVzaE5vcm1hbE1hdGVyaWFsLCBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXI1LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDEyIH0gZnJvbSBcInRocmVlXCI7XG52YXIgTm9ybWFsUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vcm1hbCBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZSB0byByZW5kZXIgdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtvcHRpb25zLnJlbmRlclRhcmdldF0gLSBBIGN1c3RvbSByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTEuMF0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwge1xuICAgIHJlbmRlclRhcmdldCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIk5vcm1hbFBhc3NcIik7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhLCBuZXcgTWVzaE5vcm1hbE1hdGVyaWFsKCkpO1xuICAgIGNvbnN0IHJlbmRlclBhc3MgPSB0aGlzLnJlbmRlclBhc3M7XG4gICAgcmVuZGVyUGFzcy5pZ25vcmVCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICByZW5kZXJQYXNzLnNraXBTaGFkb3dNYXBVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnN0IGNsZWFyUGFzcyA9IHJlbmRlclBhc3MuZ2V0Q2xlYXJQYXNzKCk7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjMoNzgyOTUwMyk7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IDE7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgaWYgKHRoaXMucmVuZGVyVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTIoMSwgMSwge1xuICAgICAgICBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXI1LFxuICAgICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXI1XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiTm9ybWFsUGFzcy5UYXJnZXRcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyUGFzcy5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG5vcm1hbCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLnByZWZlcnJlZFdpZHRoIG9yIHJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0IGluc3RlYWQuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCBvciByZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNjZW5lIG5vcm1hbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5yZW5kZXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCByZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9TaGFkZXJQYXNzLmpzXG5pbXBvcnQgeyBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxMCB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIFNoYWRlclBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzaGFkZXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTaGFkZXJNYXRlcmlhbH0gbWF0ZXJpYWwgLSBBIHNoYWRlciBtYXRlcmlhbC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtpbnB1dD1cImlucHV0QnVmZmVyXCJdIC0gVGhlIG5hbWUgb2YgdGhlIGlucHV0IGJ1ZmZlciB1bmlmb3JtLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWF0ZXJpYWwsIGlucHV0ID0gXCJpbnB1dEJ1ZmZlclwiKSB7XG4gICAgc3VwZXIoXCJTaGFkZXJQYXNzXCIpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBpbnB1dCBidWZmZXIgdW5pZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IC0gVGhlIG5hbWUgb2YgdGhlIGlucHV0IGJ1ZmZlciB1bmlmb3JtLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXQgaW5zdGVhZC5cbiAgICovXG4gIHNldElucHV0KGlucHV0KSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgaWYgKGlucHV0QnVmZmVyICE9PSBudWxsICYmIHVuaWZvcm1zICE9PSB2b2lkIDAgJiYgdW5pZm9ybXNbdGhpcy5pbnB1dF0gIT09IHZvaWQgMCkge1xuICAgICAgdW5pZm9ybXNbdGhpcy5pbnB1dF0udmFsdWUgPSBpbnB1dEJ1ZmZlci50ZXh0dXJlO1xuICAgIH1cbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBvdXRwdXRCdWZmZXIpO1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCAmJiBmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUxMCkge1xuICAgICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9UaWx0U2hpZnRCbHVyUGFzcy5qc1xudmFyIFRpbHRTaGlmdEJsdXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBLYXdhc2VCbHVyUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEthd2FzZSBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldD0wLjBdIC0gVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTAuMF0gLSBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzQXJlYT0wLjRdIC0gVGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mZWF0aGVyPTAuM10gLSBUaGUgc29mdG5lc3Mgb2YgdGhlIGZvY3VzIGFyZWEgZWRnZXMuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLk1FRElVTV0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb2Zmc2V0ID0gMCxcbiAgICByb3RhdGlvbiA9IDAsXG4gICAgZm9jdXNBcmVhID0gMC40LFxuICAgIGZlYXRoZXIgPSAwLjMsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTUVESVVNLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDAuNSxcbiAgICByZXNvbHV0aW9uWCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25ZID0gUmVzb2x1dGlvbi5BVVRPX1NJWkVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBrZXJuZWxTaXplLCByZXNvbHV0aW9uU2NhbGUsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSB9KTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbCA9IG5ldyBUaWx0U2hpZnRCbHVyTWF0ZXJpYWwoeyBrZXJuZWxTaXplLCBvZmZzZXQsIHJvdGF0aW9uLCBmb2N1c0FyZWEsIGZlYXRoZXIgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL1RpbWVyLmpzXG52YXIgTUlMTElTRUNPTkRTX1RPX1NFQ09ORFMgPSAxIC8gMWUzO1xudmFyIFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTID0gMWUzO1xudmFyIFRpbWVyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB0aW1lci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5wcmV2aW91c1RpbWUgPSAwO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICB0aGlzLl9lbGFwc2VkID0gMDtcbiAgICB0aGlzLl9maXhlZERlbHRhID0gMWUzIC8gNjA7XG4gICAgdGhpcy50aW1lc2NhbGUgPSAxO1xuICAgIHRoaXMudXNlRml4ZWREZWx0YSA9IGZhbHNlO1xuICAgIHRoaXMuX2F1dG9SZXNldCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGF1dG8gcmVzZXQgYmFzZWQgb24gcGFnZSB2aXNpYmlsaXR5LlxuICAgKlxuICAgKiBJZiBlbmFibGVkLCB0aGUgdGltZXIgd2lsbCBiZSByZXNldCB3aGVuIHRoZSBwYWdlIGJlY29tZXMgdmlzaWJsZS4gVGhpcyBlZmZlY3RpdmVseSBwYXVzZXMgdGhlIHRpbWVyIHdoZW4gdGhlIHBhZ2VcbiAgICogaXMgaGlkZGVuLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBBUEkgaXMgbm90IHN1cHBvcnRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BhZ2VfVmlzaWJpbGl0eV9BUElcbiAgICovXG4gIGdldCBhdXRvUmVzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9SZXNldDtcbiAgfVxuICBzZXQgYXV0b1Jlc2V0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5oaWRkZW4gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hdXRvUmVzZXQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRlbHRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWx0YSAqIE1JTExJU0VDT05EU19UT19TRUNPTkRTO1xuICB9XG4gIGdldCBmaXhlZERlbHRhKCkge1xuICAgIHJldHVybiB0aGlzLl9maXhlZERlbHRhICogTUlMTElTRUNPTkRTX1RPX1NFQ09ORFM7XG4gIH1cbiAgc2V0IGZpeGVkRGVsdGEodmFsdWUpIHtcbiAgICB0aGlzLl9maXhlZERlbHRhID0gdmFsdWUgKiBTRUNPTkRTX1RPX01JTExJU0VDT05EUztcbiAgfVxuICBnZXQgZWxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxhcHNlZCAqIE1JTExJU0VDT05EU19UT19TRUNPTkRTO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgdGltZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RpbWVzdGFtcF0gLSBUaGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZSh0aW1lc3RhbXApIHtcbiAgICBpZiAodGhpcy51c2VGaXhlZERlbHRhKSB7XG4gICAgICB0aGlzLl9kZWx0YSA9IHRoaXMuZml4ZWREZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmV2aW91c1RpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5jdXJyZW50VGltZSA9ICh0aW1lc3RhbXAgIT09IHZvaWQgMCA/IHRpbWVzdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgdGhpcy5fZGVsdGEgPSB0aGlzLmN1cnJlbnRUaW1lIC0gdGhpcy5wcmV2aW91c1RpbWU7XG4gICAgfVxuICAgIHRoaXMuX2RlbHRhICo9IHRoaXMudGltZXNjYWxlO1xuICAgIHRoaXMuX2VsYXBzZWQgKz0gdGhpcy5fZGVsdGE7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIHRpbWVyLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fZGVsdGEgPSAwO1xuICAgIHRoaXMuX2VsYXBzZWQgPSAwO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICB9XG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5hdXRvUmVzZXQgPSBmYWxzZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvRWZmZWN0Q29tcG9zZXIuanNcbnZhciBFZmZlY3RDb21wb3NlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZWZmZWN0IGNvbXBvc2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZXB0aEJ1ZmZlcj10cnVlXSAtIFdoZXRoZXIgdGhlIG1haW4gcmVuZGVyIHRhcmdldHMgc2hvdWxkIGhhdmUgYSBkZXB0aCBidWZmZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RlbmNpbEJ1ZmZlcj1mYWxzZV0gLSBXaGV0aGVyIHRoZSBtYWluIHJlbmRlciB0YXJnZXRzIHNob3VsZCBoYXZlIGEgc3RlbmNpbCBidWZmZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxwaGFdIC0gRGVwcmVjYXRlZC4gQnVmZmVycyBhcmUgYWx3YXlzIFJHQkEgc2luY2UgdGhyZWUgcjEzNy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpc2FtcGxpbmc9MF0gLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgdXNlZCBmb3IgbXVsdGlzYW1wbGUgYW50aWFsaWFzaW5nLiBSZXF1aXJlcyBXZWJHTCAyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVCdWZmZXJUeXBlXSAtIFRoZSB0eXBlIG9mIHRoZSBpbnRlcm5hbCBmcmFtZSBidWZmZXJzLiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBIYWxmRmxvYXRUeXBlIGlmIHBvc3NpYmxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIgPSBudWxsLCB7XG4gICAgZGVwdGhCdWZmZXIgPSB0cnVlLFxuICAgIHN0ZW5jaWxCdWZmZXIgPSBmYWxzZSxcbiAgICBtdWx0aXNhbXBsaW5nID0gMCxcbiAgICBmcmFtZUJ1ZmZlclR5cGVcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5pbnB1dEJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKGRlcHRoQnVmZmVyLCBzdGVuY2lsQnVmZmVyLCBmcmFtZUJ1ZmZlclR5cGUsIG11bHRpc2FtcGxpbmcpO1xuICAgIHRoaXMub3V0cHV0QnVmZmVyID0gdGhpcy5pbnB1dEJ1ZmZlci5jbG9uZSgpO1xuICAgIHRoaXMuY29weVBhc3MgPSBuZXcgQ29weVBhc3MoKTtcbiAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5wYXNzZXMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gbmV3IFRpbWVyKCk7XG4gICAgdGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4gPSB0cnVlO1xuICAgIHRoaXMuc2V0UmVuZGVyZXIocmVuZGVyZXIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBhbW91bnQgb2Ygc2FtcGxlcyB1c2VkIGZvciBtdWx0aXNhbXBsZSBhbnRpLWFsaWFzaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG11bHRpc2FtcGxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRCdWZmZXIuc2FtcGxlcyB8fCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhbW91bnQgb2YgTVNBQSBzYW1wbGVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyBXZWJHTCAyLiBTZXQgdG8gemVybyB0byBkaXNhYmxlIG11bHRpc2FtcGxpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgbXVsdGlzYW1wbGluZyh2YWx1ZSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuaW5wdXRCdWZmZXI7XG4gICAgY29uc3QgbXVsdGlzYW1wbGluZyA9IHRoaXMubXVsdGlzYW1wbGluZztcbiAgICBpZiAobXVsdGlzYW1wbGluZyA+IDAgJiYgdmFsdWUgPiAwKSB7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLnNhbXBsZXMgPSB2YWx1ZTtcbiAgICAgIHRoaXMub3V0cHV0QnVmZmVyLnNhbXBsZXMgPSB2YWx1ZTtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5vdXRwdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgIH0gZWxzZSBpZiAobXVsdGlzYW1wbGluZyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5vdXRwdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKFxuICAgICAgICBidWZmZXIuZGVwdGhCdWZmZXIsXG4gICAgICAgIGJ1ZmZlci5zdGVuY2lsQnVmZmVyLFxuICAgICAgICBidWZmZXIudGV4dHVyZS50eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGVwdGhUZXh0dXJlID0gdGhpcy5kZXB0aFRleHR1cmU7XG4gICAgICB0aGlzLm91dHB1dEJ1ZmZlciA9IHRoaXMuaW5wdXRCdWZmZXIuY2xvbmUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludGVybmFsIHRpbWVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lcn0gVGhlIHRpbWVyLlxuICAgKi9cbiAgZ2V0VGltZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIuXG4gICAqL1xuICBnZXRSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqL1xuICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICBpZiAocmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNpemUgPSByZW5kZXJlci5nZXRTaXplKG5ldyBWZWN0b3IyMTYoKSk7XG4gICAgICBjb25zdCBhbHBoYSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhO1xuICAgICAgY29uc3QgZnJhbWVCdWZmZXJUeXBlID0gdGhpcy5pbnB1dEJ1ZmZlci50ZXh0dXJlLnR5cGU7XG4gICAgICBpZiAoZnJhbWVCdWZmZXJUeXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlMTEgJiYgZ2V0T3V0cHV0Q29sb3JTcGFjZShyZW5kZXJlcikgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMuaW5wdXRCdWZmZXIudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLm91dHB1dEJ1ZmZlci50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm91dHB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5wYXNzZXMpIHtcbiAgICAgICAgcGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgICpcbiAgICogVGhlIGF1dG8gY2xlYXIgbWVjaGFuaXNtIG9mIHRoZSBwcm92aWRlZCByZW5kZXJlciB3aWxsIGJlIGRpc2FibGVkLiBJZiB0aGUgbmV3IHJlbmRlciBzaXplIGRpZmZlcnMgZnJvbSB0aGVcbiAgICogcHJldmlvdXMgb25lLCBhbGwgcGFzc2VzIHdpbGwgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBjdXJyZW50IHJlbmRlcmVyIHdpbGwgYXV0b21hdGljYWxseSBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBub2RlIGFuZCB0aGUgRE9NXG4gICAqIGVsZW1lbnQgb2YgdGhlIG5ldyByZW5kZXJlciB3aWxsIHRha2UgaXRzIHBsYWNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0UmVuZGVyZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSBuZXcgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlRE9NIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG9sZCBjYW52YXMgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IHRoZSBuZXcgb25lIGluIHRoZSBET00uXG4gICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyZXJ9IFRoZSBvbGQgcmVuZGVyZXIuXG4gICAqL1xuICByZXBsYWNlUmVuZGVyZXIocmVuZGVyZXIsIHVwZGF0ZURPTSA9IHRydWUpIHtcbiAgICBjb25zdCBvbGRSZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgcGFyZW50ID0gb2xkUmVuZGVyZXIuZG9tRWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHRoaXMuc2V0UmVuZGVyZXIocmVuZGVyZXIpO1xuICAgIGlmICh1cGRhdGVET00gJiYgcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQob2xkUmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvbGRSZW5kZXJlcjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRlcHRoIHRleHR1cmUgYXR0YWNobWVudCB0aGF0IHdpbGwgYmUgcHJvdmlkZWQgdG8gYWxsIHBhc3Nlcy5cbiAgICpcbiAgICogTm90ZTogV2hlbiBhIHNoYWRlciByZWFkcyBmcm9tIGEgZGVwdGggdGV4dHVyZSBhbmQgd3JpdGVzIHRvIGEgcmVuZGVyIHRhcmdldCB0aGF0IHVzZXMgdGhlIHNhbWUgZGVwdGggdGV4dHVyZVxuICAgKiBhdHRhY2htZW50LCB0aGUgZGVwdGggaW5mb3JtYXRpb24gd2lsbCBiZSBsb3N0LiBUaGlzIGhhcHBlbnMgZXZlbiBpZiBgZGVwdGhXcml0ZWAgaXMgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0RlcHRoVGV4dHVyZX0gVGhlIGRlcHRoIHRleHR1cmUuXG4gICAqL1xuICBjcmVhdGVEZXB0aFRleHR1cmUoKSB7XG4gICAgY29uc3QgZGVwdGhUZXh0dXJlID0gdGhpcy5kZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlKCk7XG4gICAgdGhpcy5pbnB1dEJ1ZmZlci5kZXB0aFRleHR1cmUgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgaWYgKHRoaXMuaW5wdXRCdWZmZXIuc3RlbmNpbEJ1ZmZlcikge1xuICAgICAgZGVwdGhUZXh0dXJlLmZvcm1hdCA9IERlcHRoU3RlbmNpbEZvcm1hdDtcbiAgICAgIGRlcHRoVGV4dHVyZS50eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXB0aFRleHR1cmUudHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcHRoVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgY3VycmVudCBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVsZXRlRGVwdGhUZXh0dXJlKCkge1xuICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZXB0aFRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsO1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kZXB0aFRleHR1cmUgPSBudWxsO1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5wYXNzZXMpIHtcbiAgICAgICAgcGFzcy5zZXREZXB0aFRleHR1cmUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJlbmRlciB0YXJnZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIENyZWF0ZSBidWZmZXJzIG1hbnVhbGx5IHZpYSBXZWJHTFJlbmRlclRhcmdldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlcHRoQnVmZmVyIC0gV2hldGhlciB0aGUgcmVuZGVyIHRhcmdldCBzaG91bGQgaGF2ZSBhIGRlcHRoIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBzdGVuY2lsQnVmZmVyIC0gV2hldGhlciB0aGUgcmVuZGVyIHRhcmdldCBzaG91bGQgaGF2ZSBhIHN0ZW5jaWwgYnVmZmVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdHlwZSAtIFRoZSBmcmFtZSBidWZmZXIgdHlwZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpc2FtcGxpbmcgLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgdG8gdXNlIGZvciBhbnRpYWxpYXNpbmcuXG4gICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyVGFyZ2V0fSBBIG5ldyByZW5kZXIgdGFyZ2V0IHRoYXQgZXF1YWxzIHRoZSByZW5kZXJlcidzIGNhbnZhcy5cbiAgICovXG4gIGNyZWF0ZUJ1ZmZlcihkZXB0aEJ1ZmZlciwgc3RlbmNpbEJ1ZmZlciwgdHlwZSwgbXVsdGlzYW1wbGluZykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBzaXplID0gcmVuZGVyZXIgPT09IG51bGwgPyBuZXcgVmVjdG9yMjE2KCkgOiByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShuZXcgVmVjdG9yMjE2KCkpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtaW5GaWx0ZXI6IExpbmVhckZpbHRlcjIsXG4gICAgICBtYWdGaWx0ZXI6IExpbmVhckZpbHRlcjIsXG4gICAgICBzdGVuY2lsQnVmZmVyLFxuICAgICAgZGVwdGhCdWZmZXIsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxMyhzaXplLndpZHRoLCBzaXplLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgaWYgKG11bHRpc2FtcGxpbmcgPiAwKSB7XG4gICAgICByZW5kZXJUYXJnZXQuaWdub3JlRGVwdGhGb3JNdWx0aXNhbXBsZUNvcHkgPSBmYWxzZTtcbiAgICAgIHJlbmRlclRhcmdldC5zYW1wbGVzID0gbXVsdGlzYW1wbGluZztcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUxMSAmJiBnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHJlbmRlclRhcmdldC50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgfVxuICAgIHJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkVmZmVjdENvbXBvc2VyLkJ1ZmZlclwiO1xuICAgIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIHJldHVybiByZW5kZXJUYXJnZXQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgbWFpbiBzY2VuZSBmb3IgYWxsIHJlZ2lzdGVyZWQgcGFzc2VzIGFuZCBlZmZlY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZS5cbiAgICovXG4gIHNldE1haW5TY2VuZShzY2VuZSkge1xuICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgcGFzcy5tYWluU2NlbmUgPSBzY2VuZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgbWFpbiBjYW1lcmEgZm9yIGFsbCByZWdpc3RlcmVkIHBhc3NlcyBhbmQgZWZmZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBjYW1lcmEuXG4gICAqL1xuICBzZXRNYWluQ2FtZXJhKGNhbWVyYSkge1xuICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgcGFzcy5tYWluQ2FtZXJhID0gY2FtZXJhO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHBhc3MsIG9wdGlvbmFsbHkgYXQgYSBzcGVjaWZpYyBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtQYXNzfSBwYXNzIC0gQSBuZXcgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gLSBBbiBpbmRleCBhdCB3aGljaCB0aGUgcGFzcyBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqL1xuICBhZGRQYXNzKHBhc3MsIGluZGV4KSB7XG4gICAgY29uc3QgcGFzc2VzID0gdGhpcy5wYXNzZXM7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGRyYXdpbmdCdWZmZXJTaXplID0gcmVuZGVyZXIuZ2V0RHJhd2luZ0J1ZmZlclNpemUobmV3IFZlY3RvcjIxNigpKTtcbiAgICBjb25zdCBhbHBoYSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhO1xuICAgIGNvbnN0IGZyYW1lQnVmZmVyVHlwZSA9IHRoaXMuaW5wdXRCdWZmZXIudGV4dHVyZS50eXBlO1xuICAgIHBhc3Muc2V0UmVuZGVyZXIocmVuZGVyZXIpO1xuICAgIHBhc3Muc2V0U2l6ZShkcmF3aW5nQnVmZmVyU2l6ZS53aWR0aCwgZHJhd2luZ0J1ZmZlclNpemUuaGVpZ2h0KTtcbiAgICBwYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIGlmICh0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbikge1xuICAgICAgaWYgKHBhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhc3Nlc1twYXNzZXMubGVuZ3RoIC0gMV0ucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXNzLnJlbmRlclRvU2NyZWVuKSB7XG4gICAgICAgIHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXNzZXMuc3BsaWNlKGluZGV4LCAwLCBwYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFzc2VzLnB1c2gocGFzcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbikge1xuICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwYXNzLm5lZWRzRGVwdGhUZXh0dXJlIHx8IHRoaXMuZGVwdGhUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZGVwdGhUZXh0dXJlID0gdGhpcy5jcmVhdGVEZXB0aFRleHR1cmUoKTtcbiAgICAgICAgZm9yIChwYXNzIG9mIHBhc3Nlcykge1xuICAgICAgICAgIHBhc3Muc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhc3Muc2V0RGVwdGhUZXh0dXJlKHRoaXMuZGVwdGhUZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3N9IHBhc3MgLSBUaGUgcGFzcy5cbiAgICovXG4gIHJlbW92ZVBhc3MocGFzcykge1xuICAgIGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xuICAgIGNvbnN0IGluZGV4ID0gcGFzc2VzLmluZGV4T2YocGFzcyk7XG4gICAgY29uc3QgZXhpc3RzID0gaW5kZXggIT09IC0xO1xuICAgIGNvbnN0IHJlbW92ZWQgPSBleGlzdHMgJiYgcGFzc2VzLnNwbGljZShpbmRleCwgMSkubGVuZ3RoID4gMDtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXIgPSAoYSwgYikgPT4gYSB8fCBiLm5lZWRzRGVwdGhUZXh0dXJlO1xuICAgICAgICBjb25zdCBkZXB0aFRleHR1cmVSZXF1aXJlZCA9IHBhc3Nlcy5yZWR1Y2UocmVkdWNlciwgZmFsc2UpO1xuICAgICAgICBpZiAoIWRlcHRoVGV4dHVyZVJlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHBhc3MuZ2V0RGVwdGhUZXh0dXJlKCkgPT09IHRoaXMuZGVwdGhUZXh0dXJlKSB7XG4gICAgICAgICAgICBwYXNzLnNldERlcHRoVGV4dHVyZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZWxldGVEZXB0aFRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gcGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIHBhc3MucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICBpZiAocGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhc3Nlc1twYXNzZXMubGVuZ3RoIC0gMV0ucmVuZGVyVG9TY3JlZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgcGFzc2VzLlxuICAgKi9cbiAgcmVtb3ZlQWxsUGFzc2VzKCkge1xuICAgIGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xuICAgIHRoaXMuZGVsZXRlRGVwdGhUZXh0dXJlKCk7XG4gICAgaWYgKHBhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXNzZXMgPSBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgYWxsIGVuYWJsZWQgcGFzc2VzIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGZyYW1lIGluIHNlY29uZHMuXG4gICAqL1xuICByZW5kZXIoZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGNvcHlQYXNzID0gdGhpcy5jb3B5UGFzcztcbiAgICBsZXQgaW5wdXRCdWZmZXIgPSB0aGlzLmlucHV0QnVmZmVyO1xuICAgIGxldCBvdXRwdXRCdWZmZXIgPSB0aGlzLm91dHB1dEJ1ZmZlcjtcbiAgICBsZXQgc3RlbmNpbFRlc3QgPSBmYWxzZTtcbiAgICBsZXQgY29udGV4dCwgc3RlbmNpbCwgYnVmZmVyO1xuICAgIGlmIChkZWx0YVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50aW1lci51cGRhdGUoKTtcbiAgICAgIGRlbHRhVGltZSA9IHRoaXMudGltZXIuZGVsdGE7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgaWYgKHBhc3MuZW5hYmxlZCkge1xuICAgICAgICBwYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCk7XG4gICAgICAgIGlmIChwYXNzLm5lZWRzU3dhcCkge1xuICAgICAgICAgIGlmIChzdGVuY2lsVGVzdCkge1xuICAgICAgICAgICAgY29weVBhc3MucmVuZGVyVG9TY3JlZW4gPSBwYXNzLnJlbmRlclRvU2NyZWVuO1xuICAgICAgICAgICAgY29udGV4dCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgIHN0ZW5jaWwgPSByZW5kZXJlci5zdGF0ZS5idWZmZXJzLnN0ZW5jaWw7XG4gICAgICAgICAgICBzdGVuY2lsLnNldEZ1bmMoY29udGV4dC5OT1RFUVVBTCwgMSwgNDI5NDk2NzI5NSk7XG4gICAgICAgICAgICBjb3B5UGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpO1xuICAgICAgICAgICAgc3RlbmNpbC5zZXRGdW5jKGNvbnRleHQuRVFVQUwsIDEsIDQyOTQ5NjcyOTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSBpbnB1dEJ1ZmZlcjtcbiAgICAgICAgICBpbnB1dEJ1ZmZlciA9IG91dHB1dEJ1ZmZlcjtcbiAgICAgICAgICBvdXRwdXRCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhc3MgaW5zdGFuY2VvZiBNYXNrUGFzcykge1xuICAgICAgICAgIHN0ZW5jaWxUZXN0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXNzIGluc3RhbmNlb2YgQ2xlYXJNYXNrUGFzcykge1xuICAgICAgICAgIHN0ZW5jaWxUZXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlcnMsIHBhc3NlcyBhbmQgdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt1cGRhdGVTdHlsZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN0eWxlIG9mIHRoZSBjYW52YXMgc2hvdWxkIGJlIHVwZGF0ZWQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGN1cnJlbnRTaXplID0gcmVuZGVyZXIuZ2V0U2l6ZShuZXcgVmVjdG9yMjE2KCkpO1xuICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwIHx8IGhlaWdodCA9PT0gdm9pZCAwKSB7XG4gICAgICB3aWR0aCA9IGN1cnJlbnRTaXplLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gY3VycmVudFNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoY3VycmVudFNpemUud2lkdGggIT09IHdpZHRoIHx8IGN1cnJlbnRTaXplLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd2luZ0J1ZmZlclNpemUgPSByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShuZXcgVmVjdG9yMjE2KCkpO1xuICAgIHRoaXMuaW5wdXRCdWZmZXIuc2V0U2l6ZShkcmF3aW5nQnVmZmVyU2l6ZS53aWR0aCwgZHJhd2luZ0J1ZmZlclNpemUuaGVpZ2h0KTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlci5zZXRTaXplKGRyYXdpbmdCdWZmZXJTaXplLndpZHRoLCBkcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQpO1xuICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgcGFzcy5zZXRTaXplKGRyYXdpbmdCdWZmZXJTaXplLndpZHRoLCBkcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgY29tcG9zZXIgYnkgZGVsZXRpbmcgYWxsIHBhc3NlcyBhbmQgY3JlYXRpbmcgbmV3IGJ1ZmZlcnMuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBjb25zdCBhdXRvUmVzZXQgPSB0aGlzLnRpbWVyLmF1dG9SZXNldDtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gICAgdGhpcy50aW1lci5hdXRvUmVzZXQgPSBhdXRvUmVzZXQ7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgY29tcG9zZXIgYW5kIGFsbCBwYXNzZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgcGFzcy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMucGFzc2VzID0gW107XG4gICAgaWYgKHRoaXMuaW5wdXRCdWZmZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRwdXRCdWZmZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3V0cHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5kZWxldGVEZXB0aFRleHR1cmUoKTtcbiAgICB0aGlzLmNvcHlQYXNzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnRpbWVyLmRpc3Bvc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvRWZmZWN0U2hhZGVyRGF0YS5qc1xudmFyIEVmZmVjdFNoYWRlckRhdGEgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIG5ldyBzaGFkZXIgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2hhZGVyUGFydHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFELCBudWxsXSxcbiAgICAgIFtFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYsIG51bGxdLFxuICAgICAgW0VmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSwgbnVsbF0sXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfSEVBRCwgbnVsbF0sXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JULCBudWxsXVxuICAgIF0pO1xuICAgIHRoaXMuZGVmaW5lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy51bmlmb3JtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5ibGVuZE1vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IEVmZmVjdEF0dHJpYnV0ZS5OT05FO1xuICAgIHRoaXMudmFyeWluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudXZUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMucmVhZERlcHRoID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL0dhdXNzS2VybmVsLmpzXG5mdW5jdGlvbiBnZXRDb2VmZmljaWVudHMobikge1xuICBsZXQgcmVzdWx0O1xuICBpZiAobiA9PT0gMCkge1xuICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoMCk7XG4gIH0gZWxzZSBpZiAobiA9PT0gMSkge1xuICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoWzFdKTtcbiAgfSBlbHNlIGlmIChuID4gMSkge1xuICAgIGxldCByb3cwID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICBsZXQgcm93MSA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgZm9yIChsZXQgeSA9IDE7IHkgPD0gbjsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHk7ICsreCkge1xuICAgICAgICByb3cxW3hdID0geCA9PT0gMCB8fCB4ID09PSB5IC0gMSA/IDEgOiByb3cwW3ggLSAxXSArIHJvdzBbeF07XG4gICAgICB9XG4gICAgICByZXN1bHQgPSByb3cxO1xuICAgICAgcm93MSA9IHJvdzA7XG4gICAgICByb3cwID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEdhdXNzS2VybmVsID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBHYXVzcyBrZXJuZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBrZXJuZWxTaXplIC0gVGhlIGtlcm5lbCBzaXplLiBTaG91bGQgYmUgYW4gb2RkIG51bWJlciBpbiB0aGUgcmFuZ2UgWzMsIDEwMjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VkZ2VCaWFzPTJdIC0gRGV0ZXJtaW5lcyBob3cgbWFueSBlZGdlIGNvZWZmaWNpZW50cyBzaG91bGQgYmUgY3V0IG9mZiBmb3IgaW5jcmVhc2VkIGFjY3VyYWN5LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2VybmVsU2l6ZSwgZWRnZUJpYXMgPSAyKSB7XG4gICAgdGhpcy53ZWlnaHRzID0gbnVsbDtcbiAgICB0aGlzLm9mZnNldHMgPSBudWxsO1xuICAgIHRoaXMubGluZWFyV2VpZ2h0cyA9IG51bGw7XG4gICAgdGhpcy5saW5lYXJPZmZzZXRzID0gbnVsbDtcbiAgICB0aGlzLmdlbmVyYXRlKGtlcm5lbFNpemUsIGVkZ2VCaWFzKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzdGVwcyBmb3IgZGlzY3JldGUgc2FtcGxpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0cyA9PT0gbnVsbCA/IDAgOiB0aGlzLm9mZnNldHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHN0ZXBzIGZvciBsaW5lYXIgc2FtcGxpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbGluZWFyU3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZWFyT2Zmc2V0cyA9PT0gbnVsbCA/IDAgOiB0aGlzLmxpbmVhck9mZnNldHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGtlcm5lbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGtlcm5lbFNpemUgLSBUaGUga2VybmVsIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlZGdlQmlhcyAtIFRoZSBhbW91bnQgb2YgZWRnZSBjb2VmZmljaWVudHMgdG8gaWdub3JlLlxuICAgKi9cbiAgZ2VuZXJhdGUoa2VybmVsU2l6ZSwgZWRnZUJpYXMpIHtcbiAgICBpZiAoa2VybmVsU2l6ZSA8IDMgfHwga2VybmVsU2l6ZSA+IDEwMjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBrZXJuZWwgc2l6ZSBtdXN0IGJlIGluIHRoZSByYW5nZSBbMywgMTAyMF1cIik7XG4gICAgfVxuICAgIGNvbnN0IG4gPSBrZXJuZWxTaXplICsgZWRnZUJpYXMgKiAyO1xuICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IGVkZ2VCaWFzID4gMCA/IGdldENvZWZmaWNpZW50cyhuKS5zbGljZShlZGdlQmlhcywgLWVkZ2VCaWFzKSA6IGdldENvZWZmaWNpZW50cyhuKTtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChjb2VmZmljaWVudHMubGVuZ3RoIC0gMSkgLyAyKTtcbiAgICBjb25zdCBzdW0gPSBjb2VmZmljaWVudHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IGNvZWZmaWNpZW50cy5zbGljZShtaWQpO1xuICAgIGNvbnN0IG9mZnNldHMgPSBbLi4uQXJyYXkobWlkICsgMSkua2V5cygpXTtcbiAgICBjb25zdCBsaW5lYXJXZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShNYXRoLmZsb29yKG9mZnNldHMubGVuZ3RoIC8gMikpO1xuICAgIGNvbnN0IGxpbmVhck9mZnNldHMgPSBuZXcgRmxvYXQ2NEFycmF5KGxpbmVhcldlaWdodHMubGVuZ3RoKTtcbiAgICBsaW5lYXJXZWlnaHRzWzBdID0gd2VpZ2h0c1swXSAvIHN1bTtcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDEsIGwgPSBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgPCBsOyBpICs9IDIsICsraikge1xuICAgICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldHNbaV0sIG9mZnNldDEgPSBvZmZzZXRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IHdlaWdodDAgPSB3ZWlnaHRzW2ldLCB3ZWlnaHQxID0gd2VpZ2h0c1tpICsgMV07XG4gICAgICBjb25zdCB3ID0gd2VpZ2h0MCArIHdlaWdodDE7XG4gICAgICBjb25zdCBvID0gKG9mZnNldDAgKiB3ZWlnaHQwICsgb2Zmc2V0MSAqIHdlaWdodDEpIC8gdztcbiAgICAgIGxpbmVhcldlaWdodHNbal0gPSB3IC8gc3VtO1xuICAgICAgbGluZWFyT2Zmc2V0c1tqXSA9IG87XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gd2VpZ2h0cy5sZW5ndGgsIHMgPSAxIC8gc3VtOyBpIDwgbDsgKytpKSB7XG4gICAgICB3ZWlnaHRzW2ldICo9IHM7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVhcldlaWdodFN1bSA9IChsaW5lYXJXZWlnaHRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC0gbGluZWFyV2VpZ2h0c1swXSAqIDAuNSkgKiAyO1xuICAgIGlmIChsaW5lYXJXZWlnaHRTdW0gIT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZWFyV2VpZ2h0cy5sZW5ndGgsIHMgPSAxIC8gbGluZWFyV2VpZ2h0U3VtOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGxpbmVhcldlaWdodHNbaV0gKj0gcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICB0aGlzLndlaWdodHMgPSB3ZWlnaHRzO1xuICAgIHRoaXMubGluZWFyT2Zmc2V0cyA9IGxpbmVhck9mZnNldHM7XG4gICAgdGhpcy5saW5lYXJXZWlnaHRzID0gbGluZWFyV2VpZ2h0cztcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvSW1tdXRhYmxlVGltZXIuanNcbnZhciBJbW11dGFibGVUaW1lciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGRlbHRhIHRpbWUgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkZWx0YSgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZml4ZWQgZGVsdGEgdGltZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZpeGVkRGVsdGEoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICAvKipcbiAgICogVGhlIGVsYXBzZWQgdGltZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGVsYXBzZWQoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvSW5pdGlhbGl6YWJsZS5qc1xudmFyIEluaXRpYWxpemFibGUgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIuanNcbmltcG9ydCB7IEJhY2tTaWRlLCBEb3VibGVTaWRlLCBGcm9udFNpZGUsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMjIgfSBmcm9tIFwidGhyZWVcIjtcbnZhciB3b3JrYXJvdW5kRW5hYmxlZCA9IGZhbHNlO1xudmFyIE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBvdmVycmlkZSBtYXRlcmlhbCBtYW5hZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbbWF0ZXJpYWw9bnVsbF0gLSBBbiBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hdGVyaWFsID0gbnVsbCkge1xuICAgIHRoaXMub3JpZ2luYWxNYXRlcmlhbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzID0gbnVsbDtcbiAgICB0aGlzLm1hdGVyaWFsc0JhY2tTaWRlID0gbnVsbDtcbiAgICB0aGlzLm1hdGVyaWFsc0RvdWJsZVNpZGUgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZCA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkQmFja1NpZGUgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGUgPSBudWxsO1xuICAgIHRoaXMuc2V0TWF0ZXJpYWwobWF0ZXJpYWwpO1xuICAgIHRoaXMubWVzaENvdW50ID0gMDtcbiAgICB0aGlzLnJlcGxhY2VNYXRlcmlhbCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZS5pc01lc2gpIHtcbiAgICAgICAgbGV0IG1hdGVyaWFscztcbiAgICAgICAgaWYgKG5vZGUubWF0ZXJpYWwuZmxhdFNoYWRpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUubWF0ZXJpYWwuc2lkZSkge1xuICAgICAgICAgICAgY2FzZSBEb3VibGVTaWRlOlxuICAgICAgICAgICAgICBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWREb3VibGVTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmFja1NpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZEJhY2tTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAobm9kZS5tYXRlcmlhbC5zaWRlKSB7XG4gICAgICAgICAgICBjYXNlIERvdWJsZVNpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJhY2tTaWRlOlxuICAgICAgICAgICAgICBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFsc0JhY2tTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5hbE1hdGVyaWFscy5zZXQobm9kZSwgbm9kZS5tYXRlcmlhbCk7XG4gICAgICAgIGlmIChub2RlLmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgICAgICBub2RlLm1hdGVyaWFsID0gbWF0ZXJpYWxzWzJdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaXNJbnN0YW5jZWRNZXNoKSB7XG4gICAgICAgICAgbm9kZS5tYXRlcmlhbCA9IG1hdGVyaWFsc1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLm1hdGVyaWFsID0gbWF0ZXJpYWxzWzBdO1xuICAgICAgICB9XG4gICAgICAgICsrdGhpcy5tZXNoQ291bnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBnaXZlbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWwgLSBUaGUgbWF0ZXJpYWwuXG4gICAqIEByZXR1cm4ge01hdGVyaWFsfSBUaGUgY2xvbmVkIG1hdGVyaWFsLlxuICAgKi9cbiAgY2xvbmVNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIGlmICghKG1hdGVyaWFsIGluc3RhbmNlb2YgU2hhZGVyTWF0ZXJpYWwyMikpIHtcbiAgICAgIHJldHVybiBtYXRlcmlhbC5jbG9uZSgpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuICAgIGNvbnN0IHRleHR1cmVVbmlmb3JtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdW5pZm9ybXNba2V5XS52YWx1ZTtcbiAgICAgIGlmICh2YWx1ZS5pc1JlbmRlclRhcmdldFRleHR1cmUpIHtcbiAgICAgICAgdW5pZm9ybXNba2V5XS52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRleHR1cmVVbmlmb3Jtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNsb25lID0gbWF0ZXJpYWwuY2xvbmUoKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRleHR1cmVVbmlmb3Jtcykge1xuICAgICAgdW5pZm9ybXNbZW50cnlbMF1dLnZhbHVlID0gZW50cnlbMV07XG4gICAgICBjbG9uZS51bmlmb3Jtc1tlbnRyeVswXV0udmFsdWUgPSBlbnRyeVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWwgLSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIHRoaXMuZGlzcG9zZU1hdGVyaWFscygpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICBpZiAobWF0ZXJpYWwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzID0gW1xuICAgICAgICB0aGlzLmNsb25lTWF0ZXJpYWwobWF0ZXJpYWwpLFxuICAgICAgICB0aGlzLmNsb25lTWF0ZXJpYWwobWF0ZXJpYWwpLFxuICAgICAgICB0aGlzLmNsb25lTWF0ZXJpYWwobWF0ZXJpYWwpXG4gICAgICBdO1xuICAgICAgZm9yIChjb25zdCBtMiBvZiBtYXRlcmlhbHMpIHtcbiAgICAgICAgbTIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIG0yLnNpZGUgPSBGcm9udFNpZGU7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbHNbMl0uc2tpbm5pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5tYXRlcmlhbHNCYWNrU2lkZSA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLnNpZGUgPSBCYWNrU2lkZTtcbiAgICAgICAgcmV0dXJuIGMyO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hdGVyaWFsc0RvdWJsZVNpZGUgPSBtYXRlcmlhbHMubWFwKChtMikgPT4ge1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuY2xvbmVNYXRlcmlhbChtMik7XG4gICAgICAgIGMyLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICBjMi5zaWRlID0gRG91YmxlU2lkZTtcbiAgICAgICAgcmV0dXJuIGMyO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWQgPSBtYXRlcmlhbHMubWFwKChtMikgPT4ge1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuY2xvbmVNYXRlcmlhbChtMik7XG4gICAgICAgIGMyLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICBjMi5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBjMjtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkQmFja1NpZGUgPSBtYXRlcmlhbHMubWFwKChtMikgPT4ge1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuY2xvbmVNYXRlcmlhbChtMik7XG4gICAgICAgIGMyLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICBjMi5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIGMyLnNpZGUgPSBCYWNrU2lkZTtcbiAgICAgICAgcmV0dXJuIGMyO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWREb3VibGVTaWRlID0gbWF0ZXJpYWxzLm1hcCgobTIpID0+IHtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmNsb25lTWF0ZXJpYWwobTIpO1xuICAgICAgICBjMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgYzIuZmxhdFNoYWRpbmcgPSB0cnVlO1xuICAgICAgICBjMi5zaWRlID0gRG91YmxlU2lkZTtcbiAgICAgICAgcmV0dXJuIGMyO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzY2VuZSB3aXRoIHRoZSBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBBIHNjZW5lLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEpIHtcbiAgICBjb25zdCBzaGFkb3dNYXBFbmFibGVkID0gcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSBmYWxzZTtcbiAgICBpZiAod29ya2Fyb3VuZEVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWF0ZXJpYWxzID0gdGhpcy5vcmlnaW5hbE1hdGVyaWFscztcbiAgICAgIHRoaXMubWVzaENvdW50ID0gMDtcbiAgICAgIHNjZW5lLnRyYXZlcnNlKHRoaXMucmVwbGFjZU1hdGVyaWFsKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2Ygb3JpZ2luYWxNYXRlcmlhbHMpIHtcbiAgICAgICAgZW50cnlbMF0ubWF0ZXJpYWwgPSBlbnRyeVsxXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lc2hDb3VudCAhPT0gb3JpZ2luYWxNYXRlcmlhbHMuc2l6ZSkge1xuICAgICAgICBvcmlnaW5hbE1hdGVyaWFscy5jbGVhcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcbiAgICAgIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG4gICAgfVxuICAgIHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gc2hhZG93TWFwRW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBjbG9uZWQgb3ZlcnJpZGUgbWF0ZXJpYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcG9zZU1hdGVyaWFscygpIHtcbiAgICBpZiAodGhpcy5tYXRlcmlhbCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHMuY29uY2F0KHRoaXMubWF0ZXJpYWxzQmFja1NpZGUpLmNvbmNhdCh0aGlzLm1hdGVyaWFsc0RvdWJsZVNpZGUpLmNvbmNhdCh0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWQpLmNvbmNhdCh0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWRCYWNrU2lkZSkuY29uY2F0KHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGUpO1xuICAgICAgZm9yIChjb25zdCBtMiBvZiBtYXRlcmlhbHMpIHtcbiAgICAgICAgbTIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgY2xlYW51cCB0YXNrcy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5vcmlnaW5hbE1hdGVyaWFscy5jbGVhcigpO1xuICAgIHRoaXMuZGlzcG9zZU1hdGVyaWFscygpO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgb3ZlcnJpZGUgbWF0ZXJpYWwgd29ya2Fyb3VuZCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgd29ya2Fyb3VuZEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHdvcmthcm91bmRFbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBvdmVycmlkZSBtYXRlcmlhbCB3b3JrYXJvdW5kIGdsb2JhbGx5LlxuICAgKlxuICAgKiBUaGlzIG9ubHkgYWZmZWN0cyBwb3N0IHByb2Nlc3NpbmcgcGFzc2VzIGFuZCBlZmZlY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBzZXQgd29ya2Fyb3VuZEVuYWJsZWQodmFsdWUpIHtcbiAgICB3b3JrYXJvdW5kRW5hYmxlZCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9SZXNpemFibGUuanNcbnZhciBSZXNpemFibGUgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL1Jlc29sdXRpb24uanNcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciwgVmVjdG9yMiBhcyBWZWN0b3IyMTcgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBBVVRPX1NJWkUgPSAtMTtcbnZhciBSZXNvbHV0aW9uID0gY2xhc3MgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyByZXNvbHV0aW9uLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSByZXNpemFibGUgcGFyYW0uXG4gICAqIEBwYXJhbSB7UmVzaXphYmxlfSByZXNpemFibGUgLSBBIHJlc2l6YWJsZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHByZWZlcnJlZCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHByZWZlcnJlZCBoZWlnaHQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MS4wXSAtIEEgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc2l6YWJsZSwgd2lkdGggPSBBVVRPX1NJWkUsIGhlaWdodCA9IEFVVE9fU0laRSwgc2NhbGUgPSAxKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlc2l6YWJsZSA9IHJlc2l6YWJsZTtcbiAgICB0aGlzLmJhc2VTaXplID0gbmV3IFZlY3RvcjIxNygxLCAxKTtcbiAgICB0aGlzLnByZWZlcnJlZFNpemUgPSBuZXcgVmVjdG9yMjE3KHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5wcmVmZXJyZWRTaXplO1xuICAgIHRoaXMucyA9IHNjYWxlO1xuICAgIHRoaXMuZWZmZWN0aXZlU2l6ZSA9IG5ldyBWZWN0b3IyMTcoKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4gdGhpcy51cGRhdGVFZmZlY3RpdmVTaXplKCkpO1xuICAgIHRoaXMudXBkYXRlRWZmZWN0aXZlU2l6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBlZmZlY3RpdmUgc2l6ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUVmZmVjdGl2ZVNpemUoKSB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYmFzZVNpemU7XG4gICAgY29uc3QgcHJlZmVycmVkID0gdGhpcy5wcmVmZXJyZWRTaXplO1xuICAgIGNvbnN0IGVmZmVjdGl2ZSA9IHRoaXMuZWZmZWN0aXZlU2l6ZTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgaWYgKHByZWZlcnJlZC53aWR0aCAhPT0gQVVUT19TSVpFKSB7XG4gICAgICBlZmZlY3RpdmUud2lkdGggPSBwcmVmZXJyZWQud2lkdGg7XG4gICAgfSBlbHNlIGlmIChwcmVmZXJyZWQuaGVpZ2h0ICE9PSBBVVRPX1NJWkUpIHtcbiAgICAgIGVmZmVjdGl2ZS53aWR0aCA9IE1hdGgucm91bmQocHJlZmVycmVkLmhlaWdodCAqIChiYXNlLndpZHRoIC8gTWF0aC5tYXgoYmFzZS5oZWlnaHQsIDEpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdGl2ZS53aWR0aCA9IE1hdGgucm91bmQoYmFzZS53aWR0aCAqIHNjYWxlKTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZC5oZWlnaHQgIT09IEFVVE9fU0laRSkge1xuICAgICAgZWZmZWN0aXZlLmhlaWdodCA9IHByZWZlcnJlZC5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChwcmVmZXJyZWQud2lkdGggIT09IEFVVE9fU0laRSkge1xuICAgICAgZWZmZWN0aXZlLmhlaWdodCA9IE1hdGgucm91bmQocHJlZmVycmVkLndpZHRoIC8gTWF0aC5tYXgoYmFzZS53aWR0aCAvIE1hdGgubWF4KGJhc2UuaGVpZ2h0LCAxKSwgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3RpdmUuaGVpZ2h0ID0gTWF0aC5yb3VuZChiYXNlLmhlaWdodCAqIHNjYWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZmZlY3RpdmUgd2lkdGguXG4gICAqXG4gICAqIElmIHRoZSBwcmVmZXJyZWQgd2lkdGggYW5kIGhlaWdodCBhcmUgc2V0IHRvIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0sIHRoZSBiYXNlIHdpZHRoIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0aXZlU2l6ZS53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnByZWZlcnJlZFdpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZmZlY3RpdmUgaGVpZ2h0LlxuICAgKlxuICAgKiBJZiB0aGUgcHJlZmVycmVkIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNldCB0byB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9LCB0aGUgYmFzZSBoZWlnaHQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0aXZlU2l6ZS5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZmVycmVkSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSB3aWR0aC5cbiAgICpcbiAgICogSWYgdGhlIHByZWZlcnJlZCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzZXQgdG8ge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfSwgdGhlIGJhc2Ugd2lkdGggd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdpZHRoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGVmZmVjdGl2ZSB3aWR0aC5cbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgaGVpZ2h0LlxuICAgKlxuICAgKiBJZiB0aGUgcHJlZmVycmVkIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNldCB0byB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9LCB0aGUgYmFzZSBoZWlnaHQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlZmZlY3RpdmUgaGVpZ2h0LlxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucztcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5zID0gdmFsdWU7XG4gICAgICB0aGlzLnByZWZlcnJlZFNpemUuc2V0U2NhbGFyKEFVVE9fU0laRSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBBbHNvIHNldHMgdGhlIHByZWZlcnJlZCByZXNvbHV0aW9uIHRvIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2NhbGUuXG4gICAqL1xuICBzZXRTY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2Ugd2lkdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYmFzZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VTaXplLndpZHRoO1xuICB9XG4gIHNldCBiYXNlV2lkdGgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5iYXNlU2l6ZS53aWR0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuYmFzZVNpemUud2lkdGggPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2Ugd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBiYXNlV2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYmFzZSB3aWR0aC5cbiAgICovXG4gIGdldEJhc2VXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlV2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhc2Ugd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBiYXNlV2lkdGggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHdpZHRoLlxuICAgKi9cbiAgc2V0QmFzZVdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5iYXNlV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaGVpZ2h0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJhc2VIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVNpemUuaGVpZ2h0O1xuICB9XG4gIHNldCBiYXNlSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuYmFzZVNpemUuaGVpZ2h0ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5iYXNlU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgaGVpZ2h0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmFzZUhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBiYXNlIGhlaWdodC5cbiAgICovXG4gIGdldEJhc2VIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUhlaWdodDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSBoZWlnaHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBiYXNlSGVpZ2h0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRCYXNlSGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5iYXNlSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhc2Ugc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5iYXNlU2l6ZS53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgdGhpcy5iYXNlU2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByZWZlcnJlZFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnByZWZlcnJlZFNpemUud2lkdGg7XG4gIH1cbiAgc2V0IHByZWZlcnJlZFdpZHRoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucHJlZmVycmVkU2l6ZS53aWR0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucHJlZmVycmVkU2l6ZS53aWR0aCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZmVycmVkV2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKi9cbiAgZ2V0UHJlZmVycmVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmVycmVkV2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWZlcnJlZCB3aWR0aC5cbiAgICpcbiAgICogVXNlIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0gdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSBoZWlnaHQgYW5kIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlcnJlZFdpZHRoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSB3aWR0aC5cbiAgICovXG4gIHNldFByZWZlcnJlZFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwcmVmZXJyZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmVycmVkU2l6ZS5oZWlnaHQ7XG4gIH1cbiAgc2V0IHByZWZlcnJlZEhlaWdodCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZWZlcnJlZFNpemUuaGVpZ2h0ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5wcmVmZXJyZWRTaXplLmhlaWdodCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBwcmVmZXJyZWQgaGVpZ2h0LlxuICAgKi9cbiAgZ2V0UHJlZmVycmVkSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnByZWZlcnJlZEhlaWdodDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICpcbiAgICogVXNlIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0gdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdGhlIGhlaWdodCBiYXNlZCBvbiB0aGUgd2lkdGggYW5kIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0UHJlZmVycmVkSGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZmVycmVkIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRQcmVmZXJyZWRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5wcmVmZXJyZWRTaXplLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLnByZWZlcnJlZFNpemUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgIHRoaXMucHJlZmVycmVkU2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIGdpdmVuIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVzb2x1dGlvbn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29weShyZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zID0gcmVzb2x1dGlvbi5zY2FsZTtcbiAgICB0aGlzLmJhc2VTaXplLnNldChyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KTtcbiAgICB0aGlzLnByZWZlcnJlZFNpemUuc2V0KHJlc29sdXRpb24ucHJlZmVycmVkV2lkdGgsIHJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBBbiBhdXRvIHNpemluZyBjb25zdGFudC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdGhlIHdpZHRoIG9yIGhlaWdodCBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgYXNwZWN0IHJhdGlvLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBBVVRPX1NJWkUoKSB7XG4gICAgcmV0dXJuIEFVVE9fU0laRTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvU2VsZWN0aW9uLmpzXG52YXIgU2VsZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBTZXQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8T2JqZWN0M0Q+fSBbaXRlcmFibGVdIC0gQSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhpcyBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbGF5ZXI9MTBdIC0gQSBkZWRpY2F0ZWQgcmVuZGVyIGxheWVyIGZvciBzZWxlY3RlZCBvYmplY3RzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXRlcmFibGUsIGxheWVyID0gMTApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubCA9IGxheWVyO1xuICAgIHRoaXMuZXhjbHVzaXZlID0gZmFsc2U7XG4gICAgaWYgKGl0ZXJhYmxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuc2V0KGl0ZXJhYmxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZW5kZXIgbGF5ZXIgZm9yIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubDtcbiAgfVxuICBzZXQgbGF5ZXIodmFsdWUpIHtcbiAgICBjb25zdCBjdXJyZW50TGF5ZXIgPSB0aGlzLmw7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgdGhpcykge1xuICAgICAgb2JqZWN0LmxheWVycy5kaXNhYmxlKGN1cnJlbnRMYXllcik7XG4gICAgICBvYmplY3QubGF5ZXJzLmVuYWJsZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMubCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlciBsYXllciBmb3Igc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgbGF5ZXIgaXMgMTAuIElmIHRoaXMgY29sbGlkZXMgd2l0aCB5b3VyIG93biBjdXN0b20gbGF5ZXJzLCBwbGVhc2UgY2hhbmdlIGl0IGJlZm9yZSByZW5kZXJpbmchXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsYXllciBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBsYXllci5cbiAgICovXG4gIGdldExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXIgbGF5ZXIgZm9yIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqXG4gICAqIFRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsYXllciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbGF5ZXIuIFJhbmdlIGlzIFswLCAzMV0uXG4gICAqL1xuICBzZXRMYXllcih2YWx1ZSkge1xuICAgIHRoaXMubGF5ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cyB0aGF0IGFyZSBhZGRlZCB0byB0aGlzIHNlbGVjdGlvbiB3aWxsIGJlIHJlbW92ZWQgZnJvbSBhbGwgb3RoZXIgbGF5ZXJzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXhjbHVzaXZlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gV2hldGhlciB0aGlzIHNlbGVjdGlvbiBpcyBleGNsdXNpdmUuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqL1xuICBpc0V4Y2x1c2l2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leGNsdXNpdmU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoZXRoZXIgb2JqZWN0cyB0aGF0IGFyZSBhZGRlZCB0byB0aGlzIHNlbGVjdGlvbiBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGFsbCBvdGhlciBsYXllcnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleGNsdXNpdmUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gV2hldGhlciB0aGlzIHNlbGVjdGlvbiBzaG91bGQgYmUgZXhjbHVzaXZlLlxuICAgKi9cbiAgc2V0RXhjbHVzaXZlKHZhbHVlKSB7XG4gICAgdGhpcy5leGNsdXNpdmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoaXMgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoaXMgc2VsZWN0aW9uLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIHRoaXMpIHtcbiAgICAgIG9iamVjdC5sYXllcnMuZGlzYWJsZShsYXllcik7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5jbGVhcigpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhpcyBzZWxlY3Rpb24gYW5kIGFkZHMgdGhlIGdpdmVuIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8T2JqZWN0M0Q+fSBvYmplY3RzIC0gVGhlIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQuXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhpcyBzZWxlY3Rpb24uXG4gICAqL1xuICBzZXQob2JqZWN0cykge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBvYmplY3RzKSB7XG4gICAgICB0aGlzLmFkZChvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQW4gYWxpYXMgZm9yIHtAbGluayBoYXN9LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBBbiBvYmplY3QuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyAwIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgY3VycmVudGx5IHNlbGVjdGVkLCBvciAtMSBvdGhlcndpc2UuXG4gICAqIEBkZXByZWNhdGVkIEFkZGVkIGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5LlxuICAgKi9cbiAgaW5kZXhPZihvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMob2JqZWN0KSA/IDAgOiAtMTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBvYmplY3QgdG8gdGhpcyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIElmIHtAbGluayBleGNsdXNpdmV9IGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBvYmplY3Qgd2lsbCBhbHNvIGJlIHJlbW92ZWQgZnJvbSBhbGwgb3RoZXIgbGF5ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkLlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoaXMgc2VsZWN0aW9uLlxuICAgKi9cbiAgYWRkKG9iamVjdCkge1xuICAgIGlmICh0aGlzLmV4Y2x1c2l2ZSkge1xuICAgICAgb2JqZWN0LmxheWVycy5zZXQodGhpcy5sYXllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdC5sYXllcnMuZW5hYmxlKHRoaXMubGF5ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuYWRkKG9iamVjdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gb2JqZWN0IGZyb20gdGhpcyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgZGVzZWxlY3RlZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBoYXMgc3VjY2Vzc2Z1bGx5IGJlZW4gcmVtb3ZlZCBmcm9tIHRoaXMgc2VsZWN0aW9uOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBkZWxldGUob2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuaGFzKG9iamVjdCkpIHtcbiAgICAgIG9iamVjdC5sYXllcnMuZGlzYWJsZSh0aGlzLmxheWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIG9iamVjdCBmcm9tIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBvYmplY3QgZG9lc24ndCBleGlzdCBpdCdzIGFkZGVkIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFkZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICB0b2dnbGUob2JqZWN0KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodGhpcy5oYXMob2JqZWN0KSkge1xuICAgICAgdGhpcy5kZWxldGUob2JqZWN0KTtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChvYmplY3QpO1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiBhbGwgc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZW5hYmxlcyBvciBkaXNhYmxlcyByZW5kZXIgbGF5ZXIgMCBvZiBhbGwgc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIC0gV2hldGhlciB0aGUgc2VsZWN0ZWQgb2JqZWN0cyBzaG91bGQgYmUgdmlzaWJsZS5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGlzIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldFZpc2libGUodmlzaWJsZSkge1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIHRoaXMpIHtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIG9iamVjdC5sYXllcnMuZW5hYmxlKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0LmxheWVycy5kaXNhYmxlKDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvQmxlbmRNb2RlLmpzXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgYXMgRXZlbnREaXNwYXRjaGVyMiwgVW5pZm9ybSBhcyBVbmlmb3JtMjMgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9hZGQuZnJhZ1xudmFyIGFkZF9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHgreSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvYWxwaGEuZnJhZ1xudmFyIGFscGhhX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseSxtaW4oeS5hLG9wYWNpdHkpKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvYXZlcmFnZS5mcmFnXG52YXIgYXZlcmFnZV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LCh4K3kpKjAuNSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvY29sb3IuZnJhZ1xudmFyIGNvbG9yX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeUhTTC5yZyx4SFNMLmIpKTtyZXR1cm4gdmVjNChtaXgoeC5yZ2IseixvcGFjaXR5KSx5LmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9jb2xvci1idXJuLmZyYWdcbnZhciBjb2xvcl9idXJuX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWM0IHo9bWl4KHN0ZXAoMC4wLHkpKigxLjAtbWluKHZlYzQoMS4wKSwoMS4wLXgpL3kpKSx2ZWM0KDEuMCksc3RlcCgxLjAseCkpO3JldHVybiBtaXgoeCx6LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9jb2xvci1kb2RnZS5mcmFnXG52YXIgY29sb3JfZG9kZ2VfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgej1zdGVwKDAuMCx4KSptaXgobWluKHZlYzQoMS4wKSx4L21heCgxLjAteSwxZS05KSksdmVjNCgxLjApLHN0ZXAoMS4wLHkpKTtyZXR1cm4gbWl4KHgseixvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvZGFya2VuLmZyYWdcbnZhciBkYXJrZW5fZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCxtaW4oeCx5KSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvZGlmZmVyZW5jZS5mcmFnXG52YXIgZGlmZmVyZW5jZV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LGFicyh4LXkpLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9kaXZpZGUuZnJhZ1xudmFyIGRpdmlkZV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHgvbWF4KHksMWUtMTIpLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9leGNsdXNpb24uZnJhZ1xudmFyIGV4Y2x1c2lvbl9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LCh4K3ktMi4wKngqeSksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2hhcmQtbGlnaHQuZnJhZ1xudmFyIGhhcmRfbGlnaHRfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgYT1taW4oeCwxLjApLGI9bWluKHksMS4wKTt2ZWM0IHo9bWl4KDIuMCphKmIsMS4wLTIuMCooMS4wLWEpKigxLjAtYiksc3RlcCgwLjUseSkpO3JldHVybiBtaXgoeCx6LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9oYXJkLW1peC5mcmFnXG52YXIgaGFyZF9taXhfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCxzdGVwKDEuMCx4K3kpLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9odWUuZnJhZ1xudmFyIGh1ZV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyB4SFNMPVJHQlRvSFNMKHgucmdiKTt2ZWMzIHlIU0w9UkdCVG9IU0woeS5yZ2IpO3ZlYzMgej1IU0xUb1JHQih2ZWMzKHlIU0wucix4SFNMLmdiKSk7cmV0dXJuIHZlYzQobWl4KHgucmdiLHosb3BhY2l0eSkseS5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvaW52ZXJ0LmZyYWdcbnZhciBpbnZlcnRfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCwxLjAteSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvaW52ZXJ0LXJnYi5mcmFnXG52YXIgaW52ZXJ0X3JnYl9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHkqKDEuMC14KSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbGlnaHRlbi5mcmFnXG52YXIgbGlnaHRlbl9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LG1heCh4LHkpLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saW5lYXItYnVybi5mcmFnXG52YXIgbGluZWFyX2J1cm5fZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCxjbGFtcCh5K3gtMS4wLDAuMCwxLjApLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saW5lYXItZG9kZ2UuZnJhZ1xudmFyIGxpbmVhcl9kb2RnZV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LG1pbih4K3ksMS4wKSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbGluZWFyLWxpZ2h0LmZyYWdcbnZhciBsaW5lYXJfbGlnaHRfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCxjbGFtcCgyLjAqeSt4LTEuMCwwLjAsMS4wKSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbHVtaW5vc2l0eS5mcmFnXG52YXIgbHVtaW5vc2l0eV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyB4SFNMPVJHQlRvSFNMKHgucmdiKTt2ZWMzIHlIU0w9UkdCVG9IU0woeS5yZ2IpO3ZlYzMgej1IU0xUb1JHQih2ZWMzKHhIU0wucmcseUhTTC5iKSk7cmV0dXJuIHZlYzQobWl4KHgucmdiLHosb3BhY2l0eSkseS5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbXVsdGlwbHkuZnJhZ1xudmFyIG11bHRpcGx5X2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseCp5LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9uZWdhdGlvbi5mcmFnXG52YXIgbmVnYXRpb25fZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCwxLjAtYWJzKDEuMC14LXkpLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9ub3JtYWwuZnJhZ1xudmFyIG5vcm1hbF9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL292ZXJsYXkuZnJhZ1xudmFyIG92ZXJsYXlfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgej1taXgoMi4wKnkqeCwxLjAtMi4wKigxLjAteSkqKDEuMC14KSxzdGVwKDAuNSx4KSk7cmV0dXJuIG1peCh4LHosb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3Bpbi1saWdodC5mcmFnXG52YXIgcGluX2xpZ2h0X2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWM0IHkyPTIuMCp5O3ZlYzQgej1taXgobWl4KHkyLHgsc3RlcCgwLjUqeCx5KSksbWF4KHZlYzQoMC4wKSx5Mi0xLjApLHN0ZXAoeCwoeTItMS4wKSkpO3JldHVybiBtaXgoeCx6LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9yZWZsZWN0LmZyYWdcbnZhciByZWZsZWN0X2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWM0IHo9bWl4KG1pbih4KngvbWF4KDEuMC15LDFlLTEyKSwxLjApLHksc3RlcCgxLjAseSkpO3JldHVybiBtaXgoeCx6LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zYXR1cmF0aW9uLmZyYWdcbnZhciBzYXR1cmF0aW9uX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeEhTTC5yLHlIU0wuZyx4SFNMLmIpKTtyZXR1cm4gdmVjNChtaXgoeC5yZ2IseixvcGFjaXR5KSx5LmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zY3JlZW4uZnJhZ1xudmFyIHNjcmVlbl9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHgreS1taW4oeCp5LDEuMCksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3NvZnQtbGlnaHQuZnJhZ1xudmFyIHNvZnRfbGlnaHRfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgeTI9Mi4wKnk7dmVjNCB3PXN0ZXAoMC41LHkpO3ZlYzQgej1taXgoeC0oMS4wLXkyKSp4KigxLjAteCksbWl4KHgrKHkyLTEuMCkqKHNxcnQoeCkteCkseCsoeTItMS4wKSp4KigoMTYuMCp4LTEyLjApKngrMy4wKSx3KigxLjAtc3RlcCgwLjI1LHgpKSksdyk7cmV0dXJuIG1peCh4LHosb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3NyYy5mcmFnXG52YXIgc3JjX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4geTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvc3VidHJhY3QuZnJhZ1xudmFyIHN1YnRyYWN0X2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsbWF4KHgreS0xLjAsMC4wKSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvdml2aWQtbGlnaHQuZnJhZ1xudmFyIHZpdmlkX2xpZ2h0X2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWM0IHo9bWl4KG1heCgxLjAtbWluKCgxLjAteCkvKDIuMCp5KSwxLjApLDAuMCksbWluKHgvKDIuMCooMS4wLXkpKSwxLjApLHN0ZXAoMC41LHkpKTtyZXR1cm4gbWl4KHgseixvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL0JsZW5kTW9kZS5qc1xudmFyIGJsZW5kRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbQmxlbmRGdW5jdGlvbi5BREQsIGFkZF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uQUxQSEEsIGFscGhhX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5BVkVSQUdFLCBhdmVyYWdlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5DT0xPUiwgY29sb3JfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkNPTE9SX0JVUk4sIGNvbG9yX2J1cm5fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkNPTE9SX0RPREdFLCBjb2xvcl9kb2RnZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uREFSS0VOLCBkYXJrZW5fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkRJRkZFUkVOQ0UsIGRpZmZlcmVuY2VfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkRJVklERSwgZGl2aWRlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5EU1QsIG51bGxdLFxuICBbQmxlbmRGdW5jdGlvbi5FWENMVVNJT04sIGV4Y2x1c2lvbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uSEFSRF9MSUdIVCwgaGFyZF9saWdodF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uSEFSRF9NSVgsIGhhcmRfbWl4X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5IVUUsIGh1ZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uSU5WRVJULCBpbnZlcnRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLklOVkVSVF9SR0IsIGludmVydF9yZ2JfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkxJR0hURU4sIGxpZ2h0ZW5fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkxJTkVBUl9CVVJOLCBsaW5lYXJfYnVybl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTElORUFSX0RPREdFLCBsaW5lYXJfZG9kZ2VfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkxJTkVBUl9MSUdIVCwgbGluZWFyX2xpZ2h0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5MVU1JTk9TSVRZLCBsdW1pbm9zaXR5X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5NVUxUSVBMWSwgbXVsdGlwbHlfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLk5FR0FUSU9OLCBuZWdhdGlvbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTk9STUFMLCBub3JtYWxfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLk9WRVJMQVksIG92ZXJsYXlfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlBJTl9MSUdIVCwgcGluX2xpZ2h0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5SRUZMRUNULCByZWZsZWN0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5TQVRVUkFUSU9OLCBzYXR1cmF0aW9uX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5TQ1JFRU4sIHNjcmVlbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uU09GVF9MSUdIVCwgc29mdF9saWdodF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uU1JDLCBzcmNfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlNVQlRSQUNULCBzdWJ0cmFjdF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uVklWSURfTElHSFQsIHZpdmlkX2xpZ2h0X2RlZmF1bHRdXG5dKTtcbnZhciBCbGVuZE1vZGUgPSBjbGFzcyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcjIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBibGVuZCBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IGJsZW5kRnVuY3Rpb24gLSBUaGUgYmxlbmQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcGFjaXR5IC0gVGhlIG9wYWNpdHkgb2YgdGhlIGNvbG9yIHRoYXQgd2lsbCBiZSBibGVuZGVkIHdpdGggdGhlIGJhc2UgY29sb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihibGVuZEZ1bmN0aW9uLCBvcGFjaXR5ID0gMSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYmxlbmRGdW5jdGlvbiA9IGJsZW5kRnVuY3Rpb247XG4gICAgdGhpcy5vcGFjaXR5ID0gbmV3IFVuaWZvcm0yMyhvcGFjaXR5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIGdldE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG9wYWNpdHkuXG4gICAqL1xuICBzZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5vcGFjaXR5LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHR5cGUge0JsZW5kRnVuY3Rpb259XG4gICAqL1xuICBnZXQgYmxlbmRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRGdW5jdGlvbjtcbiAgfVxuICBzZXQgYmxlbmRGdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2JsZW5kRnVuY3Rpb24gPSB2YWx1ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kRnVuY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7QmxlbmRGdW5jdGlvbn0gVGhlIGJsZW5kIGZ1bmN0aW9uLlxuICAgKi9cbiAgZ2V0QmxlbmRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ibGVuZEZ1bmN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kRnVuY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSB2YWx1ZSAtIFRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICovXG4gIHNldEJsZW5kRnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmJsZW5kRnVuY3Rpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmxlbmQgZnVuY3Rpb24gc2hhZGVyIGNvZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGJsZW5kIGZ1bmN0aW9uIHNoYWRlciBjb2RlLlxuICAgKi9cbiAgZ2V0U2hhZGVyQ29kZSgpIHtcbiAgICByZXR1cm4gYmxlbmRGdW5jdGlvbnMuZ2V0KHRoaXMuYmxlbmRGdW5jdGlvbik7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0Jsb29tRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0yNCwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9FZmZlY3QuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTMsIEV2ZW50RGlzcGF0Y2hlciBhcyBFdmVudERpc3BhdGNoZXIzLCBNYXRlcmlhbCBhcyBNYXRlcmlhbDIsIFRleHR1cmUgYXMgVGV4dHVyZTIsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTQgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcjMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhpcyBlZmZlY3QuIERvZXNuJ3QgaGF2ZSB0byBiZSB1bmlxdWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnbWVudFNoYWRlciAtIFRoZSBmcmFnbWVudCBzaGFkZXIuIFRoaXMgc2hhZGVyIGlzIHJlcXVpcmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0VmZmVjdEF0dHJpYnV0ZX0gW29wdGlvbnMuYXR0cmlidXRlcz1FZmZlY3RBdHRyaWJ1dGUuTk9ORV0gLSBUaGUgZWZmZWN0IGF0dHJpYnV0ZXMgdGhhdCBkZXRlcm1pbmUgdGhlIGV4ZWN1dGlvbiBwcmlvcml0eSBhbmQgcmVzb3VyY2UgcmVxdWlyZW1lbnRzLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5OT1JNQUxdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFN0cmluZz59IFtvcHRpb25zLmRlZmluZXNdIC0gQ3VzdG9tIHByZXByb2Nlc3NvciBtYWNybyBkZWZpbml0aW9ucy4gS2V5cyBhcmUgbmFtZXMgYW5kIHZhbHVlcyBhcmUgY29kZS5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gW29wdGlvbnMudW5pZm9ybXNdIC0gQ3VzdG9tIHNoYWRlciB1bmlmb3Jtcy4gS2V5cyBhcmUgbmFtZXMgYW5kIHZhbHVlcyBhcmUgdW5pZm9ybXMuXG4gICAqIEBwYXJhbSB7U2V0PFdlYkdMRXh0ZW5zaW9uPn0gW29wdGlvbnMuZXh0ZW5zaW9uc10gLSBXZWJHTCBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudmVydGV4U2hhZGVyPW51bGxdIC0gVGhlIHZlcnRleCBzaGFkZXIuIE1vc3QgZWZmZWN0cyBkb24ndCBuZWVkIG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG5hbWUsIGZyYWdtZW50U2hhZGVyLCB7XG4gICAgYXR0cmlidXRlcyA9IEVmZmVjdEF0dHJpYnV0ZS5OT05FLFxuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLk5PUk1BTCxcbiAgICBkZWZpbmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICB1bmlmb3JtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgZXh0ZW5zaW9ucyA9IG51bGwsXG4gICAgdmVydGV4U2hhZGVyID0gbnVsbFxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgdGhpcy5kZWZpbmVzID0gZGVmaW5lcztcbiAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB0aGlzLmJsZW5kTW9kZSA9IG5ldyBCbGVuZE1vZGUoYmxlbmRGdW5jdGlvbik7XG4gICAgdGhpcy5ibGVuZE1vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHRoaXMuc2V0Q2hhbmdlZCgpKTtcbiAgICB0aGlzLl9pbnB1dENvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICB0aGlzLl9vdXRwdXRDb2xvclNwYWNlID0gTm9Db2xvclNwYWNlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgY29sb3Igc3BhY2UuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvclNwYWNlfVxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBnZXQgaW5wdXRDb2xvclNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dENvbG9yU3BhY2U7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtDb2xvclNwYWNlfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNldCBpbnB1dENvbG9yU3BhY2UodmFsdWUpIHtcbiAgICB0aGlzLl9pbnB1dENvbG9yU3BhY2UgPSB2YWx1ZTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG91dHB1dCBjb2xvciBzcGFjZS5cbiAgICpcbiAgICogU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBpZiB0aGlzIGVmZmVjdCBjb252ZXJ0cyB0aGUgaW5wdXQgY29sb3JzIHRvIGEgZGlmZmVyZW50IGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3JTcGFjZX1cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgZ2V0IG91dHB1dENvbG9yU3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX291dHB1dENvbG9yU3BhY2U7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtDb2xvclNwYWNlfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNldCBvdXRwdXRDb2xvclNwYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5fb3V0cHV0Q29sb3JTcGFjZSA9IHZhbHVlO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYWluIHNjZW5lLlxuICAgKlxuICAgKiBAdHlwZSB7U2NlbmV9XG4gICAqL1xuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1haW4gY2FtZXJhLlxuICAgKlxuICAgKiBAdHlwZSB7Q2FtZXJhfVxuICAgKi9cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5hbWUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgbmFtZS5cbiAgICovXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqL1xuICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlcHJvY2Vzc29yIG1hY3JvIGRlZmluaXRpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVmaW5lcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtNYXA8U3RyaW5nLCBTdHJpbmc+fSBUaGUgZXh0ZW5zaW9ucy5cbiAgICovXG4gIGdldERlZmluZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5pZm9ybXMgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB1bmlmb3JtcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gVGhlIGV4dGVuc2lvbnMuXG4gICAqL1xuICBnZXRVbmlmb3JtcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3JtcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgV2ViR0wgZXh0ZW5zaW9ucyB0aGF0IGFyZSByZXF1aXJlZCBieSB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGV4dGVuc2lvbnMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7U2V0PFdlYkdMRXh0ZW5zaW9uPn0gVGhlIGV4dGVuc2lvbnMuXG4gICAqL1xuICBnZXRFeHRlbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsZW5kIG1vZGUuXG4gICAqXG4gICAqIFRoZSByZXN1bHQgb2YgdGhpcyBlZmZlY3Qgd2lsbCBiZSBibGVuZGVkIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgZWZmZWN0IHVzaW5nIHRoaXMgYmxlbmQgbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kTW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCbGVuZE1vZGV9IFRoZSBibGVuZCBtb2RlLlxuICAgKi9cbiAgZ2V0QmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmJsZW5kTW9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWZmZWN0IGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0VmZmVjdEF0dHJpYnV0ZX0gVGhlIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVmZmVjdCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBFZmZlY3RzIHRoYXQgaGF2ZSB0aGUgc2FtZSBhdHRyaWJ1dGVzIHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLiBTb21lIGF0dHJpYnV0ZXNcbiAgICogaW1wbHkgYSBoaWdoZXIgcHJpb3JpdHkuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtFZmZlY3RBdHRyaWJ1dGV9IGF0dHJpYnV0ZXMgLSBUaGUgYXR0cmlidXRlcy5cbiAgICovXG4gIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKi9cbiAgZ2V0RnJhZ21lbnRTaGFkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRTaGFkZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJhZ21lbnRTaGFkZXIgLSBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKi9cbiAgc2V0RnJhZ21lbnRTaGFkZXIoZnJhZ21lbnRTaGFkZXIpIHtcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHZlcnRleCBzaGFkZXIuXG4gICAqL1xuICBnZXRWZXJ0ZXhTaGFkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVydGV4U2hhZGVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0ZXhTaGFkZXIgLSBUaGUgdmVydGV4IHNoYWRlci5cbiAgICovXG4gIHNldFZlcnRleFNoYWRlcih2ZXJ0ZXhTaGFkZXIpIHtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogSW5mb3JtcyB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgRWZmZWN0UGFzc30gdGhhdCB0aGlzIGVmZmVjdCByZXF1aXJlcyBhIHNoYWRlciByZWNvbXBpbGF0aW9uLlxuICAgKlxuICAgKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIGNoYW5naW5nIG1hY3JvcyBvciBleHRlbnNpb25zIGFuZCBhZnRlciBhZGRpbmcvcmVtb3ZpbmcgdW5pZm9ybXMuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldENoYW5nZWQoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIGVmZmVjdCByZXF1aXJlcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBkZXB0aCB0ZXh0dXJlIHRoYXQgaXMgYm91bmQgdG8gdGhlXG4gICAqIGFzc29jaWF0ZWQge0BsaW5rIEVmZmVjdFBhc3N9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxMykge1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0IGJ5IHBlcmZvcm1pbmcgc3VwcG9ydGluZyBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIHtAbGluayBFZmZlY3RQYXNzfSByaWdodCBiZWZvcmUgdGhlIG1haW4gZnVsbHNjcmVlbiByZW5kZXIgb3BlcmF0aW9uLCBldmVuIGlmIHRoZVxuICAgKiBibGVuZCBmdW5jdGlvbiBpcyBzZXQgdG8gYFNLSVBgLlxuICAgKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSBuZWVkIHRvIHVwZGF0ZSBjdXN0b20gdW5pZm9ybXMgb3IgcmVuZGVyIGFkZGl0aW9uYWwgb2ZmLXNjcmVlbiB0ZXh0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdG8gYmUgaW5mb3JtZWQgYWJvdXQgdGhlIHNpemUgb2YgdGhlIGJhY2tidWZmZXIvY2FudmFzLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYmVmb3JlIHtAbGluayBpbml0aWFsaXplfSBhbmQgZXZlcnkgdGltZSB0aGUgc2l6ZSBvZiB0aGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgRWZmZWN0UGFzc30gaXMgYWRkZWQgdG8gYW4ge0BsaW5rIEVmZmVjdENvbXBvc2VyfS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICogQGV4YW1wbGUgaWYoIWFscGhhICYmIGZyYW1lQnVmZmVyVHlwZSA9PT0gVW5zaWduZWRCeXRlVHlwZSkgeyB0aGlzLm15UmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0OyB9XG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgc2hhbGxvdyBzZWFyY2ggZm9yIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgYSBkaXNwb3NlIG1ldGhvZCBhbmQgZGVsZXRlcyB0aGVtLlxuICAgKlxuICAgKiBUaGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIGl0IGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpc1trZXldO1xuICAgICAgY29uc3QgaXNEaXNwb3NhYmxlID0gcHJvcGVydHkgaW5zdGFuY2VvZiBXZWJHTFJlbmRlclRhcmdldDE0IHx8IHByb3BlcnR5IGluc3RhbmNlb2YgTWF0ZXJpYWwyIHx8IHByb3BlcnR5IGluc3RhbmNlb2YgVGV4dHVyZTIgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBQYXNzO1xuICAgICAgaWYgKGlzRGlzcG9zYWJsZSkge1xuICAgICAgICB0aGlzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9ibG9vbS5mcmFnXG52YXIgYmxvb21fZGVmYXVsdCA9IFwiI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBtYXA7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IGludGVuc2l0eTt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjNCB0ZXhlbD10ZXh0dXJlMkQobWFwLHV2KTtvdXRwdXRDb2xvcj12ZWM0KHRleGVsLnJnYippbnRlbnNpdHksdGV4ZWwuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9CbG9vbUVmZmVjdC5qc1xudmFyIEJsb29tRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBibG9vbSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU0NSRUVOXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmx1bWluYW5jZVRocmVzaG9sZD0wLjldIC0gVGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuIFJhaXNlIHRoaXMgdmFsdWUgdG8gbWFzayBvdXQgZGFya2VyIGVsZW1lbnRzIGluIHRoZSBzY2VuZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmx1bWluYW5jZVNtb290aGluZz0wLjAyNV0gLSBDb250cm9scyB0aGUgc21vb3RobmVzcyBvZiB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5taXBtYXBCbHVyPWZhbHNlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgbWlwbWFwIGJsdXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIFRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MC44NV0gLSBUaGUgYmx1ciByYWRpdXMuIE9ubHkgYXBwbGllcyB0byBtaXBtYXAgYmx1ci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxldmVscz04XSAtIFRoZSBhbW91bnQgb2YgTUlQIGxldmVscy4gT25seSBhcHBsaWVzIHRvIG1pcG1hcCBibHVyLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5MQVJHRV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIG1pcG1hcEJsdXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU0NSRUVOLFxuICAgIGx1bWluYW5jZVRocmVzaG9sZCA9IDAuOSxcbiAgICBsdW1pbmFuY2VTbW9vdGhpbmcgPSAwLjAyNSxcbiAgICBtaXBtYXBCbHVyID0gZmFsc2UsXG4gICAgaW50ZW5zaXR5ID0gMSxcbiAgICByYWRpdXMgPSAwLjg1LFxuICAgIGxldmVscyA9IDgsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTEFSR0UsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkJsb29tRWZmZWN0XCIsIGJsb29tX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJtYXBcIiwgbmV3IFVuaWZvcm0yNChudWxsKV0sXG4gICAgICAgIFtcImludGVuc2l0eVwiLCBuZXcgVW5pZm9ybTI0KGludGVuc2l0eSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTUoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJCbG9vbS5UYXJnZXRcIjtcbiAgICB0aGlzLmJsdXJQYXNzID0gbmV3IEthd2FzZUJsdXJQYXNzKHsga2VybmVsU2l6ZSB9KTtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3MgPSBuZXcgTHVtaW5hbmNlUGFzcyh7IGNvbG9yT3V0cHV0OiB0cnVlIH0pO1xuICAgIHRoaXMubHVtaW5hbmNlTWF0ZXJpYWwudGhyZXNob2xkID0gbHVtaW5hbmNlVGhyZXNob2xkO1xuICAgIHRoaXMubHVtaW5hbmNlTWF0ZXJpYWwuc21vb3RoaW5nID0gbHVtaW5hbmNlU21vb3RoaW5nO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3MgPSBuZXcgTWlwbWFwQmx1clBhc3MoKTtcbiAgICB0aGlzLm1pcG1hcEJsdXJQYXNzLmVuYWJsZWQgPSBtaXBtYXBCbHVyO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3MucmFkaXVzID0gcmFkaXVzO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3MubGV2ZWxzID0gbGV2ZWxzO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gbWlwbWFwQmx1ciA/IHRoaXMubWlwbWFwQmx1clBhc3MudGV4dHVyZSA6IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgdGV4dHVyZSB0aGF0IGNvbnRhaW5zIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0IG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLm1pcG1hcEJsdXJQYXNzLmVuYWJsZWQgPyB0aGlzLm1pcG1hcEJsdXJQYXNzLnRleHR1cmUgOiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgYmxvb20gdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEByZXR1cm4ge0thd2FzZUJsdXJQYXNzfSBUaGUgYmx1ciBwYXNzLlxuICAgKi9cbiAgZ2V0Qmx1clBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGx1bWluYW5jZSBwYXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHVtaW5hbmNlUGFzcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtMdW1pbmFuY2VQYXNzfSBUaGUgbHVtaW5hbmNlIHBhc3MuXG4gICAqL1xuICBnZXRMdW1pbmFuY2VQYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVBhc3M7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtMdW1pbmFuY2VNYXRlcmlhbH1cbiAgICovXG4gIGdldCBsdW1pbmFuY2VNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHVtaW5hbmNlTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7THVtaW5hbmNlTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldEx1bWluYW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgRWZmZWN0UGFzcy5kaXRoZXJpbmcgaW5zdGVhZC5cbiAgICovXG4gIGdldCBkaXRoZXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MuZGl0aGVyaW5nO1xuICB9XG4gIHNldCBkaXRoZXJpbmcodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmRpdGhlcmluZyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0tlcm5lbFNpemV9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGlzdGluY3Rpb24oKSB7XG4gICAgY29uc29sZS53YXJuKHRoaXMubmFtZSwgXCJkaXN0aW5jdGlvbiB3YXMgcmVtb3ZlZFwiKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBzZXQgZGlzdGluY3Rpb24odmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4odGhpcy5uYW1lLCBcImRpc3RpbmN0aW9uIHdhcyByZW1vdmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxvb20gaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJpbnRlbnNpdHlcIikudmFsdWU7XG4gIH1cbiAgc2V0IGludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiaW50ZW5zaXR5XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW50ZW5zaXR5LlxuICAgKi9cbiAgZ2V0SW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmludGVuc2l0eTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmxvb20gaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW50ZW5zaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBzZXRJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmludGVuc2l0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIGNvbnN0IGx1bWluYW5jZVBhc3MgPSB0aGlzLmx1bWluYW5jZVBhc3M7XG4gICAgaWYgKGx1bWluYW5jZVBhc3MuZW5hYmxlZCkge1xuICAgICAgbHVtaW5hbmNlUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyKTtcbiAgICAgIGlmICh0aGlzLm1pcG1hcEJsdXJQYXNzLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5taXBtYXBCbHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGx1bWluYW5jZVBhc3MucmVuZGVyVGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCBsdW1pbmFuY2VQYXNzLnJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLm1pcG1hcEJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCByZW5kZXJUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0KTtcbiAgICB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb24uY29weShyZXNvbHV0aW9uKTtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLm1pcG1hcEJsdXJQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5sdW1pbmFuY2VQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAoZ2V0T3V0cHV0Q29sb3JTcGFjZShyZW5kZXJlcikgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0Jva2VoRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0yNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2Jva2VoLmZyYWdcbnZhciBib2tlaF9kZWZhdWx0ID0gXCJ1bmlmb3JtIGZsb2F0IGZvY3VzO3VuaWZvcm0gZmxvYXQgZG9mO3VuaWZvcm0gZmxvYXQgYXBlcnR1cmU7dW5pZm9ybSBmbG9hdCBtYXhCbHVyO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMyIGFzcGVjdENvcnJlY3Rpb249dmVjMigxLjAsYXNwZWN0KTtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxuZmxvYXQgdmlld1o9cGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhcixjYW1lcmFGYXIpO2Zsb2F0IGxpbmVhckRlcHRoPXZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WixjYW1lcmFOZWFyLGNhbWVyYUZhcik7XFxuI2Vsc2VcXG5mbG9hdCBsaW5lYXJEZXB0aD1kZXB0aDtcXG4jZW5kaWZcXG5mbG9hdCBmb2N1c05lYXI9Y2xhbXAoZm9jdXMtZG9mLDAuMCwxLjApO2Zsb2F0IGZvY3VzRmFyPWNsYW1wKGZvY3VzK2RvZiwwLjAsMS4wKTtmbG9hdCBsb3c9c3RlcChsaW5lYXJEZXB0aCxmb2N1c05lYXIpO2Zsb2F0IGhpZ2g9c3RlcChmb2N1c0ZhcixsaW5lYXJEZXB0aCk7ZmxvYXQgZmFjdG9yPShsaW5lYXJEZXB0aC1mb2N1c05lYXIpKmxvdysobGluZWFyRGVwdGgtZm9jdXNGYXIpKmhpZ2g7dmVjMiBkb2ZCbHVyPXZlYzIoY2xhbXAoZmFjdG9yKmFwZXJ0dXJlLC1tYXhCbHVyLG1heEJsdXIpKTt2ZWMyIGRvZmJsdXI5PWRvZkJsdXIqMC45O3ZlYzIgZG9mYmx1cjc9ZG9mQmx1ciowLjc7dmVjMiBkb2ZibHVyND1kb2ZCbHVyKjAuNDt2ZWM0IGNvbG9yPWlucHV0Q29sb3I7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjAsMC40KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjQwLDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjM3LC0wLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLC0wLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4zNywtMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjE1LC0wLjM3KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4zNywtMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjE1LDAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsLTAuMTUpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC40MCwwLjApKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMCwtMC40KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMCwwLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLC0wLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI0KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI0KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjQsMC4wKSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLDAuNCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO291dHB1dENvbG9yPWNvbG9yLzQxLjA7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9Cb2tlaEVmZmVjdC5qc1xudmFyIEJva2VoRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBib2tlaCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzPTAuNV0gLSBUaGUgZm9jdXMgZGlzdGFuY2UgcmF0aW8sIHJhbmdpbmcgZnJvbSAwLjAgdG8gMS4wLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZG9mPTAuMDJdIC0gRGVwdGggb2YgZmllbGQuIEFuIGFyZWEgaW4gZnJvbnQgb2YgYW5kIGJlaGluZCB0aGUgZm9jYWwgcG9pbnQgdGhhdCBzdGlsbCBhcHBlYXJzIHNoYXJwLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXBlcnR1cmU9MC4wMTVdIC0gQ2FtZXJhIGFwZXJ0dXJlIHNjYWxlLiBCaWdnZXIgdmFsdWVzIGZvciBzdHJvbmdlciBibHVyIGFuZCBzaGFsbG93ZXIgZGVwdGggb2YgZmllbGQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhCbHVyPTEuMF0gLSBUaGUgbWF4aW11bSBibHVyIHN0cmVuZ3RoLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgZm9jdXMgPSAwLjUsXG4gICAgZG9mID0gMC4wMixcbiAgICBhcGVydHVyZSA9IDAuMDE1LFxuICAgIG1heEJsdXIgPSAxXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQm9rZWhFZmZlY3RcIiwgYm9rZWhfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5DT05WT0xVVElPTiB8IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImZvY3VzXCIsIG5ldyBVbmlmb3JtMjUoZm9jdXMpXSxcbiAgICAgICAgW1wiZG9mXCIsIG5ldyBVbmlmb3JtMjUoZG9mKV0sXG4gICAgICAgIFtcImFwZXJ0dXJlXCIsIG5ldyBVbmlmb3JtMjUoYXBlcnR1cmUpXSxcbiAgICAgICAgW1wibWF4Qmx1clwiLCBuZXcgVW5pZm9ybTI1KG1heEJsdXIpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0yNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2JyaWdodG5lc3MtY29udHJhc3QuZnJhZ1xudmFyIGJyaWdodG5lc3NfY29udHJhc3RfZGVmYXVsdCA9IFwidW5pZm9ybSBmbG9hdCBicmlnaHRuZXNzO3VuaWZvcm0gZmxvYXQgY29udHJhc3Q7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzMgY29sb3I9aW5wdXRDb2xvci5yZ2IrdmVjMyhicmlnaHRuZXNzLTAuNSk7aWYoY29udHJhc3Q+MC4wKXtjb2xvci89dmVjMygxLjAtY29udHJhc3QpO31lbHNle2NvbG9yKj12ZWMzKDEuMCtjb250cmFzdCk7fW91dHB1dENvbG9yPXZlYzQoY29sb3IrdmVjMygwLjUpLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9CcmlnaHRuZXNzQ29udHJhc3RFZmZlY3QuanNcbnZhciBCcmlnaHRuZXNzQ29udHJhc3RFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJyaWdodG5lc3MvY29udHJhc3QgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5icmlnaHRuZXNzPTAuMF0gLSBUaGUgYnJpZ2h0bmVzcyBmYWN0b3IsIHJhbmdpbmcgZnJvbSAtMSB0byAxLCB3aGVyZSAwIG1lYW5zIG5vIGNoYW5nZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbnRyYXN0PTAuMF0gLSBUaGUgY29udHJhc3QgZmFjdG9yLCByYW5naW5nIGZyb20gLTEgdG8gMSwgd2hlcmUgMCBtZWFucyBubyBjaGFuZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQywgYnJpZ2h0bmVzcyA9IDAsIGNvbnRyYXN0ID0gMCB9ID0ge30pIHtcbiAgICBzdXBlcihcIkJyaWdodG5lc3NDb250cmFzdEVmZmVjdFwiLCBicmlnaHRuZXNzX2NvbnRyYXN0X2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJicmlnaHRuZXNzXCIsIG5ldyBVbmlmb3JtMjYoYnJpZ2h0bmVzcyldLFxuICAgICAgICBbXCJjb250cmFzdFwiLCBuZXcgVW5pZm9ybTI2KGNvbnRyYXN0KV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5pbnB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJyaWdodG5lc3MuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnJpZ2h0bmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJicmlnaHRuZXNzXCIpLnZhbHVlO1xuICB9XG4gIHNldCBicmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJicmlnaHRuZXNzXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJyaWdodG5lc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBicmlnaHRuZXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJyaWdodG5lc3MuXG4gICAqL1xuICBnZXRCcmlnaHRuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmJyaWdodG5lc3M7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJyaWdodG5lc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBicmlnaHRuZXNzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBicmlnaHRuZXNzLlxuICAgKi9cbiAgc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgIHRoaXMuYnJpZ2h0bmVzcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29udHJhc3QuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29udHJhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiY29udHJhc3RcIikudmFsdWU7XG4gIH1cbiAgc2V0IGNvbnRyYXN0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJjb250cmFzdFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250cmFzdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbnRyYXN0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbnRyYXN0LlxuICAgKi9cbiAgZ2V0Q29udHJhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhc3Q7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRyYXN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29udHJhc3QgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGNvbnRyYXN0LlxuICAgKi9cbiAgc2V0Q29udHJhc3QodmFsdWUpIHtcbiAgICB0aGlzLmNvbnRyYXN0ID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY29sb3ItYXZlcmFnZS5mcmFnXG52YXIgY29sb3JfYXZlcmFnZV9kZWZhdWx0ID0gXCJ2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9dmVjNCh2ZWMzKGF2ZXJhZ2UoaW5wdXRDb2xvci5yZ2IpKSxpbnB1dENvbG9yLmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvQ29sb3JBdmVyYWdlRWZmZWN0LmpzXG52YXIgQ29sb3JBdmVyYWdlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBhdmVyYWdlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihibGVuZEZ1bmN0aW9uKSB7XG4gICAgc3VwZXIoXCJDb2xvckF2ZXJhZ2VFZmZlY3RcIiwgY29sb3JfYXZlcmFnZV9kZWZhdWx0LCB7IGJsZW5kRnVuY3Rpb24gfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0NvbG9yRGVwdGhFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTI3IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY29sb3ItZGVwdGguZnJhZ1xudmFyIGNvbG9yX2RlcHRoX2RlZmF1bHQgPSBcInVuaWZvcm0gZmxvYXQgZmFjdG9yO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtvdXRwdXRDb2xvcj12ZWM0KGZsb29yKGlucHV0Q29sb3IucmdiKmZhY3RvciswLjUpL2ZhY3RvcixpbnB1dENvbG9yLmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvQ29sb3JEZXB0aEVmZmVjdC5qc1xudmFyIENvbG9yRGVwdGhFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbG9yIGRlcHRoIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYml0cz0xNl0gLSBUaGUgY29sb3IgYml0IGRlcHRoLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uLCBiaXRzID0gMTYgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJDb2xvckRlcHRoRWZmZWN0XCIsIGNvbG9yX2RlcHRoX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJmYWN0b3JcIiwgbmV3IFVuaWZvcm0yNygxKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5iaXRzID0gMDtcbiAgICB0aGlzLmJpdERlcHRoID0gYml0cztcbiAgfVxuICAvKipcbiAgICogVGhlIHZpcnR1YWwgYW1vdW50IG9mIGNvbG9yIGJpdHMuXG4gICAqXG4gICAqIEVhY2ggY29sb3IgY2hhbm5lbCBlZmZlY3RpdmVseSB1c2VzIGEgZm91cnRoIG9mIHRoZSB0b3RhbCBhbW91bnQgb2YgYml0cy4gQWxwaGEgcmVtYWlucyB1bmFmZmVjdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJpdERlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLmJpdHM7XG4gIH1cbiAgc2V0IGJpdERlcHRoKHZhbHVlKSB7XG4gICAgdGhpcy5iaXRzID0gdmFsdWU7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJmYWN0b3JcIikudmFsdWUgPSBNYXRoLnBvdygyLCB2YWx1ZSAvIDMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbG9yIGJpdCBkZXB0aC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYml0IGRlcHRoLlxuICAgKi9cbiAgZ2V0Qml0RGVwdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYml0RGVwdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZpcnR1YWwgYW1vdW50IG9mIGNvbG9yIGJpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBiaXQgZGVwdGguXG4gICAqL1xuICBzZXRCaXREZXB0aCh2YWx1ZSkge1xuICAgIHRoaXMuYml0RGVwdGggPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvQ2hyb21hdGljQWJlcnJhdGlvbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMjgsIFZlY3RvcjIgYXMgVmVjdG9yMjE4IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY2hyb21hdGljLWFiZXJyYXRpb24uZnJhZ1xudmFyIGNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQgPSBcIiNpZmRlZiBSQURJQUxfTU9EVUxBVElPTlxcbnVuaWZvcm0gZmxvYXQgbW9kdWxhdGlvbk9mZnNldDtcXG4jZW5kaWZcXG52YXJ5aW5nIGZsb2F0IHZBY3RpdmU7dmFyeWluZyB2ZWMyIHZVdlI7dmFyeWluZyB2ZWMyIHZVdkI7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzIgcmE9aW5wdXRDb2xvci5yYTt2ZWMyIGJhPWlucHV0Q29sb3IuYmE7XFxuI2lmZGVmIFJBRElBTF9NT0RVTEFUSU9OXFxuY29uc3QgdmVjMiBjZW50ZXI9dmVjMigwLjUpO2Zsb2F0IGQ9ZGlzdGFuY2UodXYsY2VudGVyKSoyLjA7ZD1tYXgoZC1tb2R1bGF0aW9uT2Zmc2V0LDAuMCk7aWYodkFjdGl2ZT4wLjAmJmQ+MC4wKXtyYT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsbWl4KHV2LHZVdlIsZCkpLnJhO2JhPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixtaXgodXYsdlV2QixkKSkuYmE7fVxcbiNlbHNlXFxuaWYodkFjdGl2ZT4wLjApe3JhPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZSKS5yYTtiYT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2QikuYmE7fVxcbiNlbmRpZlxcbm91dHB1dENvbG9yPXZlYzQocmEueCxpbnB1dENvbG9yLmcsYmEueCxtYXgobWF4KHJhLnksYmEueSksaW5wdXRDb2xvci5hKSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2Nocm9tYXRpYy1hYmVycmF0aW9uLnZlcnRcbnZhciBjaHJvbWF0aWNfYWJlcnJhdGlvbl9kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIG9mZnNldDt2YXJ5aW5nIGZsb2F0IHZBY3RpdmU7dmFyeWluZyB2ZWMyIHZVdlI7dmFyeWluZyB2ZWMyIHZVdkI7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2ZWMyIHNoaWZ0PW9mZnNldCp2ZWMyKDEuMCxhc3BlY3QpO3ZBY3RpdmU9KHNoaWZ0LnghPTAuMHx8c2hpZnQueSE9MC4wKT8xLjA6MC4wO3ZVdlI9dXYrc2hpZnQ7dlV2Qj11di1zaGlmdDt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0Nocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QuanNcbnZhciBDaHJvbWF0aWNBYmVycmF0aW9uRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjaHJvbWF0aWMgYWJlcnJhdGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5vZmZzZXRdIC0gVGhlIGNvbG9yIG9mZnNldC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYWRpYWxNb2R1bGF0aW9uPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGVmZmVjdCBzaG91bGQgYmUgbW9kdWxhdGVkIHdpdGggYSByYWRpYWwgZ3JhZGllbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tb2R1bGF0aW9uT2Zmc2V0PTAuMTVdIC0gVGhlIG1vZHVsYXRpb24gb2Zmc2V0LiBPbmx5IGFwcGxpZXMgaWYgYHJhZGlhbE1vZHVsYXRpb25gIGlzIGVuYWJsZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb2Zmc2V0ID0gbmV3IFZlY3RvcjIxOCgxZS0zLCA1ZS00KSxcbiAgICByYWRpYWxNb2R1bGF0aW9uID0gZmFsc2UsXG4gICAgbW9kdWxhdGlvbk9mZnNldCA9IDAuMTVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJDaHJvbWF0aWNBYmVycmF0aW9uRWZmZWN0XCIsIGNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogY2hyb21hdGljX2FiZXJyYXRpb25fZGVmYXVsdDIsXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJvZmZzZXRcIiwgbmV3IFVuaWZvcm0yOChvZmZzZXQpXSxcbiAgICAgICAgW1wibW9kdWxhdGlvbk9mZnNldFwiLCBuZXcgVW5pZm9ybTI4KG1vZHVsYXRpb25PZmZzZXQpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnJhZGlhbE1vZHVsYXRpb24gPSByYWRpYWxNb2R1bGF0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2Zmc2V0LlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwib2Zmc2V0XCIpLnZhbHVlO1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm9mZnNldFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciByYWRpYWwgbW9kdWxhdGlvbiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBXaGVuIGVuYWJsZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSB3ZWFrZXIgaW4gdGhlIG1pZGRsZSBhbmQgc3Ryb25nZXIgdG93YXJkcyB0aGUgc2NyZWVuIGVkZ2VzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCByYWRpYWxNb2R1bGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiUkFESUFMX01PRFVMQVRJT05cIik7XG4gIH1cbiAgc2V0IHJhZGlhbE1vZHVsYXRpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJSQURJQUxfTU9EVUxBVElPTlwiLCBcIjFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJSQURJQUxfTU9EVUxBVElPTlwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtb2R1bGF0aW9uIG9mZnNldC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtb2R1bGF0aW9uT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm1vZHVsYXRpb25PZmZzZXRcIikudmFsdWU7XG4gIH1cbiAgc2V0IG1vZHVsYXRpb25PZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm1vZHVsYXRpb25PZmZzZXRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29sb3Igb2Zmc2V0IHZlY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3Igb2Zmc2V0IHZlY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZhbHVlIC0gVGhlIG9mZnNldC5cbiAgICovXG4gIHNldE9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMub2Zmc2V0ID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZGVwdGguZnJhZ1xudmFyIGRlcHRoX2RlZmF1bHQgPSBcInZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXtcXG4jaWZkZWYgSU5WRVJURURcXG52ZWMzIGNvbG9yPXZlYzMoMS4wLWRlcHRoKTtcXG4jZWxzZVxcbnZlYzMgY29sb3I9dmVjMyhkZXB0aCk7XFxuI2VuZGlmXFxub3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvRGVwdGhFZmZlY3QuanNcbnZhciBEZXB0aEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW52ZXJ0ZWQ9ZmFsc2VdIC0gV2hldGhlciB0aGUgZGVwdGggc2hvdWxkIGJlIGludmVydGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGludmVydGVkID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEZXB0aEVmZmVjdFwiLCBkZXB0aF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkRFUFRIXG4gICAgfSk7XG4gICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkZXB0aCBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiSU5WRVJURURcIik7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52ZXJ0ZWQgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIklOVkVSVEVEXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJJTlZFUlRFRFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlbmRlcmVkIGRlcHRoIGlzIGludmVydGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyZWQgZGVwdGggaXMgaW52ZXJ0ZWQuXG4gICAqL1xuICBpc0ludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmludmVydGVkO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGRlcHRoIGludmVyc2lvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIGRlcHRoIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICovXG4gIHNldEludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnRlZCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9EZXB0aE9mRmllbGRFZmZlY3QuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTQsIFVuaWZvcm0gYXMgVW5pZm9ybTI5LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxMiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2RlcHRoLW9mLWZpZWxkLmZyYWdcbnZhciBkZXB0aF9vZl9maWVsZF9kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG5lYXJDb2xvckJ1ZmZlcjt1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGZhckNvbG9yQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBuZWFyQ29sb3JCdWZmZXI7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBmYXJDb2xvckJ1ZmZlcjtcXG4jZW5kaWZcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG5lYXJDb0NCdWZmZXI7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBmYXJDb0NCdWZmZXI7dW5pZm9ybSBmbG9hdCBzY2FsZTt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixjb25zdCBpbiBmbG9hdCBkZXB0aCxvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjNCBjb2xvck5lYXI9dGV4dHVyZTJEKG5lYXJDb2xvckJ1ZmZlcix1dik7dmVjNCBjb2xvckZhcj10ZXh0dXJlMkQoZmFyQ29sb3JCdWZmZXIsdXYpO1xcbiNpZiBNQVNLX0ZVTkNUSU9OID09IDFcXG52ZWMyIGNvY05lYXJGYXI9dmVjMih0ZXh0dXJlMkQobmVhckNvQ0J1ZmZlcix1dikucixjb2xvckZhci5hKTtjb2NOZWFyRmFyLng9bWluKGNvY05lYXJGYXIueCpzY2FsZSwxLjApO1xcbiNlbHNlXFxudmVjMiBjb2NOZWFyRmFyPXZlYzIodGV4dHVyZTJEKG5lYXJDb0NCdWZmZXIsdXYpLnIsdGV4dHVyZTJEKGZhckNvQ0J1ZmZlcix1dikuZyk7Y29jTmVhckZhcj1taW4oY29jTmVhckZhcipzY2FsZSwxLjApO1xcbiNlbmRpZlxcbnZlYzQgcmVzdWx0PWlucHV0Q29sb3IqKDEuMC1jb2NOZWFyRmFyLnkpK2NvbG9yRmFyO3Jlc3VsdD1taXgocmVzdWx0LGNvbG9yTmVhcixjb2NOZWFyRmFyLngpO291dHB1dENvbG9yPXJlc3VsdDt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0RlcHRoT2ZGaWVsZEVmZmVjdC5qc1xudmFyIERlcHRoT2ZGaWVsZEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggb2YgZmllbGQgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZEZvY3VzRGlzdGFuY2VdIC0gVGhlIGZvY3VzIGRpc3RhbmNlIGluIHdvcmxkIHVuaXRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGRGb2N1c1JhbmdlXSAtIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzRGlzdGFuY2U9MC4wXSAtIFRoZSBub3JtYWxpemVkIGZvY3VzIGRpc3RhbmNlLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNSYW5nZT0wLjFdIC0gVGhlIGZvY3VzIHJhbmdlLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jYWxMZW5ndGg9MC4xXSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ib2tlaFNjYWxlPTEuMF0gLSBUaGUgc2NhbGUgb2YgdGhlIGJva2VoIGJsdXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIHtcbiAgICBibGVuZEZ1bmN0aW9uLFxuICAgIHdvcmxkRm9jdXNEaXN0YW5jZSxcbiAgICB3b3JsZEZvY3VzUmFuZ2UsXG4gICAgZm9jdXNEaXN0YW5jZSA9IDAsXG4gICAgZm9jYWxMZW5ndGggPSAwLjEsXG4gICAgZm9jdXNSYW5nZSA9IGZvY2FsTGVuZ3RoLFxuICAgIGJva2VoU2NhbGUgPSAxLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRGVwdGhPZkZpZWxkRWZmZWN0XCIsIGRlcHRoX29mX2ZpZWxkX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJuZWFyQ29sb3JCdWZmZXJcIiwgbmV3IFVuaWZvcm0yOShudWxsKV0sXG4gICAgICAgIFtcImZhckNvbG9yQnVmZmVyXCIsIG5ldyBVbmlmb3JtMjkobnVsbCldLFxuICAgICAgICBbXCJuZWFyQ29DQnVmZmVyXCIsIG5ldyBVbmlmb3JtMjkobnVsbCldLFxuICAgICAgICBbXCJmYXJDb0NCdWZmZXJcIiwgbmV3IFVuaWZvcm0yOShudWxsKV0sXG4gICAgICAgIFtcInNjYWxlXCIsIG5ldyBVbmlmb3JtMjkoMSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTYoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJEb0YuSW50ZXJtZWRpYXRlXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQgPSB0aGlzLnJlbmRlclRhcmdldC5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUubmFtZSA9IFwiRG9GLk1hc2tlZC5GYXJcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldE5lYXIgPSB0aGlzLnJlbmRlclRhcmdldC5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TmVhci50ZXh0dXJlLm5hbWUgPSBcIkRvRi5Cb2tlaC5OZWFyXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJuZWFyQ29sb3JCdWZmZXJcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldE5lYXIudGV4dHVyZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEZhciA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRGYXIudGV4dHVyZS5uYW1lID0gXCJEb0YuQm9rZWguRmFyXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJmYXJDb2xvckJ1ZmZlclwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0RmFyLnRleHR1cmU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0MgPSB0aGlzLnJlbmRlclRhcmdldC5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmUubmFtZSA9IFwiRG9GLkNvQ1wiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZmFyQ29DQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldENvQ0JsdXJyZWQgPSB0aGlzLnJlbmRlclRhcmdldENvQy5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZC50ZXh0dXJlLm5hbWUgPSBcIkRvRi5Db0MuQmx1cnJlZFwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibmVhckNvQ0J1ZmZlclwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZC50ZXh0dXJlO1xuICAgIHRoaXMuY29jUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsKGNhbWVyYSkpO1xuICAgIGNvbnN0IGNvY01hdGVyaWFsID0gdGhpcy5jb2NNYXRlcmlhbDtcbiAgICBjb2NNYXRlcmlhbC5mb2N1c0Rpc3RhbmNlID0gZm9jdXNEaXN0YW5jZTtcbiAgICBjb2NNYXRlcmlhbC5mb2N1c1JhbmdlID0gZm9jdXNSYW5nZTtcbiAgICBpZiAod29ybGRGb2N1c0Rpc3RhbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIGNvY01hdGVyaWFsLndvcmxkRm9jdXNEaXN0YW5jZSA9IHdvcmxkRm9jdXNEaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHdvcmxkRm9jdXNSYW5nZSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb2NNYXRlcmlhbC53b3JsZEZvY3VzUmFuZ2UgPSB3b3JsZEZvY3VzUmFuZ2U7XG4gICAgfVxuICAgIHRoaXMuYmx1clBhc3MgPSBuZXcgS2F3YXNlQmx1clBhc3MoeyByZXNvbHV0aW9uU2NhbGUsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwga2VybmVsU2l6ZTogS2VybmVsU2l6ZS5NRURJVU0gfSk7XG4gICAgdGhpcy5tYXNrUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBNYXNrTWF0ZXJpYWwodGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZSkpO1xuICAgIGNvbnN0IG1hc2tNYXRlcmlhbCA9IHRoaXMubWFza1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIG1hc2tNYXRlcmlhbC5jb2xvckNoYW5uZWwgPSBDb2xvckNoYW5uZWwuR1JFRU47XG4gICAgdGhpcy5tYXNrRnVuY3Rpb24gPSBNYXNrRnVuY3Rpb24uTVVMVElQTFlfUkdCO1xuICAgIHRoaXMuYm9rZWhOZWFyQmFzZVBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgQm9rZWhNYXRlcmlhbChmYWxzZSwgdHJ1ZSkpO1xuICAgIHRoaXMuYm9rZWhOZWFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmNvY0J1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZC50ZXh0dXJlO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgQm9rZWhNYXRlcmlhbCh0cnVlLCB0cnVlKSk7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuY29jQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmU7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IEJva2VoTWF0ZXJpYWwoZmFsc2UsIGZhbHNlKSk7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5jb2NCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBCb2tlaE1hdGVyaWFsKHRydWUsIGZhbHNlKSk7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5jb2NCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlO1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLmJva2VoU2NhbGUgPSBib2tlaFNjYWxlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLmNvY01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGNvY1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXNrIGZ1bmN0aW9uLiBEZWZhdWx0IGlzIGBNVUxUSVBMWV9SR0JgLlxuICAgKlxuICAgKiBAdHlwZSB7TWFza0Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IG1hc2tGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwubWFza0Z1bmN0aW9uO1xuICB9XG4gIHNldCBtYXNrRnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5tYXNrRnVuY3Rpb24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiTUFTS19GVU5DVElPTlwiLCB2YWx1ZS50b0ZpeGVkKDApKTtcbiAgICAgIHRoaXMubWFza1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLm1hc2tGdW5jdGlvbiA9IHZhbHVlO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgY2lyY2xlIG9mIGNvbmZ1c2lvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0NpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgY29jTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29jUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29jTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHR5cGUge0NpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgY2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2NNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2lyY2xlIG9mIGNvbmZ1c2lvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvY01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0NpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29jTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhc3MgdGhhdCBibHVycyB0aGUgZm9yZWdyb3VuZCBDb0MgYnVmZmVyIHRvIHNvZnRlbiBlZGdlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0thd2FzZUJsdXJQYXNzfSBUaGUgYmx1ciBwYXNzLlxuICAgKi9cbiAgZ2V0Qmx1clBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBib2tlaCBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBib2tlaFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBib2tlaFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICAgIHRoaXMuYm9rZWhGYXJCYXNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgICB0aGlzLmJva2VoRmFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNjYWxlID0gdmFsdWU7XG4gICAgdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYm9rZWggc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBib2tlaFNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0Qm9rZWhTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib2tlaFNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBib2tlaCBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJva2VoU2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNjYWxlLlxuICAgKi9cbiAgc2V0Qm9rZWhTY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMuYm9rZWhTY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dG8gZm9jdXMgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGFyZ2V0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSB0YXJnZXQuXG4gICAqL1xuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhdXRvIGZvY3VzIHRhcmdldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRhcmdldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZhbHVlIC0gVGhlIHRhcmdldC5cbiAgICovXG4gIHNldFRhcmdldCh2YWx1ZSkge1xuICAgIHRoaXMudGFyZ2V0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGZvY3VzIGRpc3RhbmNlIGZyb20gdGhlIGNhbWVyYSB0byB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdGFyZ2V0IC0gVGhlIHRhcmdldC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbm9ybWFsaXplZCBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIGNhbGN1bGF0ZUZvY3VzRGlzdGFuY2UodGFyZ2V0KSB7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmEucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXQpO1xuICAgIHJldHVybiB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLWRpc3RhbmNlLCBjYW1lcmEubmVhciwgY2FtZXJhLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzE0KSB7XG4gICAgdGhpcy5jb2NNYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmNvY01hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0Q29DID0gdGhpcy5yZW5kZXJUYXJnZXRDb0M7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0Q29DQmx1cnJlZCA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZDtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRNYXNrZWQgPSB0aGlzLnJlbmRlclRhcmdldE1hc2tlZDtcbiAgICBpZiAodGhpcy50YXJnZXQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVGb2N1c0Rpc3RhbmNlKHRoaXMudGFyZ2V0KTtcbiAgICAgIHRoaXMuY29jTWF0ZXJpYWwuZm9jdXNEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH1cbiAgICB0aGlzLmNvY1Bhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsLCByZW5kZXJUYXJnZXRDb0MpO1xuICAgIHRoaXMuYmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRDb0MsIHJlbmRlclRhcmdldENvQ0JsdXJyZWQpO1xuICAgIHRoaXMubWFza1Bhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgcmVuZGVyVGFyZ2V0TWFza2VkKTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRNYXNrZWQsIHJlbmRlclRhcmdldCk7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCB0aGlzLnJlbmRlclRhcmdldEZhcik7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCByZW5kZXJUYXJnZXQpO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQsIHRoaXMucmVuZGVyVGFyZ2V0TmVhcik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLmNvY1Bhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmJsdXJQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5tYXNrUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0RmFyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXROZWFyLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuYm9rZWhGYXJCYXNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmJva2VoRmFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuY29jUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLm1hc2tQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuYm9rZWhOZWFyQmFzZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIFVuc2lnbmVkQnl0ZVR5cGUxMik7XG4gICAgaWYgKHJlbmRlcmVyLmNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSB7XG4gICAgICB0aGlzLmNvY1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuTE9HX0RFUFRIID0gXCIxXCI7XG4gICAgfVxuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXROZWFyLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0RmFyLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldE5lYXIudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEZhci50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0RvdFNjcmVlbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzAsIFZlY3RvcjIgYXMgVmVjdG9yMjE5IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZG90LXNjcmVlbi5mcmFnXG52YXIgZG90X3NjcmVlbl9kZWZhdWx0ID0gXCJ1bmlmb3JtIHZlYzIgYW5nbGU7dW5pZm9ybSBmbG9hdCBzY2FsZTtmbG9hdCBwYXR0ZXJuKGNvbnN0IGluIHZlYzIgdXYpe3ZlYzIgcG9pbnQ9c2NhbGUqdmVjMihkb3QoYW5nbGUueXgsdmVjMih1di54LC11di55KSksZG90KGFuZ2xlLHV2KSk7cmV0dXJuKHNpbihwb2ludC54KSpzaW4ocG9pbnQueSkpKjQuMDt9dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzMgY29sb3I9dmVjMyhpbnB1dENvbG9yLnJnYioxMC4wLTUuMCtwYXR0ZXJuKHV2KnJlc29sdXRpb24pKTtvdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9Eb3RTY3JlZW5FZmZlY3QuanNcbnZhciBEb3RTY3JlZW5FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRvdCBzY3JlZW4gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZT0xLjU3XSAtIFRoZSBhbmdsZSBvZiB0aGUgZG90IHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZT0xLjBdIC0gVGhlIHNjYWxlIG9mIHRoZSBkb3QgcGF0dGVybi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgYW5nbGUgPSBNYXRoLlBJICogMC41LCBzY2FsZSA9IDEgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEb3RTY3JlZW5FZmZlY3RcIiwgZG90X3NjcmVlbl9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYW5nbGVcIiwgbmV3IFVuaWZvcm0zMChuZXcgVmVjdG9yMjE5KCkpXSxcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm0zMChzY2FsZSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFuZ2xlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGFuZ2xlKCkge1xuICAgIHJldHVybiBNYXRoLmFjb3ModGhpcy51bmlmb3Jtcy5nZXQoXCJhbmdsZVwiKS52YWx1ZS55KTtcbiAgfVxuICBzZXQgYW5nbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImFuZ2xlXCIpLnZhbHVlLnNldChNYXRoLnNpbih2YWx1ZSksIE1hdGguY29zKHZhbHVlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhdHRlcm4gYW5nbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhbmdsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgZ2V0QW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5nbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhdHRlcm4gYW5nbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhbmdsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG4gIHNldEFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy5hbmdsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwic2NhbGVcIikudmFsdWU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2Z4YWEuZnJhZ1xudmFyIGZ4YWFfZGVmYXVsdCA9IFwiI2lmIFRIUkVFX1JFVklTSU9OIDwgMTQzXFxuI2RlZmluZSBsdW1pbmFuY2UodikgbGluZWFyVG9SZWxhdGl2ZUx1bWluYW5jZSh2KVxcbiNlbmRpZlxcbiNkZWZpbmUgUVVBTElUWShxKSAoKHEpIDwgNSA/IDEuMCA6ICgocSkgPiA1ID8gKChxKSA8IDEwID8gMi4wIDogKChxKSA8IDExID8gNC4wIDogOC4wKSkgOiAxLjUpKVxcbiNkZWZpbmUgT05FX09WRVJfVFdFTFZFIDAuMDgzMzMzMzMzMzMzMzMzMzNcXG52YXJ5aW5nIHZlYzIgdlV2RG93bjt2YXJ5aW5nIHZlYzIgdlV2VXA7dmFyeWluZyB2ZWMyIHZVdkxlZnQ7dmFyeWluZyB2ZWMyIHZVdlJpZ2h0O3ZhcnlpbmcgdmVjMiB2VXZEb3duTGVmdDt2YXJ5aW5nIHZlYzIgdlV2VXBSaWdodDt2YXJ5aW5nIHZlYzIgdlV2VXBMZWZ0O3ZhcnlpbmcgdmVjMiB2VXZEb3duUmlnaHQ7dmVjNCBmeGFhKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2KXtmbG9hdCBsdW1hQ2VudGVyPWx1bWluYW5jZShpbnB1dENvbG9yLnJnYik7ZmxvYXQgbHVtYURvd249bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZEb3duKS5yZ2IpO2Zsb2F0IGx1bWFVcD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdlVwKS5yZ2IpO2Zsb2F0IGx1bWFMZWZ0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2TGVmdCkucmdiKTtmbG9hdCBsdW1hUmlnaHQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZSaWdodCkucmdiKTtmbG9hdCBsdW1hTWluPW1pbihsdW1hQ2VudGVyLG1pbihtaW4obHVtYURvd24sbHVtYVVwKSxtaW4obHVtYUxlZnQsbHVtYVJpZ2h0KSkpO2Zsb2F0IGx1bWFNYXg9bWF4KGx1bWFDZW50ZXIsbWF4KG1heChsdW1hRG93bixsdW1hVXApLG1heChsdW1hTGVmdCxsdW1hUmlnaHQpKSk7ZmxvYXQgbHVtYVJhbmdlPWx1bWFNYXgtbHVtYU1pbjtpZihsdW1hUmFuZ2U8bWF4KEVER0VfVEhSRVNIT0xEX01JTixsdW1hTWF4KkVER0VfVEhSRVNIT0xEX01BWCkpe3JldHVybiBpbnB1dENvbG9yO31mbG9hdCBsdW1hRG93bkxlZnQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZEb3duTGVmdCkucmdiKTtmbG9hdCBsdW1hVXBSaWdodD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdlVwUmlnaHQpLnJnYik7ZmxvYXQgbHVtYVVwTGVmdD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdlVwTGVmdCkucmdiKTtmbG9hdCBsdW1hRG93blJpZ2h0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2RG93blJpZ2h0KS5yZ2IpO2Zsb2F0IGx1bWFEb3duVXA9bHVtYURvd24rbHVtYVVwO2Zsb2F0IGx1bWFMZWZ0UmlnaHQ9bHVtYUxlZnQrbHVtYVJpZ2h0O2Zsb2F0IGx1bWFMZWZ0Q29ybmVycz1sdW1hRG93bkxlZnQrbHVtYVVwTGVmdDtmbG9hdCBsdW1hRG93bkNvcm5lcnM9bHVtYURvd25MZWZ0K2x1bWFEb3duUmlnaHQ7ZmxvYXQgbHVtYVJpZ2h0Q29ybmVycz1sdW1hRG93blJpZ2h0K2x1bWFVcFJpZ2h0O2Zsb2F0IGx1bWFVcENvcm5lcnM9bHVtYVVwUmlnaHQrbHVtYVVwTGVmdDtmbG9hdCBlZGdlSG9yaXpvbnRhbD0oYWJzKC0yLjAqbHVtYUxlZnQrbHVtYUxlZnRDb3JuZXJzKSthYnMoLTIuMCpsdW1hQ2VudGVyK2x1bWFEb3duVXApKjIuMCthYnMoLTIuMCpsdW1hUmlnaHQrbHVtYVJpZ2h0Q29ybmVycykpO2Zsb2F0IGVkZ2VWZXJ0aWNhbD0oYWJzKC0yLjAqbHVtYVVwK2x1bWFVcENvcm5lcnMpK2FicygtMi4wKmx1bWFDZW50ZXIrbHVtYUxlZnRSaWdodCkqMi4wK2FicygtMi4wKmx1bWFEb3duK2x1bWFEb3duQ29ybmVycykpO2Jvb2wgaXNIb3Jpem9udGFsPShlZGdlSG9yaXpvbnRhbD49ZWRnZVZlcnRpY2FsKTtmbG9hdCBzdGVwTGVuZ3RoPWlzSG9yaXpvbnRhbD90ZXhlbFNpemUueTp0ZXhlbFNpemUueDtmbG9hdCBsdW1hMT1pc0hvcml6b250YWw/bHVtYURvd246bHVtYUxlZnQ7ZmxvYXQgbHVtYTI9aXNIb3Jpem9udGFsP2x1bWFVcDpsdW1hUmlnaHQ7ZmxvYXQgZ3JhZGllbnQxPWFicyhsdW1hMS1sdW1hQ2VudGVyKTtmbG9hdCBncmFkaWVudDI9YWJzKGx1bWEyLWx1bWFDZW50ZXIpO2Jvb2wgaXMxU3RlZXBlc3Q9Z3JhZGllbnQxPj1ncmFkaWVudDI7ZmxvYXQgZ3JhZGllbnRTY2FsZWQ9MC4yNSptYXgoZ3JhZGllbnQxLGdyYWRpZW50Mik7ZmxvYXQgbHVtYUxvY2FsQXZlcmFnZT0wLjA7aWYoaXMxU3RlZXBlc3Qpe3N0ZXBMZW5ndGg9LXN0ZXBMZW5ndGg7bHVtYUxvY2FsQXZlcmFnZT0wLjUqKGx1bWExK2x1bWFDZW50ZXIpO31lbHNle2x1bWFMb2NhbEF2ZXJhZ2U9MC41KihsdW1hMitsdW1hQ2VudGVyKTt9dmVjMiBjdXJyZW50VXY9dXY7aWYoaXNIb3Jpem9udGFsKXtjdXJyZW50VXYueSs9c3RlcExlbmd0aCowLjU7fWVsc2V7Y3VycmVudFV2LngrPXN0ZXBMZW5ndGgqMC41O312ZWMyIG9mZnNldD1pc0hvcml6b250YWw/dmVjMih0ZXhlbFNpemUueCwwLjApOnZlYzIoMC4wLHRleGVsU2l6ZS55KTt2ZWMyIHV2MT1jdXJyZW50VXYtb2Zmc2V0KlFVQUxJVFkoMCk7dmVjMiB1djI9Y3VycmVudFV2K29mZnNldCpRVUFMSVRZKDApO2Zsb2F0IGx1bWFFbmQxPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYxKS5yZ2IpO2Zsb2F0IGx1bWFFbmQyPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYyKS5yZ2IpO2x1bWFFbmQxLT1sdW1hTG9jYWxBdmVyYWdlO2x1bWFFbmQyLT1sdW1hTG9jYWxBdmVyYWdlO2Jvb2wgcmVhY2hlZDE9YWJzKGx1bWFFbmQxKT49Z3JhZGllbnRTY2FsZWQ7Ym9vbCByZWFjaGVkMj1hYnMobHVtYUVuZDIpPj1ncmFkaWVudFNjYWxlZDtib29sIHJlYWNoZWRCb3RoPXJlYWNoZWQxJiZyZWFjaGVkMjtpZighcmVhY2hlZDEpe3V2MS09b2Zmc2V0KlFVQUxJVFkoMSk7fWlmKCFyZWFjaGVkMil7dXYyKz1vZmZzZXQqUVVBTElUWSgxKTt9aWYoIXJlYWNoZWRCb3RoKXtmb3IoaW50IGk9MjtpPFNBTVBMRVM7KytpKXtpZighcmVhY2hlZDEpe2x1bWFFbmQxPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYxKS5yZ2IpO2x1bWFFbmQxPWx1bWFFbmQxLWx1bWFMb2NhbEF2ZXJhZ2U7fWlmKCFyZWFjaGVkMil7bHVtYUVuZDI9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix1djIpLnJnYik7bHVtYUVuZDI9bHVtYUVuZDItbHVtYUxvY2FsQXZlcmFnZTt9cmVhY2hlZDE9YWJzKGx1bWFFbmQxKT49Z3JhZGllbnRTY2FsZWQ7cmVhY2hlZDI9YWJzKGx1bWFFbmQyKT49Z3JhZGllbnRTY2FsZWQ7cmVhY2hlZEJvdGg9cmVhY2hlZDEmJnJlYWNoZWQyO2lmKCFyZWFjaGVkMSl7dXYxLT1vZmZzZXQqUVVBTElUWShpKTt9aWYoIXJlYWNoZWQyKXt1djIrPW9mZnNldCpRVUFMSVRZKGkpO31pZihyZWFjaGVkQm90aCl7YnJlYWs7fX19ZmxvYXQgZGlzdGFuY2UxPWlzSG9yaXpvbnRhbD8odXYueC11djEueCk6KHV2LnktdXYxLnkpO2Zsb2F0IGRpc3RhbmNlMj1pc0hvcml6b250YWw/KHV2Mi54LXV2LngpOih1djIueS11di55KTtib29sIGlzRGlyZWN0aW9uMT1kaXN0YW5jZTE8ZGlzdGFuY2UyO2Zsb2F0IGRpc3RhbmNlRmluYWw9bWluKGRpc3RhbmNlMSxkaXN0YW5jZTIpO2Zsb2F0IGVkZ2VUaGlja25lc3M9KGRpc3RhbmNlMStkaXN0YW5jZTIpO2Jvb2wgaXNMdW1hQ2VudGVyU21hbGxlcj1sdW1hQ2VudGVyPGx1bWFMb2NhbEF2ZXJhZ2U7Ym9vbCBjb3JyZWN0VmFyaWF0aW9uMT0obHVtYUVuZDE8MC4wKSE9aXNMdW1hQ2VudGVyU21hbGxlcjtib29sIGNvcnJlY3RWYXJpYXRpb24yPShsdW1hRW5kMjwwLjApIT1pc0x1bWFDZW50ZXJTbWFsbGVyO2Jvb2wgY29ycmVjdFZhcmlhdGlvbj1pc0RpcmVjdGlvbjE/Y29ycmVjdFZhcmlhdGlvbjE6Y29ycmVjdFZhcmlhdGlvbjI7ZmxvYXQgcGl4ZWxPZmZzZXQ9LWRpc3RhbmNlRmluYWwvZWRnZVRoaWNrbmVzcyswLjU7ZmxvYXQgZmluYWxPZmZzZXQ9Y29ycmVjdFZhcmlhdGlvbj9waXhlbE9mZnNldDowLjA7ZmxvYXQgbHVtYUF2ZXJhZ2U9T05FX09WRVJfVFdFTFZFKigyLjAqKGx1bWFEb3duVXArbHVtYUxlZnRSaWdodCkrbHVtYUxlZnRDb3JuZXJzK2x1bWFSaWdodENvcm5lcnMpO2Zsb2F0IHN1YlBpeGVsT2Zmc2V0MT1jbGFtcChhYnMobHVtYUF2ZXJhZ2UtbHVtYUNlbnRlcikvbHVtYVJhbmdlLDAuMCwxLjApO2Zsb2F0IHN1YlBpeGVsT2Zmc2V0Mj0oLTIuMCpzdWJQaXhlbE9mZnNldDErMy4wKSpzdWJQaXhlbE9mZnNldDEqc3ViUGl4ZWxPZmZzZXQxO2Zsb2F0IHN1YlBpeGVsT2Zmc2V0RmluYWw9c3ViUGl4ZWxPZmZzZXQyKnN1YlBpeGVsT2Zmc2V0MipTVUJQSVhFTF9RVUFMSVRZO2ZpbmFsT2Zmc2V0PW1heChmaW5hbE9mZnNldCxzdWJQaXhlbE9mZnNldEZpbmFsKTt2ZWMyIGZpbmFsVXY9dXY7aWYoaXNIb3Jpem9udGFsKXtmaW5hbFV2LnkrPWZpbmFsT2Zmc2V0KnN0ZXBMZW5ndGg7fWVsc2V7ZmluYWxVdi54Kz1maW5hbE9mZnNldCpzdGVwTGVuZ3RoO31yZXR1cm4gdGV4dHVyZTJEKGlucHV0QnVmZmVyLGZpbmFsVXYpO312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9ZnhhYShpbnB1dENvbG9yLHV2KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZnhhYS52ZXJ0XG52YXIgZnhhYV9kZWZhdWx0MiA9IFwidmFyeWluZyB2ZWMyIHZVdkRvd247dmFyeWluZyB2ZWMyIHZVdlVwO3ZhcnlpbmcgdmVjMiB2VXZMZWZ0O3ZhcnlpbmcgdmVjMiB2VXZSaWdodDt2YXJ5aW5nIHZlYzIgdlV2RG93bkxlZnQ7dmFyeWluZyB2ZWMyIHZVdlVwUmlnaHQ7dmFyeWluZyB2ZWMyIHZVdlVwTGVmdDt2YXJ5aW5nIHZlYzIgdlV2RG93blJpZ2h0O3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7dlV2RG93bj11dit2ZWMyKDAuMCwtMS4wKSp0ZXhlbFNpemU7dlV2VXA9dXYrdmVjMigwLjAsMS4wKSp0ZXhlbFNpemU7dlV2UmlnaHQ9dXYrdmVjMigxLjAsMC4wKSp0ZXhlbFNpemU7dlV2TGVmdD11dit2ZWMyKC0xLjAsMC4wKSp0ZXhlbFNpemU7dlV2RG93bkxlZnQ9dXYrdmVjMigtMS4wLC0xLjApKnRleGVsU2l6ZTt2VXZVcFJpZ2h0PXV2K3ZlYzIoMS4wLDEuMCkqdGV4ZWxTaXplO3ZVdlVwTGVmdD11dit2ZWMyKC0xLjAsMS4wKSp0ZXhlbFNpemU7dlV2RG93blJpZ2h0PXV2K3ZlYzIoMS4wLC0xLjApKnRleGVsU2l6ZTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0ZYQUFFZmZlY3QuanNcbnZhciBGWEFBRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBGWEFBIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJGWEFBRWZmZWN0XCIsIGZ4YWFfZGVmYXVsdCwge1xuICAgICAgdmVydGV4U2hhZGVyOiBmeGFhX2RlZmF1bHQyLFxuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGRlZmluZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiRURHRV9USFJFU0hPTERfTUlOXCIsIFwiMC4wMzEyXCJdLFxuICAgICAgICBbXCJFREdFX1RIUkVTSE9MRF9NQVhcIiwgXCIwLjEyNVwiXSxcbiAgICAgICAgW1wiU1VCUElYRUxfUVVBTElUWVwiLCBcIjAuNzVcIl0sXG4gICAgICAgIFtcIlNBTVBMRVNcIiwgXCIxMlwiXVxuICAgICAgXSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbkVkZ2VUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiRURHRV9USFJFU0hPTERfTUlOXCIpKTtcbiAgfVxuICBzZXQgbWluRWRnZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJFREdFX1RIUkVTSE9MRF9NSU5cIiwgdmFsdWUudG9GaXhlZCgxMikpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBlZGdlIGRldGVjdGlvbiB0aHJlc2hvbGQuIFJhbmdlIGlzIFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4RWRnZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJFREdFX1RIUkVTSE9MRF9NQVhcIikpO1xuICB9XG4gIHNldCBtYXhFZGdlVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIkVER0VfVEhSRVNIT0xEX01BWFwiLCB2YWx1ZS50b0ZpeGVkKDEyKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdWJwaXhlbCBibGVuZCBxdWFsaXR5LiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN1YnBpeGVsUXVhbGl0eSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJTVUJQSVhFTF9RVUFMSVRZXCIpKTtcbiAgfVxuICBzZXQgc3VicGl4ZWxRdWFsaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlNVQlBJWEVMX1FVQUxJVFlcIiwgdmFsdWUudG9GaXhlZCgxMikpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgZWRnZSBkZXRlY3Rpb24gc2FtcGxlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzYW1wbGVzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLmdldChcIlNBTVBMRVNcIikpO1xuICB9XG4gIHNldCBzYW1wbGVzKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlNBTVBMRVNcIiwgdmFsdWUudG9GaXhlZCgwKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dhbW1hQ29ycmVjdGlvbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzEgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9nYW1tYS1jb3JyZWN0aW9uLmZyYWdcbnZhciBnYW1tYV9jb3JyZWN0aW9uX2RlZmF1bHQgPSBcInVuaWZvcm0gZmxvYXQgZ2FtbWE7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPUxpbmVhclRvR2FtbWEobWF4KGlucHV0Q29sb3IsMC4wKSxnYW1tYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9HYW1tYUNvcnJlY3Rpb25FZmZlY3QuanNcbnZhciBHYW1tYUNvcnJlY3Rpb25FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGdhbW1hIGNvcnJlY3Rpb24gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYW1tYT0yLjBdIC0gVGhlIGdhbW1hIGZhY3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDLCBnYW1tYSA9IDIgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJHYW1tYUNvcnJlY3Rpb25FZmZlY3RcIiwgZ2FtbWFfY29ycmVjdGlvbl9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZ2FtbWFcIiwgbmV3IFVuaWZvcm0zMShnYW1tYSldXG4gICAgICBdKVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9HbGl0Y2hFZmZlY3QuanNcbmltcG9ydCB7IE5lYXJlc3RGaWx0ZXIgYXMgTmVhcmVzdEZpbHRlcjYsIFJlcGVhdFdyYXBwaW5nLCBSR0JBRm9ybWF0IGFzIFJHQkFGb3JtYXQzLCBVbmlmb3JtIGFzIFVuaWZvcm0zMiwgVmVjdG9yMiBhcyBWZWN0b3IyMjAgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3RleHR1cmVzL2x1dC9Mb29rdXBUZXh0dXJlLmpzXG5pbXBvcnQge1xuICBDb2xvciBhcyBDb2xvcjQsXG4gIENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIERhdGFUZXh0dXJlLFxuICBEYXRhM0RUZXh0dXJlLFxuICBGbG9hdFR5cGUgYXMgRmxvYXRUeXBlNCxcbiAgTGluZWFyRmlsdGVyIGFzIExpbmVhckZpbHRlcjMsXG4gIFJHQkFGb3JtYXQsXG4gIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTEzLFxuICBWZWN0b3IzXG59IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvdGV4dHVyZXMvUmF3SW1hZ2VEYXRhLmpzXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCwgZGF0YSkge1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICBjb250ZXh0LmRyYXdJbWFnZShkYXRhLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpbWFnZURhdGEuZGF0YS5zZXQoZGF0YSk7XG4gICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfVxuICByZXR1cm4gY2FudmFzO1xufVxudmFyIFJhd0ltYWdlRGF0YSA9IGNsYXNzIF9SYXdJbWFnZURhdGEge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbWFnZSBkYXRhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSAtIFRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIC0gVGhlIGhlaWdodCBvZiB0aGUgaW1hZ2UuXG4gICAqIEBwYXJhbSB7VWludDhDbGFtcGVkQXJyYXl9IFtkYXRhPW51bGxdIC0gVGhlIGltYWdlIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDAsIGRhdGEgPSBudWxsKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYW52YXMgZnJvbSB0aGlzIGltYWdlIGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm4ge0NhbnZhc30gVGhlIGNhbnZhcywgb3IgbnVsbCBpZiBpdCBjb3VsZG4ndCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdG9DYW52YXMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBjcmVhdGVDYW52YXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW1hZ2UgZGF0YSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7SW1hZ2VEYXRhfEltYWdlfSBpbWFnZSAtIEFuIGltYWdlIG9yIHBsYWluIGltYWdlIGRhdGEuXG4gICAqIEByZXR1cm4ge1Jhd0ltYWdlRGF0YX0gVGhlIGltYWdlIGRhdGEuXG4gICAqL1xuICBzdGF0aWMgZnJvbShpbWFnZSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2U7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKGltYWdlIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0LCBpbWFnZSk7XG4gICAgICBpZiAoY2FudmFzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGltYWdlLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1Jhd0ltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0LCBkYXRhKTtcbiAgfVxufTtcblxuLy8gdG1wL2x1dC93b3JrZXIudHh0XG52YXIgd29ya2VyX2RlZmF1bHQgPSAnXCJ1c2Ugc3RyaWN0XCI7KCgpPT57dmFyIE89e1NDQUxFX1VQOlwibHV0LnNjYWxldXBcIn07dmFyIF89W25ldyBGbG9hdDMyQXJyYXkoMyksbmV3IEZsb2F0MzJBcnJheSgzKV0sbj1bbmV3IEZsb2F0MzJBcnJheSgzKSxuZXcgRmxvYXQzMkFycmF5KDMpLG5ldyBGbG9hdDMyQXJyYXkoMyksbmV3IEZsb2F0MzJBcnJheSgzKV0sWj1bW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldLFtuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDFdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXSxbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwxXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV0sW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldLFtuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwwXSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDFdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXSxbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwxXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV1dO2Z1bmN0aW9uIGQoYSx0LHIsbSl7bGV0IGk9clswXS10WzBdLGU9clsxXS10WzFdLHk9clsyXS10WzJdLGg9YVswXS10WzBdLEE9YVsxXS10WzFdLHc9YVsyXS10WzJdLGM9ZSp3LXkqQSxsPXkqaC1pKncseD1pKkEtZSpoLHU9TWF0aC5zcXJ0KGMqYytsKmwreCp4KSxiPXUqLjUscz1jL3UsRj1sL3UsZj14L3UscD0tKGFbMF0qcythWzFdKkYrYVsyXSpmKSxNPW1bMF0qcyttWzFdKkYrbVsyXSpmO3JldHVybiBNYXRoLmFicyhNK3ApKmIvM31mdW5jdGlvbiBWKGEsdCxyLG0saSxlKXtsZXQgeT0ocittKnQraSp0KnQpKjQ7ZVswXT1hW3krMF0sZVsxXT1hW3krMV0sZVsyXT1hW3krMl19ZnVuY3Rpb24gayhhLHQscixtLGksZSl7bGV0IHk9cioodC0xKSxoPW0qKHQtMSksQT1pKih0LTEpLHc9TWF0aC5mbG9vcih5KSxjPU1hdGguZmxvb3IoaCksbD1NYXRoLmZsb29yKEEpLHg9TWF0aC5jZWlsKHkpLHU9TWF0aC5jZWlsKGgpLGI9TWF0aC5jZWlsKEEpLHM9eS13LEY9aC1jLGY9QS1sO2lmKHc9PT15JiZjPT09aCYmbD09PUEpVihhLHQseSxoLEEsZSk7ZWxzZXtsZXQgcDtzPj1GJiZGPj1mP3A9WlswXTpzPj1mJiZmPj1GP3A9WlsxXTpmPj1zJiZzPj1GP3A9WlsyXTpGPj1zJiZzPj1mP3A9WlszXTpGPj1mJiZmPj1zP3A9Wls0XTpmPj1GJiZGPj1zJiYocD1aWzVdKTtsZXRbTSxnLFgsWV09cCxQPV9bMF07UFswXT1zLFBbMV09RixQWzJdPWY7bGV0IG89X1sxXSxMPXgtdyxTPXUtYyxVPWItbDtvWzBdPUwqTVswXSt3LG9bMV09UypNWzFdK2Msb1syXT1VKk1bMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzBdKSxvWzBdPUwqZ1swXSt3LG9bMV09UypnWzFdK2Msb1syXT1VKmdbMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzFdKSxvWzBdPUwqWFswXSt3LG9bMV09UypYWzFdK2Msb1syXT1VKlhbMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzJdKSxvWzBdPUwqWVswXSt3LG9bMV09UypZWzFdK2Msb1syXT1VKllbMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzNdKTtsZXQgVD1kKGcsWCxZLFApKjYscT1kKE0sWCxZLFApKjYsQz1kKE0sZyxZLFApKjYsRT1kKE0sZyxYLFApKjY7blswXVswXSo9VCxuWzBdWzFdKj1ULG5bMF1bMl0qPVQsblsxXVswXSo9cSxuWzFdWzFdKj1xLG5bMV1bMl0qPXEsblsyXVswXSo9QyxuWzJdWzFdKj1DLG5bMl1bMl0qPUMsblszXVswXSo9RSxuWzNdWzFdKj1FLG5bM11bMl0qPUUsZVswXT1uWzBdWzBdK25bMV1bMF0rblsyXVswXStuWzNdWzBdLGVbMV09blswXVsxXStuWzFdWzFdK25bMl1bMV0rblszXVsxXSxlWzJdPW5bMF1bMl0rblsxXVsyXStuWzJdWzJdK25bM11bMl19fXZhciB2PWNsYXNze3N0YXRpYyBleHBhbmQodCxyKXtsZXQgbT1NYXRoLmNicnQodC5sZW5ndGgvNCksaT1uZXcgRmxvYXQzMkFycmF5KDMpLGU9bmV3IHQuY29uc3RydWN0b3IocioqMyo0KSx5PXQgaW5zdGFuY2VvZiBVaW50OEFycmF5PzI1NToxLGg9cioqMixBPTEvKHItMSk7Zm9yKGxldCB3PTA7dzxyOysrdylmb3IobGV0IGM9MDtjPHI7KytjKWZvcihsZXQgbD0wO2w8cjsrK2wpe2xldCB4PWwqQSx1PWMqQSxiPXcqQSxzPU1hdGgucm91bmQobCtjKnIrdypoKSo0O2sodCxtLHgsdSxiLGkpLGVbcyswXT1pWzBdLGVbcysxXT1pWzFdLGVbcysyXT1pWzJdLGVbcyszXT15fXJldHVybiBlfX07c2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGE9PntsZXQgdD1hLmRhdGEscj10LmRhdGE7c3dpdGNoKHQub3BlcmF0aW9uKXtjYXNlIE8uU0NBTEVfVVA6cj12LmV4cGFuZChyLHQuc2l6ZSk7YnJlYWt9cG9zdE1lc3NhZ2Uocixbci5idWZmZXJdKSxjbG9zZSgpfSk7fSkoKTtcXG4nO1xuXG4vLyBzcmMvdGV4dHVyZXMvbHV0L0xvb2t1cFRleHR1cmUuanNcbnZhciBjID0gLyogQF9fUFVSRV9fICovIG5ldyBDb2xvcjQoKTtcbnZhciBMb29rdXBUZXh0dXJlID0gY2xhc3MgX0xvb2t1cFRleHR1cmUgZXh0ZW5kcyBEYXRhM0RUZXh0dXJlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjdWJpYyAzRCBsb29rdXAgdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIC0gVGhlIHBpeGVsIGRhdGEuIFRoZSBkZWZhdWx0IGZvcm1hdCBpcyBSR0JBLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIFRoZSBzaWRlbGVuZ3RoLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgc2l6ZSkge1xuICAgIHN1cGVyKGRhdGEsIHNpemUsIHNpemUsIHNpemUpO1xuICAgIHRoaXMudHlwZSA9IEZsb2F0VHlwZTQ7XG4gICAgdGhpcy5mb3JtYXQgPSBSR0JBRm9ybWF0O1xuICAgIHRoaXMubWluRmlsdGVyID0gTGluZWFyRmlsdGVyMztcbiAgICB0aGlzLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjM7XG4gICAgdGhpcy53cmFwUyA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgdGhpcy53cmFwVCA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgdGhpcy53cmFwUiA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMsIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICB0aGlzLmRvbWFpbk1pbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuZG9tYWluTWF4ID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgTG9va3VwVGV4dHVyZTNELlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBpc0xvb2t1cFRleHR1cmUzRCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2NhbGVzIHRoaXMgTFVUIHVwIHRvIGEgZ2l2ZW4gdGFyZ2V0IHNpemUgdXNpbmcgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgdGFyZ2V0IHNpZGVsZW5ndGguXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RyYW5zZmVyRGF0YT10cnVlXSAtIEV4dHJhIGZhc3QgbW9kZS4gU2V0IHRvIGZhbHNlIHRvIGtlZXAgdGhlIG9yaWdpbmFsIGRhdGEgaW50YWN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPExvb2t1cFRleHR1cmU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgbmV3IExVVCB1cG9uIGNvbXBsZXRpb24uXG4gICAqL1xuICBzY2FsZVVwKHNpemUsIHRyYW5zZmVyRGF0YSA9IHRydWUpIHtcbiAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKHNpemUgPD0gaW1hZ2Uud2lkdGgpIHtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJUaGUgdGFyZ2V0IHNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgc2l6ZVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHdvcmtlclVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dvcmtlcl9kZWZhdWx0XSwge1xuICAgICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2ZW50KSA9PiByZWplY3QoZXZlbnQuZXJyb3IpKTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGx1dCA9IG5ldyBfTG9va3VwVGV4dHVyZShldmVudC5kYXRhLCBzaXplKTtcbiAgICAgICAgICBjb3B5VGV4dHVyZUNvbG9yU3BhY2UodGhpcywgbHV0KTtcbiAgICAgICAgICBsdXQudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgICBsdXQubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTCk7XG4gICAgICAgICAgcmVzb2x2ZShsdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhbnNmZXJMaXN0ID0gdHJhbnNmZXJEYXRhID8gW2ltYWdlLmRhdGEuYnVmZmVyXSA6IFtdO1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIG9wZXJhdGlvbjogTFVUT3BlcmF0aW9uLlNDQUxFX1VQLFxuICAgICAgICAgIGRhdGE6IGltYWdlLmRhdGEsXG4gICAgICAgICAgc2l6ZVxuICAgICAgICB9LCB0cmFuc2Zlckxpc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBMVVQgdG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TG9va3VwVGV4dHVyZX0gbHV0IC0gQSBMVVQuIE11c3QgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLCB0eXBlIGFuZCBmb3JtYXQgYXMgdGhpcyBMVVQuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGFwcGx5TFVUKGx1dCkge1xuICAgIGNvbnN0IGltZzAgPSB0aGlzLmltYWdlO1xuICAgIGNvbnN0IGltZzEgPSBsdXQuaW1hZ2U7XG4gICAgY29uc3Qgc2l6ZTAgPSBNYXRoLm1pbihpbWcwLndpZHRoLCBpbWcwLmhlaWdodCwgaW1nMC5kZXB0aCk7XG4gICAgY29uc3Qgc2l6ZTEgPSBNYXRoLm1pbihpbWcxLndpZHRoLCBpbWcxLmhlaWdodCwgaW1nMS5kZXB0aCk7XG4gICAgaWYgKHNpemUwICE9PSBzaXplMSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlNpemUgbWlzbWF0Y2hcIik7XG4gICAgfSBlbHNlIGlmIChsdXQudHlwZSAhPT0gRmxvYXRUeXBlNCB8fCB0aGlzLnR5cGUgIT09IEZsb2F0VHlwZTQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJCb3RoIExVVHMgbXVzdCBiZSBGbG9hdFR5cGUgdGV4dHVyZXNcIik7XG4gICAgfSBlbHNlIGlmIChsdXQuZm9ybWF0ICE9PSBSR0JBRm9ybWF0IHx8IHRoaXMuZm9ybWF0ICE9PSBSR0JBRm9ybWF0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQm90aCBMVVRzIG11c3QgYmUgUkdCQSB0ZXh0dXJlc1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGF0YTAgPSBpbWcwLmRhdGE7XG4gICAgICBjb25zdCBkYXRhMSA9IGltZzEuZGF0YTtcbiAgICAgIGNvbnN0IHNpemUgPSBzaXplMDtcbiAgICAgIGNvbnN0IHNpemVTcSA9IHNpemUgKiogMjtcbiAgICAgIGNvbnN0IHMgPSBzaXplIC0gMTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc2l6ZSAqKiAzOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGk0ID0gaSAqIDQ7XG4gICAgICAgIGNvbnN0IHIgPSBkYXRhMFtpNCArIDBdICogcztcbiAgICAgICAgY29uc3QgZyA9IGRhdGEwW2k0ICsgMV0gKiBzO1xuICAgICAgICBjb25zdCBiID0gZGF0YTBbaTQgKyAyXSAqIHM7XG4gICAgICAgIGNvbnN0IGlSR0IgPSBNYXRoLnJvdW5kKHIgKyBnICogc2l6ZSArIGIgKiBzaXplU3EpICogNDtcbiAgICAgICAgZGF0YTBbaTQgKyAwXSA9IGRhdGExW2lSR0IgKyAwXTtcbiAgICAgICAgZGF0YTBbaTQgKyAxXSA9IGRhdGExW2lSR0IgKyAxXTtcbiAgICAgICAgZGF0YTBbaTQgKyAyXSA9IGRhdGExW2lSR0IgKyAyXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIExVVCBkYXRhIGludG8gdW5zaWduZWQgYnl0ZSBkYXRhLlxuICAgKlxuICAgKiBUaGlzIGlzIGEgbG9zc3kgb3BlcmF0aW9uIHdoaWNoIHNob3VsZCBvbmx5IGJlIHBlcmZvcm1lZCBhZnRlciBhbGwgb3RoZXIgdHJhbnNmb3JtYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGlzIHRleHR1cmUuXG4gICAqL1xuICBjb252ZXJ0VG9VaW50OCgpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSBGbG9hdFR5cGU0KSB7XG4gICAgICBjb25zdCBmbG9hdERhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgICBjb25zdCB1aW50OERhdGEgPSBuZXcgVWludDhBcnJheShmbG9hdERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZmxvYXREYXRhLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICB1aW50OERhdGFbaV0gPSBmbG9hdERhdGFbaV0gKiAyNTUgKyAwLjU7XG4gICAgICB9XG4gICAgICB0aGlzLmltYWdlLmRhdGEgPSB1aW50OERhdGE7XG4gICAgICB0aGlzLnR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlMTM7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBMVVQgZGF0YSBpbnRvIGZsb2F0IGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRUb0Zsb2F0KCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUxMykge1xuICAgICAgY29uc3QgdWludDhEYXRhID0gdGhpcy5pbWFnZS5kYXRhO1xuICAgICAgY29uc3QgZmxvYXREYXRhID0gbmV3IEZsb2F0MzJBcnJheSh1aW50OERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdWludDhEYXRhLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBmbG9hdERhdGFbaV0gPSB1aW50OERhdGFbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICB0aGlzLmltYWdlLmRhdGEgPSBmbG9hdERhdGE7XG4gICAgICB0aGlzLnR5cGUgPSBGbG9hdFR5cGU0O1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExVVCBpbnRvIFJHQkEgZGF0YS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgTFVUcyBhcmUgUkdCQSBieSBkZWZhdWx0IHNpbmNlIHRocmVlIHIxMzcuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRUb1JHQkEoKSB7XG4gICAgY29uc29sZS53YXJuKFwiTG9va3VwVGV4dHVyZVwiLCBcImNvbnZlcnRUb1JHQkEoKSBpcyBkZXByZWNhdGVkLCBMVVRzIGFyZSBub3cgUkdCQSBieSBkZWZhdWx0XCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgb3V0cHV0IG9mIHRoaXMgTFVUIGludG8gc1JHQiBjb2xvciBzcGFjZS5cbiAgICpcbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhpcyB0ZXh0dXJlLlxuICAgKi9cbiAgY29udmVydExpbmVhclRvU1JHQigpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5pbWFnZS5kYXRhO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IEZsb2F0VHlwZTQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgYy5mcm9tQXJyYXkoZGF0YSwgaSkuY29udmVydExpbmVhclRvU1JHQigpLnRvQXJyYXkoZGF0YSwgaSk7XG4gICAgICB9XG4gICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNvbG9yIHNwYWNlIGNvbnZlcnNpb24gcmVxdWlyZXMgRmxvYXRUeXBlIGRhdGFcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgb3V0cHV0IG9mIHRoaXMgTFVUIGludG8gbGluZWFyIGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGlzIHRleHR1cmUuXG4gICAqL1xuICBjb252ZXJ0U1JHQlRvTGluZWFyKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gRmxvYXRUeXBlNCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICBjLmZyb21BcnJheShkYXRhLCBpKS5jb252ZXJ0U1JHQlRvTGluZWFyKCkudG9BcnJheShkYXRhLCBpKTtcbiAgICAgIH1cbiAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMsIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ29sb3Igc3BhY2UgY29udmVyc2lvbiByZXF1aXJlcyBGbG9hdFR5cGUgZGF0YVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTFVUIGludG8gYSAyRCBkYXRhIHRleHR1cmUuXG4gICAqXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgY3VzdG9tIGlucHV0IGRvbWFpbnMgYXJlIG5vdCBjYXJyaWVkIG92ZXIgdG8gMkQgdGV4dHVyZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0RhdGFUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIHRvRGF0YVRleHR1cmUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmltYWdlLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaW1hZ2UuaGVpZ2h0ICogdGhpcy5pbWFnZS5kZXB0aDtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKHRoaXMuaW1hZ2UuZGF0YSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGV4dHVyZS5uYW1lID0gdGhpcy5uYW1lO1xuICAgIHRleHR1cmUudHlwZSA9IHRoaXMudHlwZTtcbiAgICB0ZXh0dXJlLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyMztcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjM7XG4gICAgdGV4dHVyZS53cmFwUyA9IHRoaXMud3JhcFM7XG4gICAgdGV4dHVyZS53cmFwVCA9IHRoaXMud3JhcFQ7XG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjb3B5VGV4dHVyZUNvbG9yU3BhY2UodGhpcywgdGV4dHVyZSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgM0QgTFVUIGJ5IGNvcHlpbmcgYSBnaXZlbiBMVVQuXG4gICAqXG4gICAqIENvbW1vbiBpbWFnZS1iYXNlZCB0ZXh0dXJlcyB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIDNEIGRhdGEgdGV4dHVyZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBMVVQuIEFzc3VtZWQgdG8gYmUgY3ViaWMuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IEEgbmV3IDNEIExVVC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHRleHR1cmUpIHtcbiAgICBjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKGltYWdlIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgIGNvbnN0IHJhd0ltYWdlRGF0YSA9IFJhd0ltYWdlRGF0YS5mcm9tKGltYWdlKTtcbiAgICAgIGNvbnN0IHNyYyA9IHJhd0ltYWdlRGF0YS5kYXRhO1xuICAgICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzcmMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCBzaXplOyArK3opIHtcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemU7ICsreSkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplOyArK3gpIHtcbiAgICAgICAgICAgICAgY29uc3QgaTQgPSAoeCArIHogKiBzaXplICsgeSAqIHNpemUgKiBzaXplKSAqIDQ7XG4gICAgICAgICAgICAgIGNvbnN0IGo0ID0gKHggKyB5ICogc2l6ZSArIHogKiBzaXplICogc2l6ZSkgKiA0O1xuICAgICAgICAgICAgICBkYXRhW2o0ICsgMF0gPSBzcmNbaTQgKyAwXTtcbiAgICAgICAgICAgICAgZGF0YVtqNCArIDFdID0gc3JjW2k0ICsgMV07XG4gICAgICAgICAgICAgIGRhdGFbajQgKyAyXSA9IHNyY1tpNCArIDJdO1xuICAgICAgICAgICAgICBkYXRhW2o0ICsgM10gPSBzcmNbaTQgKyAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzcmMuYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGltYWdlLmRhdGEuc2xpY2UoKTtcbiAgICB9XG4gICAgY29uc3QgbHV0ID0gbmV3IF9Mb29rdXBUZXh0dXJlKGRhdGEsIHNpemUpO1xuICAgIGx1dC50eXBlID0gdGV4dHVyZS50eXBlO1xuICAgIGx1dC5uYW1lID0gdGV4dHVyZS5uYW1lO1xuICAgIGNvcHlUZXh0dXJlQ29sb3JTcGFjZSh0ZXh0dXJlLCBsdXQpO1xuICAgIHJldHVybiBsdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXV0cmFsIDNEIExVVC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgc2lkZWxlbmd0aC5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gQSBuZXV0cmFsIDNEIExVVC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOZXV0cmFsKHNpemUpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICoqIDMgKiA0KTtcbiAgICBjb25zdCBzaXplU3EgPSBzaXplICoqIDI7XG4gICAgY29uc3QgcyA9IDEgLyAoc2l6ZSAtIDEpO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgc2l6ZTsgKytyKSB7XG4gICAgICBmb3IgKGxldCBnID0gMDsgZyA8IHNpemU7ICsrZykge1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHNpemU7ICsrYikge1xuICAgICAgICAgIGNvbnN0IGk0ID0gKHIgKyBnICogc2l6ZSArIGIgKiBzaXplU3EpICogNDtcbiAgICAgICAgICBkYXRhW2k0ICsgMF0gPSByICogcztcbiAgICAgICAgICBkYXRhW2k0ICsgMV0gPSBnICogcztcbiAgICAgICAgICBkYXRhW2k0ICsgMl0gPSBiICogcztcbiAgICAgICAgICBkYXRhW2k0ICsgM10gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGx1dCA9IG5ldyBfTG9va3VwVGV4dHVyZShkYXRhLCBzaXplKTtcbiAgICBsdXQubmFtZSA9IFwibmV1dHJhbFwiO1xuICAgIHJldHVybiBsdXQ7XG4gIH1cbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9sdXQvVGV0cmFoZWRyYWxVcHNjYWxlci5qc1xudmFyIFAgPSBbXG4gIG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gIG5ldyBGbG9hdDMyQXJyYXkoMylcbl07XG52YXIgQyA9IFtcbiAgbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgzKVxuXTtcbnZhciBUID0gW1xuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF0sXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXSxcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdLFxuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF0sXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXSxcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdXG5dO1xuZnVuY3Rpb24gY2FsY3VsYXRlVGV0cmFoZWRyb25Wb2x1bWUoYSwgYiwgYzIsIGQpIHtcbiAgY29uc3QgYmNYID0gYzJbMF0gLSBiWzBdO1xuICBjb25zdCBiY1kgPSBjMlsxXSAtIGJbMV07XG4gIGNvbnN0IGJjWiA9IGMyWzJdIC0gYlsyXTtcbiAgY29uc3QgYmFYID0gYVswXSAtIGJbMF07XG4gIGNvbnN0IGJhWSA9IGFbMV0gLSBiWzFdO1xuICBjb25zdCBiYVogPSBhWzJdIC0gYlsyXTtcbiAgY29uc3QgY3Jvc3NYID0gYmNZICogYmFaIC0gYmNaICogYmFZO1xuICBjb25zdCBjcm9zc1kgPSBiY1ogKiBiYVggLSBiY1ggKiBiYVo7XG4gIGNvbnN0IGNyb3NzWiA9IGJjWCAqIGJhWSAtIGJjWSAqIGJhWDtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KGNyb3NzWCAqIGNyb3NzWCArIGNyb3NzWSAqIGNyb3NzWSArIGNyb3NzWiAqIGNyb3NzWik7XG4gIGNvbnN0IHRyaWFuZ2xlQXJlYSA9IGxlbmd0aCAqIDAuNTtcbiAgY29uc3Qgbm9ybWFsWCA9IGNyb3NzWCAvIGxlbmd0aDtcbiAgY29uc3Qgbm9ybWFsWSA9IGNyb3NzWSAvIGxlbmd0aDtcbiAgY29uc3Qgbm9ybWFsWiA9IGNyb3NzWiAvIGxlbmd0aDtcbiAgY29uc3QgY29uc3RhbnQgPSAtKGFbMF0gKiBub3JtYWxYICsgYVsxXSAqIG5vcm1hbFkgKyBhWzJdICogbm9ybWFsWik7XG4gIGNvbnN0IGRvdCA9IGRbMF0gKiBub3JtYWxYICsgZFsxXSAqIG5vcm1hbFkgKyBkWzJdICogbm9ybWFsWjtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMoZG90ICsgY29uc3RhbnQpO1xuICByZXR1cm4gaGVpZ2h0ICogdHJpYW5nbGVBcmVhIC8gMztcbn1cbmZ1bmN0aW9uIHNhbXBsZShkYXRhLCBzaXplLCB4LCB5LCB6LCBjb2xvcjIpIHtcbiAgY29uc3QgaTQgPSAoeCArIHkgKiBzaXplICsgeiAqIHNpemUgKiBzaXplKSAqIDQ7XG4gIGNvbG9yMlswXSA9IGRhdGFbaTQgKyAwXTtcbiAgY29sb3IyWzFdID0gZGF0YVtpNCArIDFdO1xuICBjb2xvcjJbMl0gPSBkYXRhW2k0ICsgMl07XG59XG5mdW5jdGlvbiB0ZXRyYWhlZHJhbFNhbXBsZShkYXRhLCBzaXplLCB1LCB2MywgdywgY29sb3IyKSB7XG4gIGNvbnN0IHB4ID0gdSAqIChzaXplIC0gMSk7XG4gIGNvbnN0IHB5ID0gdjMgKiAoc2l6ZSAtIDEpO1xuICBjb25zdCBweiA9IHcgKiAoc2l6ZSAtIDEpO1xuICBjb25zdCBtaW5YID0gTWF0aC5mbG9vcihweCk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLmZsb29yKHB5KTtcbiAgY29uc3QgbWluWiA9IE1hdGguZmxvb3IocHopO1xuICBjb25zdCBtYXhYID0gTWF0aC5jZWlsKHB4KTtcbiAgY29uc3QgbWF4WSA9IE1hdGguY2VpbChweSk7XG4gIGNvbnN0IG1heFogPSBNYXRoLmNlaWwocHopO1xuICBjb25zdCBzdSA9IHB4IC0gbWluWDtcbiAgY29uc3Qgc3YgPSBweSAtIG1pblk7XG4gIGNvbnN0IHN3ID0gcHogLSBtaW5aO1xuICBpZiAobWluWCA9PT0gcHggJiYgbWluWSA9PT0gcHkgJiYgbWluWiA9PT0gcHopIHtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgcHgsIHB5LCBweiwgY29sb3IyKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdmVydGljZXM7XG4gICAgaWYgKHN1ID49IHN2ICYmIHN2ID49IHN3KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbMF07XG4gICAgfSBlbHNlIGlmIChzdSA+PSBzdyAmJiBzdyA+PSBzdikge1xuICAgICAgdmVydGljZXMgPSBUWzFdO1xuICAgIH0gZWxzZSBpZiAoc3cgPj0gc3UgJiYgc3UgPj0gc3YpIHtcbiAgICAgIHZlcnRpY2VzID0gVFsyXTtcbiAgICB9IGVsc2UgaWYgKHN2ID49IHN1ICYmIHN1ID49IHN3KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbM107XG4gICAgfSBlbHNlIGlmIChzdiA+PSBzdyAmJiBzdyA+PSBzdSkge1xuICAgICAgdmVydGljZXMgPSBUWzRdO1xuICAgIH0gZWxzZSBpZiAoc3cgPj0gc3YgJiYgc3YgPj0gc3UpIHtcbiAgICAgIHZlcnRpY2VzID0gVFs1XTtcbiAgICB9XG4gICAgY29uc3QgW1AwLCBQMSwgUDIsIFAzXSA9IHZlcnRpY2VzO1xuICAgIGNvbnN0IGNvb3JkcyA9IFBbMF07XG4gICAgY29vcmRzWzBdID0gc3U7XG4gICAgY29vcmRzWzFdID0gc3Y7XG4gICAgY29vcmRzWzJdID0gc3c7XG4gICAgY29uc3QgdG1wID0gUFsxXTtcbiAgICBjb25zdCBkaWZmWCA9IG1heFggLSBtaW5YO1xuICAgIGNvbnN0IGRpZmZZID0gbWF4WSAtIG1pblk7XG4gICAgY29uc3QgZGlmZlogPSBtYXhaIC0gbWluWjtcbiAgICB0bXBbMF0gPSBkaWZmWCAqIFAwWzBdICsgbWluWDtcbiAgICB0bXBbMV0gPSBkaWZmWSAqIFAwWzFdICsgbWluWTtcbiAgICB0bXBbMl0gPSBkaWZmWiAqIFAwWzJdICsgbWluWjtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgdG1wWzBdLCB0bXBbMV0sIHRtcFsyXSwgQ1swXSk7XG4gICAgdG1wWzBdID0gZGlmZlggKiBQMVswXSArIG1pblg7XG4gICAgdG1wWzFdID0gZGlmZlkgKiBQMVsxXSArIG1pblk7XG4gICAgdG1wWzJdID0gZGlmZlogKiBQMVsyXSArIG1pblo7XG4gICAgc2FtcGxlKGRhdGEsIHNpemUsIHRtcFswXSwgdG1wWzFdLCB0bXBbMl0sIENbMV0pO1xuICAgIHRtcFswXSA9IGRpZmZYICogUDJbMF0gKyBtaW5YO1xuICAgIHRtcFsxXSA9IGRpZmZZICogUDJbMV0gKyBtaW5ZO1xuICAgIHRtcFsyXSA9IGRpZmZaICogUDJbMl0gKyBtaW5aO1xuICAgIHNhbXBsZShkYXRhLCBzaXplLCB0bXBbMF0sIHRtcFsxXSwgdG1wWzJdLCBDWzJdKTtcbiAgICB0bXBbMF0gPSBkaWZmWCAqIFAzWzBdICsgbWluWDtcbiAgICB0bXBbMV0gPSBkaWZmWSAqIFAzWzFdICsgbWluWTtcbiAgICB0bXBbMl0gPSBkaWZmWiAqIFAzWzJdICsgbWluWjtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgdG1wWzBdLCB0bXBbMV0sIHRtcFsyXSwgQ1szXSk7XG4gICAgY29uc3QgVjAgPSBjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZShQMSwgUDIsIFAzLCBjb29yZHMpICogNjtcbiAgICBjb25zdCBWMSA9IGNhbGN1bGF0ZVRldHJhaGVkcm9uVm9sdW1lKFAwLCBQMiwgUDMsIGNvb3JkcykgKiA2O1xuICAgIGNvbnN0IFYyID0gY2FsY3VsYXRlVGV0cmFoZWRyb25Wb2x1bWUoUDAsIFAxLCBQMywgY29vcmRzKSAqIDY7XG4gICAgY29uc3QgVjMgPSBjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZShQMCwgUDEsIFAyLCBjb29yZHMpICogNjtcbiAgICBDWzBdWzBdICo9IFYwO1xuICAgIENbMF1bMV0gKj0gVjA7XG4gICAgQ1swXVsyXSAqPSBWMDtcbiAgICBDWzFdWzBdICo9IFYxO1xuICAgIENbMV1bMV0gKj0gVjE7XG4gICAgQ1sxXVsyXSAqPSBWMTtcbiAgICBDWzJdWzBdICo9IFYyO1xuICAgIENbMl1bMV0gKj0gVjI7XG4gICAgQ1syXVsyXSAqPSBWMjtcbiAgICBDWzNdWzBdICo9IFYzO1xuICAgIENbM11bMV0gKj0gVjM7XG4gICAgQ1szXVsyXSAqPSBWMztcbiAgICBjb2xvcjJbMF0gPSBDWzBdWzBdICsgQ1sxXVswXSArIENbMl1bMF0gKyBDWzNdWzBdO1xuICAgIGNvbG9yMlsxXSA9IENbMF1bMV0gKyBDWzFdWzFdICsgQ1syXVsxXSArIENbM11bMV07XG4gICAgY29sb3IyWzJdID0gQ1swXVsyXSArIENbMV1bMl0gKyBDWzJdWzJdICsgQ1szXVsyXTtcbiAgfVxufVxudmFyIFRldHJhaGVkcmFsVXBzY2FsZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBFeHBhbmRzIHRoZSBnaXZlbiBkYXRhIHRvIHRoZSB0YXJnZXQgc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIC0gVGhlIGlucHV0IFJHQkEgZGF0YS4gQXNzdW1lZCB0byBiZSBjdWJpYy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgdGFyZ2V0IHNpemUuXG4gICAqIEByZXR1cm4ge1R5cGVkQXJyYXl9IFRoZSBuZXcgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBleHBhbmQoZGF0YSwgc2l6ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IE1hdGguY2JydChkYXRhLmxlbmd0aCAvIDQpO1xuICAgIGNvbnN0IHJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgZGF0YS5jb25zdHJ1Y3RvcihzaXplICoqIDMgKiA0KTtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gMjU1IDogMTtcbiAgICBjb25zdCBzaXplU3EgPSBzaXplICoqIDI7XG4gICAgY29uc3QgcyA9IDEgLyAoc2l6ZSAtIDEpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgc2l6ZTsgKyt6KSB7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemU7ICsreSkge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7ICsreCkge1xuICAgICAgICAgIGNvbnN0IHUgPSB4ICogcztcbiAgICAgICAgICBjb25zdCB2MyA9IHkgKiBzO1xuICAgICAgICAgIGNvbnN0IHcgPSB6ICogcztcbiAgICAgICAgICBjb25zdCBpNCA9IE1hdGgucm91bmQoeCArIHkgKiBzaXplICsgeiAqIHNpemVTcSkgKiA0O1xuICAgICAgICAgIHRldHJhaGVkcmFsU2FtcGxlKGRhdGEsIG9yaWdpbmFsU2l6ZSwgdSwgdjMsIHcsIHJnYik7XG4gICAgICAgICAgYXJyYXlbaTQgKyAwXSA9IHJnYlswXTtcbiAgICAgICAgICBhcnJheVtpNCArIDFdID0gcmdiWzFdO1xuICAgICAgICAgIGFycmF5W2k0ICsgMl0gPSByZ2JbMl07XG4gICAgICAgICAgYXJyYXlbaTQgKyAzXSA9IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvU01BQUFyZWFJbWFnZURhdGEuanNcbnZhciBhcmVhID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KDIpLFxuICBuZXcgRmxvYXQzMkFycmF5KDIpXG5dO1xudmFyIE9SVEhPR09OQUxfU0laRSA9IDE2O1xudmFyIERJQUdPTkFMX1NJWkUgPSAyMDtcbnZhciBESUFHT05BTF9TQU1QTEVTID0gMzA7XG52YXIgU01PT1RIX01BWF9ESVNUQU5DRSA9IDMyO1xudmFyIG9ydGhvZ29uYWxTdWJzYW1wbGluZ09mZnNldHMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgMCxcbiAgLTAuMjUsXG4gIDAuMjUsXG4gIC0wLjEyNSxcbiAgMC4xMjUsXG4gIC0wLjM3NSxcbiAgMC4zNzVcbl0pO1xudmFyIGRpYWdvbmFsU3Vic2FtcGxpbmdPZmZzZXRzID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAuMjUsIC0wLjI1XSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWy0wLjI1LCAwLjI1XSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAuMTI1LCAtMC4xMjVdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbLTAuMTI1LCAwLjEyNV0pXG5dO1xudmFyIG9ydGhvZ29uYWxFZGdlcyA9IFtcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDRdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDRdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDRdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzQsIDRdKVxuXTtcbnZhciBkaWFnb25hbEVkZ2VzID0gW1xuICBuZXcgVWludDhBcnJheShbMCwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMSwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMCwgMl0pLFxuICBuZXcgVWludDhBcnJheShbMSwgMl0pLFxuICBuZXcgVWludDhBcnJheShbMiwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMywgMF0pLFxuICBuZXcgVWludDhBcnJheShbMiwgMl0pLFxuICBuZXcgVWludDhBcnJheShbMywgMl0pLFxuICBuZXcgVWludDhBcnJheShbMCwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMSwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMCwgM10pLFxuICBuZXcgVWludDhBcnJheShbMSwgM10pLFxuICBuZXcgVWludDhBcnJheShbMiwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMywgMV0pLFxuICBuZXcgVWludDhBcnJheShbMiwgM10pLFxuICBuZXcgVWludDhBcnJheShbMywgM10pXG5dO1xuZnVuY3Rpb24gbGVycChhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5mdW5jdGlvbiBzYXR1cmF0ZShhKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChhLCAwKSwgMSk7XG59XG5mdW5jdGlvbiBzbW9vdGhBcmVhKGQpIHtcbiAgY29uc3QgYTEgPSBhcmVhWzBdO1xuICBjb25zdCBhMiA9IGFyZWFbMV07XG4gIGNvbnN0IGIxWCA9IE1hdGguc3FydChhMVswXSAqIDIpICogMC41O1xuICBjb25zdCBiMVkgPSBNYXRoLnNxcnQoYTFbMV0gKiAyKSAqIDAuNTtcbiAgY29uc3QgYjJYID0gTWF0aC5zcXJ0KGEyWzBdICogMikgKiAwLjU7XG4gIGNvbnN0IGIyWSA9IE1hdGguc3FydChhMlsxXSAqIDIpICogMC41O1xuICBjb25zdCBwID0gc2F0dXJhdGUoZCAvIFNNT09USF9NQVhfRElTVEFOQ0UpO1xuICBhMVswXSA9IGxlcnAoYjFYLCBhMVswXSwgcCk7XG4gIGExWzFdID0gbGVycChiMVksIGExWzFdLCBwKTtcbiAgYTJbMF0gPSBsZXJwKGIyWCwgYTJbMF0sIHApO1xuICBhMlsxXSA9IGxlcnAoYjJZLCBhMlsxXSwgcCk7XG59XG5mdW5jdGlvbiBnZXRPcnRoQXJlYShwMVgsIHAxWSwgcDJYLCBwMlksIHgsIHJlc3VsdCkge1xuICBjb25zdCBkWCA9IHAyWCAtIHAxWDtcbiAgY29uc3QgZFkgPSBwMlkgLSBwMVk7XG4gIGNvbnN0IHgxID0geDtcbiAgY29uc3QgeDIgPSB4ICsgMTtcbiAgY29uc3QgeTEgPSBwMVkgKyBkWSAqICh4MSAtIHAxWCkgLyBkWDtcbiAgY29uc3QgeTIgPSBwMVkgKyBkWSAqICh4MiAtIHAxWCkgLyBkWDtcbiAgaWYgKHgxID49IHAxWCAmJiB4MSA8IHAyWCB8fCB4MiA+IHAxWCAmJiB4MiA8PSBwMlgpIHtcbiAgICBpZiAoTWF0aC5zaWduKHkxKSA9PT0gTWF0aC5zaWduKHkyKSB8fCBNYXRoLmFicyh5MSkgPCAxZS00IHx8IE1hdGguYWJzKHkyKSA8IDFlLTQpIHtcbiAgICAgIGNvbnN0IGEgPSAoeTEgKyB5MikgLyAyO1xuICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgIHJlc3VsdFswXSA9IE1hdGguYWJzKGEpO1xuICAgICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5hYnMoYSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSAtcDFZICogZFggLyBkWSArIHAxWDtcbiAgICAgIGNvbnN0IHRJbnQgPSBNYXRoLnRydW5jKHQpO1xuICAgICAgY29uc3QgYTEgPSB0ID4gcDFYID8geTEgKiAodCAtIHRJbnQpIC8gMiA6IDA7XG4gICAgICBjb25zdCBhMiA9IHQgPCBwMlggPyB5MiAqICgxIC0gKHQgLSB0SW50KSkgLyAyIDogMDtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLmFicyhhMSkgPiBNYXRoLmFicyhhMikgPyBhMSA6IC1hMjtcbiAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICByZXN1bHRbMF0gPSBNYXRoLmFicyhhMSk7XG4gICAgICAgIHJlc3VsdFsxXSA9IE1hdGguYWJzKGEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IE1hdGguYWJzKGEyKTtcbiAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5hYnMoYTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHRbMF0gPSAwO1xuICAgIHJlc3VsdFsxXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE9ydGhBcmVhRm9yUGF0dGVybihwYXR0ZXJuLCBsZWZ0LCByaWdodCwgb2Zmc2V0LCByZXN1bHQpIHtcbiAgY29uc3QgYTEgPSBhcmVhWzBdO1xuICBjb25zdCBhMiA9IGFyZWFbMV07XG4gIGNvbnN0IG8xID0gMC41ICsgb2Zmc2V0O1xuICBjb25zdCBvMiA9IDAuNSArIG9mZnNldCAtIDE7XG4gIGNvbnN0IGQgPSBsZWZ0ICsgcmlnaHQgKyAxO1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgaWYgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQgLyAyLCAwLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDI6IHtcbiAgICAgIGlmIChsZWZ0ID49IHJpZ2h0KSB7XG4gICAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMiwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAzOiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCAvIDIsIDAsIGxlZnQsIGExKTtcbiAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMiwgbGVmdCwgYTIpO1xuICAgICAgc21vb3RoQXJlYShkLCBhcmVhKTtcbiAgICAgIHJlc3VsdFswXSA9IGExWzBdICsgYTJbMF07XG4gICAgICByZXN1bHRbMV0gPSBhMVsxXSArIGEyWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNDoge1xuICAgICAgaWYgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQgLyAyLCAwLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDU6IHtcbiAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNjoge1xuICAgICAgaWYgKE1hdGguYWJzKG9mZnNldCkgPiAwKSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkLCBvMiwgbGVmdCwgYTEpO1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCAvIDIsIDAsIGxlZnQsIGEyKTtcbiAgICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgICBhMlswXSA9IGEyWzBdICsgcmVzdWx0WzBdO1xuICAgICAgICBhMlsxXSA9IGEyWzFdICsgcmVzdWx0WzFdO1xuICAgICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNzoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgODoge1xuICAgICAgaWYgKGxlZnQgPj0gcmlnaHQpIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8xLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDk6IHtcbiAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQpID4gMCkge1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCwgbzEsIGxlZnQsIGExKTtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQgLyAyLCAwLCBsZWZ0LCBhMik7XG4gICAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMSwgbGVmdCwgcmVzdWx0KTtcbiAgICAgICAgYTJbMF0gPSBhMlswXSArIHJlc3VsdFswXTtcbiAgICAgICAgYTJbMV0gPSBhMlsxXSArIHJlc3VsdFsxXTtcbiAgICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkLCBvMSwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEwOiB7XG4gICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDExOiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCwgbzEsIGxlZnQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMjoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQgLyAyLCAwLCBsZWZ0LCBhMSk7XG4gICAgICBnZXRPcnRoQXJlYShkIC8gMiwgMCwgZCwgbzEsIGxlZnQsIGEyKTtcbiAgICAgIHNtb290aEFyZWEoZCwgYXJlYSk7XG4gICAgICByZXN1bHRbMF0gPSBhMVswXSArIGEyWzBdO1xuICAgICAgcmVzdWx0WzFdID0gYTFbMV0gKyBhMlsxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEzOiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCwgbzEsIGxlZnQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxNDoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTU6IHtcbiAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0luc2lkZUFyZWEoYTFYLCBhMVksIGEyWCwgYTJZLCB4LCB5KSB7XG4gIGxldCByZXN1bHQgPSBhMVggPT09IGEyWCAmJiBhMVkgPT09IGEyWTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICBjb25zdCB4bSA9IChhMVggKyBhMlgpIC8gMjtcbiAgICBjb25zdCB5bSA9IChhMVkgKyBhMlkpIC8gMjtcbiAgICBjb25zdCBhID0gYTJZIC0gYTFZO1xuICAgIGNvbnN0IGIgPSBhMVggLSBhMlg7XG4gICAgY29uc3QgYzIgPSBhICogKHggLSB4bSkgKyBiICogKHkgLSB5bSk7XG4gICAgcmVzdWx0ID0gYzIgPiAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREaWFnQXJlYUZvclBpeGVsKGExWCwgYTFZLCBhMlgsIGEyWSwgcFgsIHBZKSB7XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBESUFHT05BTF9TQU1QTEVTOyArK3kpIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IERJQUdPTkFMX1NBTVBMRVM7ICsreCkge1xuICAgICAgY29uc3Qgb2Zmc2V0WCA9IHggLyAoRElBR09OQUxfU0FNUExFUyAtIDEpO1xuICAgICAgY29uc3Qgb2Zmc2V0WSA9IHkgLyAoRElBR09OQUxfU0FNUExFUyAtIDEpO1xuICAgICAgaWYgKGlzSW5zaWRlQXJlYShhMVgsIGExWSwgYTJYLCBhMlksIHBYICsgb2Zmc2V0WCwgcFkgKyBvZmZzZXRZKSkge1xuICAgICAgICArK247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuIC8gKERJQUdPTkFMX1NBTVBMRVMgKiBESUFHT05BTF9TQU1QTEVTKTtcbn1cbmZ1bmN0aW9uIGdldERpYWdBcmVhKHBhdHRlcm4sIGExWCwgYTFZLCBhMlgsIGEyWSwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpIHtcbiAgY29uc3QgZSA9IGRpYWdvbmFsRWRnZXNbcGF0dGVybl07XG4gIGNvbnN0IGUxID0gZVswXTtcbiAgY29uc3QgZTIgPSBlWzFdO1xuICBpZiAoZTEgPiAwKSB7XG4gICAgYTFYICs9IG9mZnNldFswXTtcbiAgICBhMVkgKz0gb2Zmc2V0WzFdO1xuICB9XG4gIGlmIChlMiA+IDApIHtcbiAgICBhMlggKz0gb2Zmc2V0WzBdO1xuICAgIGEyWSArPSBvZmZzZXRbMV07XG4gIH1cbiAgcmVzdWx0WzBdID0gMSAtIGdldERpYWdBcmVhRm9yUGl4ZWwoYTFYLCBhMVksIGEyWCwgYTJZLCAxICsgbGVmdCwgMCArIGxlZnQpO1xuICByZXN1bHRbMV0gPSBnZXREaWFnQXJlYUZvclBpeGVsKGExWCwgYTFZLCBhMlgsIGEyWSwgMSArIGxlZnQsIDEgKyBsZWZ0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldERpYWdBcmVhRm9yUGF0dGVybihwYXR0ZXJuLCBsZWZ0LCByaWdodCwgb2Zmc2V0LCByZXN1bHQpIHtcbiAgY29uc3QgYTEgPSBhcmVhWzBdO1xuICBjb25zdCBhMiA9IGFyZWFbMV07XG4gIGNvbnN0IGQgPSBsZWZ0ICsgcmlnaHQgKyAxO1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAwICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMCwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDM6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNDoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMCArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDU6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDAgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA2OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDc6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA4OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAwLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgOToge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEwOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAwLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTE6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMjoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMzoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE0OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTU6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0dGVybnMocGF0dGVybnMsIG9mZnNldCwgb3J0aG9nb25hbCkge1xuICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcbiAgICBjb25zdCBkYXRhID0gcGF0dGVybi5kYXRhO1xuICAgIGNvbnN0IHNpemUgPSBwYXR0ZXJuLndpZHRoO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZTsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7ICsreCkge1xuICAgICAgICBpZiAob3J0aG9nb25hbCkge1xuICAgICAgICAgIGdldE9ydGhBcmVhRm9yUGF0dGVybihpLCB4LCB5LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2V0RGlhZ0FyZWFGb3JQYXR0ZXJuKGksIHgsIHksIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjMiA9ICh5ICogc2l6ZSArIHgpICogMjtcbiAgICAgICAgZGF0YVtjMl0gPSByZXN1bHRbMF0gKiAyNTU7XG4gICAgICAgIGRhdGFbYzIgKyAxXSA9IHJlc3VsdFsxXSAqIDI1NTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VtYmxlKGJhc2VYLCBiYXNlWSwgcGF0dGVybnMsIGVkZ2VzMiwgc2l6ZSwgb3J0aG9nb25hbCwgdGFyZ2V0KSB7XG4gIGNvbnN0IGRzdERhdGEgPSB0YXJnZXQuZGF0YTtcbiAgY29uc3QgZHN0V2lkdGggPSB0YXJnZXQud2lkdGg7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgZWRnZSA9IGVkZ2VzMltpXTtcbiAgICBjb25zdCBwYXR0ZXJuID0gcGF0dGVybnNbaV07XG4gICAgY29uc3Qgc3JjRGF0YSA9IHBhdHRlcm4uZGF0YTtcbiAgICBjb25zdCBzcmNXaWR0aCA9IHBhdHRlcm4ud2lkdGg7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZTsgKyt4KSB7XG4gICAgICAgIGNvbnN0IHBYID0gZWRnZVswXSAqIHNpemUgKyBiYXNlWCArIHg7XG4gICAgICAgIGNvbnN0IHBZID0gZWRnZVsxXSAqIHNpemUgKyBiYXNlWSArIHk7XG4gICAgICAgIGNvbnN0IGMyID0gKHBZICogZHN0V2lkdGggKyBwWCkgKiA0O1xuICAgICAgICBjb25zdCBkID0gb3J0aG9nb25hbCA/ICh5ICogeSAqIHNyY1dpZHRoICsgeCAqIHgpICogMiA6ICh5ICogc3JjV2lkdGggKyB4KSAqIDI7XG4gICAgICAgIGRzdERhdGFbYzJdID0gc3JjRGF0YVtkXTtcbiAgICAgICAgZHN0RGF0YVtjMiArIDFdID0gc3JjRGF0YVtkICsgMV07XG4gICAgICAgIGRzdERhdGFbYzIgKyAyXSA9IDA7XG4gICAgICAgIGRzdERhdGFbYzIgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBTTUFBQXJlYUltYWdlRGF0YSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYXJlYSBpbWFnZS5cbiAgICpcbiAgICogQHJldHVybiB7UmF3SW1hZ2VEYXRhfSBUaGUgZ2VuZXJhdGVkIGltYWdlIGRhdGEuXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSAyICogNSAqIE9SVEhPR09OQUxfU0laRTtcbiAgICBjb25zdCBoZWlnaHQgPSBvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzLmxlbmd0aCAqIDUgKiBPUlRIT0dPTkFMX1NJWkU7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSYXdJbWFnZURhdGEod2lkdGgsIGhlaWdodCwgZGF0YSk7XG4gICAgY29uc3Qgb3J0aFBhdHRlcm5TaXplID0gTWF0aC5wb3coT1JUSE9HT05BTF9TSVpFIC0gMSwgMikgKyAxO1xuICAgIGNvbnN0IGRpYWdQYXR0ZXJuU2l6ZSA9IERJQUdPTkFMX1NJWkU7XG4gICAgY29uc3Qgb3J0aG9nb25hbFBhdHRlcm5zID0gW107XG4gICAgY29uc3QgZGlhZ29uYWxQYXR0ZXJucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAzLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaV0gPSAyNTU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgb3J0aG9nb25hbFBhdHRlcm5zLnB1c2gobmV3IFJhd0ltYWdlRGF0YShcbiAgICAgICAgb3J0aFBhdHRlcm5TaXplLFxuICAgICAgICBvcnRoUGF0dGVyblNpemUsXG4gICAgICAgIG5ldyBVaW50OENsYW1wZWRBcnJheShvcnRoUGF0dGVyblNpemUgKiBvcnRoUGF0dGVyblNpemUgKiAyKSxcbiAgICAgICAgMlxuICAgICAgKSk7XG4gICAgICBkaWFnb25hbFBhdHRlcm5zLnB1c2gobmV3IFJhd0ltYWdlRGF0YShcbiAgICAgICAgZGlhZ1BhdHRlcm5TaXplLFxuICAgICAgICBkaWFnUGF0dGVyblNpemUsXG4gICAgICAgIG5ldyBVaW50OENsYW1wZWRBcnJheShkaWFnUGF0dGVyblNpemUgKiBkaWFnUGF0dGVyblNpemUgKiAyKSxcbiAgICAgICAgMlxuICAgICAgKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3J0aG9nb25hbFN1YnNhbXBsaW5nT2Zmc2V0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGdlbmVyYXRlUGF0dGVybnMob3J0aG9nb25hbFBhdHRlcm5zLCBvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzW2ldLCB0cnVlKTtcbiAgICAgIGFzc2VtYmxlKFxuICAgICAgICAwLFxuICAgICAgICA1ICogT1JUSE9HT05BTF9TSVpFICogaSxcbiAgICAgICAgb3J0aG9nb25hbFBhdHRlcm5zLFxuICAgICAgICBvcnRob2dvbmFsRWRnZXMsXG4gICAgICAgIE9SVEhPR09OQUxfU0laRSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgcmVzdWx0XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRpYWdvbmFsU3Vic2FtcGxpbmdPZmZzZXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgZ2VuZXJhdGVQYXR0ZXJucyhkaWFnb25hbFBhdHRlcm5zLCBkaWFnb25hbFN1YnNhbXBsaW5nT2Zmc2V0c1tpXSwgZmFsc2UpO1xuICAgICAgYXNzZW1ibGUoXG4gICAgICAgIDUgKiBPUlRIT0dPTkFMX1NJWkUsXG4gICAgICAgIDQgKiBESUFHT05BTF9TSVpFICogaSxcbiAgICAgICAgZGlhZ29uYWxQYXR0ZXJucyxcbiAgICAgICAgZGlhZ29uYWxFZGdlcyxcbiAgICAgICAgRElBR09OQUxfU0laRSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHJlc3VsdFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvU01BQUltYWdlR2VuZXJhdG9yLmpzXG5pbXBvcnQgeyBMb2FkaW5nTWFuYWdlciB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyB0bXAvc21hYS93b3JrZXIudHh0XG52YXIgd29ya2VyX2RlZmF1bHQyID0gJ1widXNlIHN0cmljdFwiOygoKT0+e2Z1bmN0aW9uIHEodCxhLHMpe2xldCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksbj1lLmdldENvbnRleHQoXCIyZFwiKTtpZihlLndpZHRoPXQsZS5oZWlnaHQ9YSxzIGluc3RhbmNlb2YgSW1hZ2Upbi5kcmF3SW1hZ2UocywwLDApO2Vsc2V7bGV0IHI9bi5jcmVhdGVJbWFnZURhdGEodCxhKTtyLmRhdGEuc2V0KHMpLG4ucHV0SW1hZ2VEYXRhKHIsMCwwKX1yZXR1cm4gZX12YXIgRj1jbGFzcyB0e2NvbnN0cnVjdG9yKGE9MCxzPTAsZT1udWxsKXt0aGlzLndpZHRoPWEsdGhpcy5oZWlnaHQ9cyx0aGlzLmRhdGE9ZX10b0NhbnZhcygpe3JldHVybiB0eXBlb2YgZG9jdW1lbnQ9PVwidW5kZWZpbmVkXCI/bnVsbDpxKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5kYXRhKX1zdGF0aWMgZnJvbShhKXtsZXR7d2lkdGg6cyxoZWlnaHQ6ZX09YSxuO2lmKGEgaW5zdGFuY2VvZiBJbWFnZSl7bGV0IHI9cShzLGUsYSk7ciE9PW51bGwmJihuPXIuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAscyxlKS5kYXRhKX1lbHNlIG49YS5kYXRhO3JldHVybiBuZXcgdChzLGUsbil9fTt2YXIgTT1bbmV3IEZsb2F0MzJBcnJheSgyKSxuZXcgRmxvYXQzMkFycmF5KDIpXSxEPTE2LFc9MjAsST0zMCxqPTMyLHY9bmV3IEZsb2F0MzJBcnJheShbMCwtLjI1LC4yNSwtLjEyNSwuMTI1LC0uMzc1LC4zNzVdKSxOPVtuZXcgRmxvYXQzMkFycmF5KFswLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsuMjUsLS4yNV0pLG5ldyBGbG9hdDMyQXJyYXkoWy0uMjUsLjI1XSksbmV3IEZsb2F0MzJBcnJheShbLjEyNSwtLjEyNV0pLG5ldyBGbG9hdDMyQXJyYXkoWy0uMTI1LC4xMjVdKV0sej1bbmV3IFVpbnQ4QXJyYXkoWzAsMF0pLG5ldyBVaW50OEFycmF5KFszLDBdKSxuZXcgVWludDhBcnJheShbMCwzXSksbmV3IFVpbnQ4QXJyYXkoWzMsM10pLG5ldyBVaW50OEFycmF5KFsxLDBdKSxuZXcgVWludDhBcnJheShbNCwwXSksbmV3IFVpbnQ4QXJyYXkoWzEsM10pLG5ldyBVaW50OEFycmF5KFs0LDNdKSxuZXcgVWludDhBcnJheShbMCwxXSksbmV3IFVpbnQ4QXJyYXkoWzMsMV0pLG5ldyBVaW50OEFycmF5KFswLDRdKSxuZXcgVWludDhBcnJheShbMyw0XSksbmV3IFVpbnQ4QXJyYXkoWzEsMV0pLG5ldyBVaW50OEFycmF5KFs0LDFdKSxuZXcgVWludDhBcnJheShbMSw0XSksbmV3IFVpbnQ4QXJyYXkoWzQsNF0pXSxwPVtuZXcgVWludDhBcnJheShbMCwwXSksbmV3IFVpbnQ4QXJyYXkoWzEsMF0pLG5ldyBVaW50OEFycmF5KFswLDJdKSxuZXcgVWludDhBcnJheShbMSwyXSksbmV3IFVpbnQ4QXJyYXkoWzIsMF0pLG5ldyBVaW50OEFycmF5KFszLDBdKSxuZXcgVWludDhBcnJheShbMiwyXSksbmV3IFVpbnQ4QXJyYXkoWzMsMl0pLG5ldyBVaW50OEFycmF5KFswLDFdKSxuZXcgVWludDhBcnJheShbMSwxXSksbmV3IFVpbnQ4QXJyYXkoWzAsM10pLG5ldyBVaW50OEFycmF5KFsxLDNdKSxuZXcgVWludDhBcnJheShbMiwxXSksbmV3IFVpbnQ4QXJyYXkoWzMsMV0pLG5ldyBVaW50OEFycmF5KFsyLDNdKSxuZXcgVWludDhBcnJheShbMywzXSldO2Z1bmN0aW9uIEModCxhLHMpe3JldHVybiB0KyhhLXQpKnN9ZnVuY3Rpb24gQih0KXtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodCwwKSwxKX1mdW5jdGlvbiBfKHQpe2xldCBhPU1bMF0scz1NWzFdLGU9TWF0aC5zcXJ0KGFbMF0qMikqLjUsbj1NYXRoLnNxcnQoYVsxXSoyKSouNSxyPU1hdGguc3FydChzWzBdKjIpKi41LG89TWF0aC5zcXJ0KHNbMV0qMikqLjUsYz1CKHQvaik7YVswXT1DKGUsYVswXSxjKSxhWzFdPUMobixhWzFdLGMpLHNbMF09QyhyLHNbMF0sYyksc1sxXT1DKG8sc1sxXSxjKX1mdW5jdGlvbiBkKHQsYSxzLGUsbixyKXtsZXQgbz1zLXQsYz1lLWEsaD1uLGk9bisxLHc9YStjKihoLXQpL28sYj1hK2MqKGktdCkvbztpZihoPj10JiZoPHN8fGk+dCYmaTw9cylpZihNYXRoLnNpZ24odyk9PT1NYXRoLnNpZ24oYil8fE1hdGguYWJzKHcpPDFlLTR8fE1hdGguYWJzKGIpPDFlLTQpe2xldCBnPSh3K2IpLzI7ZzwwPyhyWzBdPU1hdGguYWJzKGcpLHJbMV09MCk6KHJbMF09MCxyWzFdPU1hdGguYWJzKGcpKX1lbHNle2xldCBnPS1hKm8vYyt0LGs9TWF0aC50cnVuYyhnKSxtPWc+dD93KihnLWspLzI6MCxVPWc8cz9iKigxLShnLWspKS8yOjA7KE1hdGguYWJzKG0pPk1hdGguYWJzKFUpP206LVUpPDA/KHJbMF09TWF0aC5hYnMobSksclsxXT1NYXRoLmFicyhVKSk6KHJbMF09TWF0aC5hYnMoVSksclsxXT1NYXRoLmFicyhtKSl9ZWxzZSByWzBdPTAsclsxXT0wO3JldHVybiByfWZ1bmN0aW9uIEoodCxhLHMsZSxuKXtsZXQgcj1NWzBdLG89TVsxXSxjPS41K2UsaD0uNStlLTEsaT1hK3MrMTtzd2l0Y2godCl7Y2FzZSAwOntuWzBdPTAsblsxXT0wO2JyZWFrfWNhc2UgMTp7YTw9cz9kKDAsaCxpLzIsMCxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDI6e2E+PXM/ZChpLzIsMCxpLGgsYSxuKTooblswXT0wLG5bMV09MCk7YnJlYWt9Y2FzZSAzOntkKDAsaCxpLzIsMCxhLHIpLGQoaS8yLDAsaSxoLGEsbyksXyhpLE0pLG5bMF09clswXStvWzBdLG5bMV09clsxXStvWzFdO2JyZWFrfWNhc2UgNDp7YTw9cz9kKDAsYyxpLzIsMCxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDU6e25bMF09MCxuWzFdPTA7YnJlYWt9Y2FzZSA2OntNYXRoLmFicyhlKT4wPyhkKDAsYyxpLGgsYSxyKSxkKDAsYyxpLzIsMCxhLG8pLGQoaS8yLDAsaSxoLGEsbiksb1swXT1vWzBdK25bMF0sb1sxXT1vWzFdK25bMV0sblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMik6ZCgwLGMsaSxoLGEsbik7YnJlYWt9Y2FzZSA3OntkKDAsYyxpLGgsYSxuKTticmVha31jYXNlIDg6e2E+PXM/ZChpLzIsMCxpLGMsYSxuKTooblswXT0wLG5bMV09MCk7YnJlYWt9Y2FzZSA5OntNYXRoLmFicyhlKT4wPyhkKDAsaCxpLGMsYSxyKSxkKDAsaCxpLzIsMCxhLG8pLGQoaS8yLDAsaSxjLGEsbiksb1swXT1vWzBdK25bMF0sb1sxXT1vWzFdK25bMV0sblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMik6ZCgwLGgsaSxjLGEsbik7YnJlYWt9Y2FzZSAxMDp7blswXT0wLG5bMV09MDticmVha31jYXNlIDExOntkKDAsaCxpLGMsYSxuKTticmVha31jYXNlIDEyOntkKDAsYyxpLzIsMCxhLHIpLGQoaS8yLDAsaSxjLGEsbyksXyhpLE0pLG5bMF09clswXStvWzBdLG5bMV09clsxXStvWzFdO2JyZWFrfWNhc2UgMTM6e2QoMCxoLGksYyxhLG4pO2JyZWFrfWNhc2UgMTQ6e2QoMCxjLGksaCxhLG4pO2JyZWFrfWNhc2UgMTU6e25bMF09MCxuWzFdPTA7YnJlYWt9fXJldHVybiBufWZ1bmN0aW9uIEsodCxhLHMsZSxuLHIpe2xldCBvPXQ9PT1zJiZhPT09ZTtpZighbyl7bGV0IGM9KHQrcykvMixoPShhK2UpLzIsaT1lLWEsdz10LXM7bz1pKihuLWMpK3cqKHItaCk+MH1yZXR1cm4gb31mdW5jdGlvbiBHKHQsYSxzLGUsbixyKXtsZXQgbz0wO2ZvcihsZXQgYz0wO2M8STsrK2MpZm9yKGxldCBoPTA7aDxJOysraCl7bGV0IGk9aC8oSS0xKSx3PWMvKEktMSk7Syh0LGEscyxlLG4raSxyK3cpJiYrK299cmV0dXJuIG8vKEkqSSl9ZnVuY3Rpb24gQSh0LGEscyxlLG4scixvLGMpe2xldCBoPXBbdF0saT1oWzBdLHc9aFsxXTtyZXR1cm4gaT4wJiYoYSs9b1swXSxzKz1vWzFdKSx3PjAmJihlKz1vWzBdLG4rPW9bMV0pLGNbMF09MS1HKGEscyxlLG4sMStyLDArciksY1sxXT1HKGEscyxlLG4sMStyLDErciksY31mdW5jdGlvbiBRKHQsYSxzLGUsbil7bGV0IHI9TVswXSxvPU1bMV0sYz1hK3MrMTtzd2l0Y2godCl7Y2FzZSAwOntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDE6e0EodCwxLDAsMCtjLDArYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMjp7QSh0LDAsMCwxK2MsMCtjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAzOntBKHQsMSwwLDErYywwK2MsYSxlLG4pO2JyZWFrfWNhc2UgNDp7QSh0LDEsMSwwK2MsMCtjLGEsZSxyKSxBKHQsMSwxLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSA1OntBKHQsMSwxLDArYywwK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDY6e0EodCwxLDEsMStjLDArYyxhLGUsbik7YnJlYWt9Y2FzZSA3OntBKHQsMSwxLDErYywwK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDg6e0EodCwwLDAsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMStjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgOTp7QSh0LDEsMCwxK2MsMStjLGEsZSxuKSxBKHQsMSwwLDErYywxK2MsYSxlLG4pO2JyZWFrfWNhc2UgMTA6e0EodCwwLDAsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMTE6e0EodCwxLDAsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMTI6e0EodCwxLDEsMStjLDErYyxhLGUsbik7YnJlYWt9Y2FzZSAxMzp7QSh0LDEsMSwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywxK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxNDp7QSh0LDEsMSwxK2MsMStjLGEsZSxyKSxBKHQsMSwxLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxNTp7QSh0LDEsMSwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9fXJldHVybiBufWZ1bmN0aW9uIFIodCxhLHMpe2xldCBlPW5ldyBGbG9hdDMyQXJyYXkoMik7Zm9yKGxldCBuPTAscj10Lmxlbmd0aDtuPHI7KytuKXtsZXQgbz10W25dLGM9by5kYXRhLGg9by53aWR0aDtmb3IobGV0IGk9MDtpPGg7KytpKWZvcihsZXQgdz0wO3c8aDsrK3cpe3M/SihuLHcsaSxhLGUpOlEobix3LGksYSxlKTtsZXQgYj0oaSpoK3cpKjI7Y1tiXT1lWzBdKjI1NSxjW2IrMV09ZVsxXSoyNTV9fX1mdW5jdGlvbiBUKHQsYSxzLGUsbixyLG8pe2xldCBjPW8uZGF0YSxoPW8ud2lkdGg7Zm9yKGxldCBpPTAsdz1zLmxlbmd0aDtpPHc7KytpKXtsZXQgYj1lW2ldLGc9c1tpXSxrPWcuZGF0YSxtPWcud2lkdGg7Zm9yKGxldCBVPTA7VTxuOysrVSlmb3IobGV0IHg9MDt4PG47Kyt4KXtsZXQgWj1iWzBdKm4rdCt4LE89KChiWzFdKm4rYStVKSpoK1opKjQsTD1yPyhVKlUqbSt4KngpKjI6KFUqbSt4KSoyO2NbT109a1tMXSxjW08rMV09a1tMKzFdLGNbTysyXT0wLGNbTyszXT0yNTV9fX12YXIgUz1jbGFzc3tzdGF0aWMgZ2VuZXJhdGUoKXtsZXQgYT0xMCpELHM9di5sZW5ndGgqNSpELGU9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGEqcyo0KSxuPW5ldyBGKGEscyxlKSxyPU1hdGgucG93KEQtMSwyKSsxLG89VyxjPVtdLGg9W107Zm9yKGxldCBpPTMsdz1lLmxlbmd0aDtpPHc7aSs9NCllW2ldPTI1NTtmb3IobGV0IGk9MDtpPDE2OysraSljLnB1c2gobmV3IEYocixyLG5ldyBVaW50OENsYW1wZWRBcnJheShyKnIqMiksMikpLGgucHVzaChuZXcgRihvLG8sbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG8qbyoyKSwyKSk7Zm9yKGxldCBpPTAsdz12Lmxlbmd0aDtpPHc7KytpKVIoYyx2W2ldLCEwKSxUKDAsNSpEKmksYyx6LEQsITAsbik7Zm9yKGxldCBpPTAsdz1OLmxlbmd0aDtpPHc7KytpKVIoaCxOW2ldLCExKSxUKDUqRCw0KlcqaSxoLHAsVywhMSxuKTtyZXR1cm4gbn19O3ZhciBQPW5ldyBNYXAoW1t5KDAsMCwwLDApLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwwLDBdKV0sW3koMCwwLDAsMSksbmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMV0pXSxbeSgwLDAsMSwwKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMSwwXSldLFt5KDAsMCwxLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwxLDFdKV0sW3koMCwxLDAsMCksbmV3IEZsb2F0MzJBcnJheShbMCwxLDAsMF0pXSxbeSgwLDEsMCwxKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMCwxXSldLFt5KDAsMSwxLDApLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwxLDBdKV0sW3koMCwxLDEsMSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDEsMV0pXSxbeSgxLDAsMCwwKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMCwwXSldLFt5KDEsMCwwLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwLDFdKV0sW3koMSwwLDEsMCksbmV3IEZsb2F0MzJBcnJheShbMSwwLDEsMF0pXSxbeSgxLDAsMSwxKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMSwxXSldLFt5KDEsMSwwLDApLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwwLDBdKV0sW3koMSwxLDAsMSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDAsMV0pXSxbeSgxLDEsMSwwKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMSwwXSldLFt5KDEsMSwxLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxLDFdKV1dKTtmdW5jdGlvbiBIKHQsYSxzKXtyZXR1cm4gdCsoYS10KSpzfWZ1bmN0aW9uIHkodCxhLHMsZSl7bGV0IG49SCh0LGEsLjc1KSxyPUgocyxlLDEtLjI1KTtyZXR1cm4gSChuLHIsMS0uMTI1KX1mdW5jdGlvbiBWKHQsYSl7bGV0IHM9MDtyZXR1cm4gYVszXT09PTEmJihzKz0xKSxzPT09MSYmYVsyXT09PTEmJnRbMV0hPT0xJiZ0WzNdIT09MSYmKHMrPTEpLHN9ZnVuY3Rpb24gJCh0LGEpe2xldCBzPTA7cmV0dXJuIGFbM109PT0xJiZ0WzFdIT09MSYmdFszXSE9PTEmJihzKz0xKSxzPT09MSYmYVsyXT09PTEmJnRbMF0hPT0xJiZ0WzJdIT09MSYmKHMrPTEpLHN9dmFyIEU9Y2xhc3N7c3RhdGljIGdlbmVyYXRlKCl7bGV0IG89bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDIxNzgpLGM9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDY0KjE2KjQpO2ZvcihsZXQgaD0wO2g8MzM7KytoKWZvcihsZXQgaT0wO2k8NjY7KytpKXtsZXQgdz0uMDMxMjUqaSxiPS4wMzEyNSpoO2lmKFAuaGFzKHcpJiZQLmhhcyhiKSl7bGV0IGc9UC5nZXQodyksaz1QLmdldChiKSxtPWgqNjYraTtvW21dPTEyNypWKGcsayksb1ttKzMzXT0xMjcqJChnLGspfX1mb3IobGV0IGg9MCxpPTE3O2k8MzM7KytpKWZvcihsZXQgdz0wO3c8NjQ7Kyt3LGgrPTQpY1toXT1vW2kqNjYrd10sY1toKzNdPTI1NTtyZXR1cm4gbmV3IEYoNjQsMTYsYyl9fTtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdD0+e2xldCBhPVMuZ2VuZXJhdGUoKSxzPUUuZ2VuZXJhdGUoKTtwb3N0TWVzc2FnZSh7YXJlYUltYWdlRGF0YTphLHNlYXJjaEltYWdlRGF0YTpzfSxbYS5kYXRhLmJ1ZmZlcixzLmRhdGEuYnVmZmVyXSksY2xvc2UoKX0pO30pKCk7XFxuJztcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvU01BQUltYWdlR2VuZXJhdG9yLmpzXG5mdW5jdGlvbiBnZW5lcmF0ZSh1c2VDYWNoZSA9IHRydWUpIHtcbiAgY29uc3Qgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd29ya2VyX2RlZmF1bHQyXSwge1xuICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgfSkpO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG4gIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVVJMKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4gcmVqZWN0KGV2ZW50LmVycm9yKSk7XG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoSW1hZ2VEYXRhID0gUmF3SW1hZ2VEYXRhLmZyb20oZXZlbnQuZGF0YS5zZWFyY2hJbWFnZURhdGEpO1xuICAgICAgY29uc3QgYXJlYUltYWdlRGF0YSA9IFJhd0ltYWdlRGF0YS5mcm9tKGV2ZW50LmRhdGEuYXJlYUltYWdlRGF0YSk7XG4gICAgICBjb25zdCB1cmxzID0gW1xuICAgICAgICBzZWFyY2hJbWFnZURhdGEudG9DYW52YXMoKS50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIiwgMSksXG4gICAgICAgIGFyZWFJbWFnZURhdGEudG9DYW52YXMoKS50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIiwgMSlcbiAgICAgIF07XG4gICAgICBpZiAodXNlQ2FjaGUpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzbWFhLXNlYXJjaFwiLCB1cmxzWzBdKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzbWFhLWFyZWFcIiwgdXJsc1sxXSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHVybHMpO1xuICAgIH0pO1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZShudWxsKTtcbiAgfSk7XG59XG52YXIgU01BQUltYWdlR2VuZXJhdG9yID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIGltYWdlIGdlbmVyYXRvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGlzYWJsZUNhY2hlID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgY2FjaGluZyB2aWEgbG9jYWxTdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgY2FjaGUgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRDYWNoZUVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmRpc2FibGVDYWNoZSA9ICF2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBTTUFBIGRhdGEgaW1hZ2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBTTUFBSW1hZ2VHZW5lcmF0b3IuZ2VuZXJhdGUoKS50aGVuKChbc2VhcmNoLCBhcmVhXSkgPT4ge1xuICAgKiAgIGNvbnN0IHNtYWFFZmZlY3QgPSBuZXcgU01BQUVmZmVjdChzZWFyY2gsIGFyZWEpO1xuICAgKiB9KTtcbiAgICogQHJldHVybiB7UHJvbWlzZTxJbWFnZVtdPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgc2VhcmNoIGltYWdlIGFuZCBhcmVhIGltYWdlIGFzIGEgcGFpci5cbiAgICovXG4gIGdlbmVyYXRlKCkge1xuICAgIGNvbnN0IHVzZUNhY2hlID0gIXRoaXMuZGlzYWJsZUNhY2hlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09IHZvaWQgMDtcbiAgICBjb25zdCBjYWNoZWRVUkxzID0gdXNlQ2FjaGUgPyBbXG4gICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNtYWEtc2VhcmNoXCIpLFxuICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzbWFhLWFyZWFcIilcbiAgICBdIDogW251bGwsIG51bGxdO1xuICAgIGNvbnN0IHByb21pc2UgPSBjYWNoZWRVUkxzWzBdICE9PSBudWxsICYmIGNhY2hlZFVSTHNbMV0gIT09IG51bGwgPyBQcm9taXNlLnJlc29sdmUoY2FjaGVkVVJMcykgOiBnZW5lcmF0ZSh1c2VDYWNoZSk7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbigodXJscykgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc2VhcmNoSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgYXJlYUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcbiAgICAgICAgbWFuYWdlci5vbkxvYWQgPSAoKSA9PiByZXNvbHZlKFtzZWFyY2hJbWFnZSwgYXJlYUltYWdlXSk7XG4gICAgICAgIG1hbmFnZXIub25FcnJvciA9IHJlamVjdDtcbiAgICAgICAgc2VhcmNoSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiBtYW5hZ2VyLml0ZW1FcnJvcihcInNtYWEtc2VhcmNoXCIpKTtcbiAgICAgICAgYXJlYUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZSkgPT4gbWFuYWdlci5pdGVtRXJyb3IoXCJzbWFhLWFyZWFcIikpO1xuICAgICAgICBzZWFyY2hJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBtYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLXNlYXJjaFwiKSk7XG4gICAgICAgIGFyZWFJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBtYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLWFyZWFcIikpO1xuICAgICAgICBtYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgICBtYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtYXJlYVwiKTtcbiAgICAgICAgc2VhcmNoSW1hZ2Uuc3JjID0gdXJsc1swXTtcbiAgICAgICAgYXJlYUltYWdlLnNyYyA9IHVybHNbMV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvU01BQVNlYXJjaEltYWdlRGF0YS5qc1xudmFyIGVkZ2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbYmlsaW5lYXIoMCwgMCwgMCwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDBdKV0sXG4gIFtiaWxpbmVhcigwLCAwLCAwLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMV0pXSxcbiAgW2JpbGluZWFyKDAsIDAsIDEsIDApLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwXSldLFxuICBbYmlsaW5lYXIoMCwgMCwgMSwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDFdKV0sXG4gIFtiaWxpbmVhcigwLCAxLCAwLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMCwgMF0pXSxcbiAgW2JpbGluZWFyKDAsIDEsIDAsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwLCAxXSldLFxuICBbYmlsaW5lYXIoMCwgMSwgMSwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDEsIDBdKV0sXG4gIFtiaWxpbmVhcigwLCAxLCAxLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMV0pXSxcbiAgW2JpbGluZWFyKDEsIDAsIDAsIDApLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwXSldLFxuICBbYmlsaW5lYXIoMSwgMCwgMCwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDFdKV0sXG4gIFtiaWxpbmVhcigxLCAwLCAxLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMSwgMF0pXSxcbiAgW2JpbGluZWFyKDEsIDAsIDEsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAxLCAxXSldLFxuICBbYmlsaW5lYXIoMSwgMSwgMCwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDAsIDBdKV0sXG4gIFtiaWxpbmVhcigxLCAxLCAwLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMCwgMV0pXSxcbiAgW2JpbGluZWFyKDEsIDEsIDEsIDApLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAwXSldLFxuICBbYmlsaW5lYXIoMSwgMSwgMSwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKV1cbl0pO1xuZnVuY3Rpb24gbGVycDIoYSwgYiwgcCkge1xuICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xufVxuZnVuY3Rpb24gYmlsaW5lYXIoZTAsIGUxLCBlMiwgZTMpIHtcbiAgY29uc3QgYSA9IGxlcnAyKGUwLCBlMSwgMSAtIDAuMjUpO1xuICBjb25zdCBiID0gbGVycDIoZTIsIGUzLCAxIC0gMC4yNSk7XG4gIHJldHVybiBsZXJwMihhLCBiLCAxIC0gMC4xMjUpO1xufVxuZnVuY3Rpb24gZGVsdGFMZWZ0KGxlZnQsIHRvcCkge1xuICBsZXQgZCA9IDA7XG4gIGlmICh0b3BbM10gPT09IDEpIHtcbiAgICBkICs9IDE7XG4gIH1cbiAgaWYgKGQgPT09IDEgJiYgdG9wWzJdID09PSAxICYmIGxlZnRbMV0gIT09IDEgJiYgbGVmdFszXSAhPT0gMSkge1xuICAgIGQgKz0gMTtcbiAgfVxuICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIGRlbHRhUmlnaHQobGVmdCwgdG9wKSB7XG4gIGxldCBkID0gMDtcbiAgaWYgKHRvcFszXSA9PT0gMSAmJiBsZWZ0WzFdICE9PSAxICYmIGxlZnRbM10gIT09IDEpIHtcbiAgICBkICs9IDE7XG4gIH1cbiAgaWYgKGQgPT09IDEgJiYgdG9wWzJdID09PSAxICYmIGxlZnRbMF0gIT09IDEgJiYgbGVmdFsyXSAhPT0gMSkge1xuICAgIGQgKz0gMTtcbiAgfVxuICByZXR1cm4gZDtcbn1cbnZhciBTTUFBU2VhcmNoSW1hZ2VEYXRhID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzZWFyY2ggaW1hZ2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1Jhd0ltYWdlRGF0YX0gVGhlIGdlbmVyYXRlZCBpbWFnZSBkYXRhLlxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIGNvbnN0IHdpZHRoID0gNjY7XG4gICAgY29uc3QgaGVpZ2h0ID0gMzM7XG4gICAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGNyb3BwZWRXaWR0aCA9IDY0O1xuICAgIGNvbnN0IGNyb3BwZWRIZWlnaHQgPSAxNjtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICBjb25zdCBjcm9wcGVkRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShjcm9wcGVkV2lkdGggKiBjcm9wcGVkSGVpZ2h0ICogNCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgIGNvbnN0IHMgPSAwLjAzMTI1ICogeDtcbiAgICAgICAgY29uc3QgdCA9IDAuMDMxMjUgKiB5O1xuICAgICAgICBpZiAoZWRnZXMuaGFzKHMpICYmIGVkZ2VzLmhhcyh0KSkge1xuICAgICAgICAgIGNvbnN0IGUxID0gZWRnZXMuZ2V0KHMpO1xuICAgICAgICAgIGNvbnN0IGUyID0gZWRnZXMuZ2V0KHQpO1xuICAgICAgICAgIGNvbnN0IGkgPSB5ICogd2lkdGggKyB4O1xuICAgICAgICAgIGRhdGFbaV0gPSAxMjcgKiBkZWx0YUxlZnQoZTEsIGUyKTtcbiAgICAgICAgICBkYXRhW2kgKyBoYWxmV2lkdGhdID0gMTI3ICogZGVsdGFSaWdodChlMSwgZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCB5ID0gaGVpZ2h0IC0gY3JvcHBlZEhlaWdodDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNyb3BwZWRXaWR0aDsgKyt4LCBpICs9IDQpIHtcbiAgICAgICAgY3JvcHBlZERhdGFbaV0gPSBkYXRhW3kgKiB3aWR0aCArIHhdO1xuICAgICAgICBjcm9wcGVkRGF0YVtpICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmF3SW1hZ2VEYXRhKGNyb3BwZWRXaWR0aCwgY3JvcHBlZEhlaWdodCwgY3JvcHBlZERhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvdGV4dHVyZXMvTm9pc2VUZXh0dXJlLmpzXG5pbXBvcnQge1xuICBEYXRhVGV4dHVyZSBhcyBEYXRhVGV4dHVyZTIsXG4gIEx1bWluYW5jZUZvcm1hdCxcbiAgUmVkRm9ybWF0LFxuICBSR0Zvcm1hdCxcbiAgUkdCQUZvcm1hdCBhcyBSR0JBRm9ybWF0MixcbiAgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTRcbn0gZnJvbSBcInRocmVlXCI7XG5mdW5jdGlvbiBnZXROb2lzZShzaXplLCBmb3JtYXQsIHR5cGUpIHtcbiAgY29uc3QgY2hhbm5lbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgW0x1bWluYW5jZUZvcm1hdCwgMV0sXG4gICAgW1JlZEZvcm1hdCwgMV0sXG4gICAgW1JHRm9ybWF0LCAyXSxcbiAgICBbUkdCQUZvcm1hdDIsIDRdXG4gIF0pO1xuICBsZXQgZGF0YTtcbiAgaWYgKCFjaGFubmVscy5oYXMoZm9ybWF0KSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG5vaXNlIHRleHR1cmUgZm9ybWF0XCIpO1xuICB9XG4gIGlmICh0eXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlMTQpIHtcbiAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIGNoYW5uZWxzLmdldChmb3JtYXQpKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gTWF0aC5yYW5kb20oKSAqIDI1NSArIDAuNTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIGNoYW5uZWxzLmdldChmb3JtYXQpKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gTWF0aC5yYW5kb20oKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG52YXIgTm9pc2VUZXh0dXJlID0gY2xhc3MgZXh0ZW5kcyBEYXRhVGV4dHVyZTIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBub2lzZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBUaGUgdGV4dHVyZSBmb3JtYXQgY2FuIGJlIGVpdGhlciBgTHVtaW5hbmNlRm9ybWF0YCBvciBgUkdCQUZvcm1hdGAuIEFkZGl0aW9uYWxseSwgdGhlIGZvcm1hdHMgYFJlZEZvcm1hdGAgYW5kXG4gICAqIGBSR0Zvcm1hdGAgY2FuIGJlIHVzZWQgaW4gYSBXZWJHTCAyIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZm9ybWF0PUx1bWluYW5jZUZvcm1hdF0gLSBUaGUgdGV4dHVyZSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdHlwZT1VbnNpZ25lZEJ5dGVUeXBlXSAtIFRoZSB0ZXh0dXJlIHR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBmb3JtYXQgPSBMdW1pbmFuY2VGb3JtYXQsIHR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlMTQpIHtcbiAgICBzdXBlcihnZXROb2lzZSh3aWR0aCAqIGhlaWdodCwgZm9ybWF0LCB0eXBlKSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9nbGl0Y2guZnJhZ1xudmFyIGdsaXRjaF9kZWZhdWx0ID0gXCJ1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHBlcnR1cmJhdGlvbk1hcDt1bmlmb3JtIGJvb2wgYWN0aXZlO3VuaWZvcm0gZmxvYXQgY29sdW1uczt1bmlmb3JtIGZsb2F0IHJhbmRvbTt1bmlmb3JtIHZlYzIgc2VlZHM7dW5pZm9ybSB2ZWMyIGRpc3RvcnRpb247dm9pZCBtYWluVXYoaW5vdXQgdmVjMiB1dil7aWYoYWN0aXZlKXtpZih1di55PGRpc3RvcnRpb24ueCtjb2x1bW5zJiZ1di55PmRpc3RvcnRpb24ueC1jb2x1bW5zKnJhbmRvbSl7ZmxvYXQgc3g9Y2xhbXAoY2VpbChzZWVkcy54KSwwLjAsMS4wKTt1di55PXN4KigxLjAtKHV2LnkrZGlzdG9ydGlvbi55KSkrKDEuMC1zeCkqZGlzdG9ydGlvbi55O31pZih1di54PGRpc3RvcnRpb24ueStjb2x1bW5zJiZ1di54PmRpc3RvcnRpb24ueS1jb2x1bW5zKnJhbmRvbSl7ZmxvYXQgc3k9Y2xhbXAoY2VpbChzZWVkcy55KSwwLjAsMS4wKTt1di54PXN5KmRpc3RvcnRpb24ueCsoMS4wLXN5KSooMS4wLSh1di54K2Rpc3RvcnRpb24ueCkpO312ZWMyIG5vcm1hbD10ZXh0dXJlMkQocGVydHVyYmF0aW9uTWFwLHV2KnJhbmRvbSpyYW5kb20pLnJnO3V2Kz1ub3JtYWwqc2VlZHMqKHJhbmRvbSowLjIpO319XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0dsaXRjaEVmZmVjdC5qc1xudmFyIHRleHR1cmVUYWcgPSBcIkdsaXRjaC5HZW5lcmF0ZWRcIjtcbmZ1bmN0aW9uIHJhbmRvbUZsb2F0KGxvdywgaGlnaCkge1xuICByZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KTtcbn1cbnZhciBHbGl0Y2hFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGdsaXRjaCBlZmZlY3QuXG4gICAqXG4gICAqIFRPRE8gQ2hhbmdlIHJhdGlvIHRvIDAuMTUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5jaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0XSAtIEEgY2hyb21hdGljIGFiZXJyYXRpb24gb2Zmc2V0LiBJZiBwcm92aWRlZCwgdGhlIGdsaXRjaCBlZmZlY3Qgd2lsbCBpbmZsdWVuY2UgdGhpcyBvZmZzZXQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMuZGVsYXldIC0gVGhlIG1pbmltdW0gYW5kIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5kdXJhdGlvbl0gLSBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBkdXJhdGlvbiBvZiBhIGdsaXRjaCBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLnN0cmVuZ3RoXSAtIFRoZSBzdHJlbmd0aCBvZiB3ZWFrIGFuZCBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMucGVydHVyYmF0aW9uTWFwXSAtIEEgcGVydHVyYmF0aW9uIG1hcC4gSWYgbm9uZSBpcyBwcm92aWRlZCwgYSBub2lzZSB0ZXh0dXJlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR0U2l6ZT02NF0gLSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIG5vaXNlIG1hcC4gV2lsbCBiZSBpZ25vcmVkIGlmIGEgcGVydHVyYmF0aW9uIG1hcCBpcyBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbHVtbnM9MC4wNV0gLSBUaGUgc2NhbGUgb2YgdGhlIGJsb2NreSBnbGl0Y2ggY29sdW1ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhdGlvPTAuODVdIC0gVGhlIHRocmVzaG9sZCBmb3Igc3Ryb25nIGdsaXRjaGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSBudWxsLFxuICAgIGRlbGF5ID0gbmV3IFZlY3RvcjIyMCgxLjUsIDMuNSksXG4gICAgZHVyYXRpb24gPSBuZXcgVmVjdG9yMjIwKDAuNiwgMSksXG4gICAgc3RyZW5ndGggPSBuZXcgVmVjdG9yMjIwKDAuMywgMSksXG4gICAgY29sdW1ucyA9IDAuMDUsXG4gICAgcmF0aW8gPSAwLjg1LFxuICAgIHBlcnR1cmJhdGlvbk1hcCA9IG51bGwsXG4gICAgZHRTaXplID0gNjRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJHbGl0Y2hFZmZlY3RcIiwgZ2xpdGNoX2RlZmF1bHQsIHtcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcInBlcnR1cmJhdGlvbk1hcFwiLCBuZXcgVW5pZm9ybTMyKG51bGwpXSxcbiAgICAgICAgW1wiY29sdW1uc1wiLCBuZXcgVW5pZm9ybTMyKGNvbHVtbnMpXSxcbiAgICAgICAgW1wiYWN0aXZlXCIsIG5ldyBVbmlmb3JtMzIoZmFsc2UpXSxcbiAgICAgICAgW1wicmFuZG9tXCIsIG5ldyBVbmlmb3JtMzIoMSldLFxuICAgICAgICBbXCJzZWVkc1wiLCBuZXcgVW5pZm9ybTMyKG5ldyBWZWN0b3IyMjAoKSldLFxuICAgICAgICBbXCJkaXN0b3J0aW9uXCIsIG5ldyBVbmlmb3JtMzIobmV3IFZlY3RvcjIyMCgpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgaWYgKHBlcnR1cmJhdGlvbk1hcCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE5vaXNlVGV4dHVyZShkdFNpemUsIGR0U2l6ZSwgUkdCQUZvcm1hdDMpO1xuICAgICAgbWFwLm5hbWUgPSB0ZXh0dXJlVGFnO1xuICAgICAgdGhpcy5wZXJ0dXJiYXRpb25NYXAgPSBtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVydHVyYmF0aW9uTWFwID0gcGVydHVyYmF0aW9uTWFwO1xuICAgIH1cbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuZGlzdG9ydGlvbiA9IHRoaXMudW5pZm9ybXMuZ2V0KFwiZGlzdG9ydGlvblwiKS52YWx1ZTtcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuYnJlYWtQb2ludCA9IG5ldyBWZWN0b3IyMjAoXG4gICAgICByYW5kb21GbG9hdCh0aGlzLmRlbGF5LngsIHRoaXMuZGVsYXkueSksXG4gICAgICByYW5kb21GbG9hdCh0aGlzLmR1cmF0aW9uLngsIHRoaXMuZHVyYXRpb24ueSlcbiAgICApO1xuICAgIHRoaXMuc3RyZW5ndGggPSBzdHJlbmd0aDtcbiAgICB0aGlzLm1vZGUgPSBHbGl0Y2hNb2RlLlNQT1JBRElDO1xuICAgIHRoaXMucmF0aW8gPSByYXRpbztcbiAgICB0aGlzLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSBjaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0O1xuICB9XG4gIC8qKlxuICAgKiBSYW5kb20gbnVtYmVyIHNlZWRzLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBzZWVkcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzZWVkc1wiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdsaXRjaCBlZmZlY3QgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImFjdGl2ZVwiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdsaXRjaCBlZmZlY3QgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFjdGl2ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBnbGl0Y2ggZWZmZWN0IGlzIGFjdGl2ZS5cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluRGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueDtcbiAgfVxuICBzZXQgbWluRGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkRlbGF5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gZGVsYXkgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1pbkRlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGF5Lng7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5EZWxheSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWluRGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4RGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueTtcbiAgfVxuICBzZXQgbWF4RGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlbGF5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gZGVsYXkgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1heERlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGF5Lnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZWxheSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWF4RGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueDtcbiAgfVxuICBzZXQgbWluRHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1pbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uLng7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5EdXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWluRHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueTtcbiAgfVxuICBzZXQgbWF4RHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heER1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1heER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uLnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEdXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWF4RHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN0cmVuZ3RoIG9mIHdlYWsgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueDtcbiAgfVxuICBzZXQgbWluU3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2Ygd2VhayBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHN0cmVuZ3RoLlxuICAgKi9cbiAgZ2V0TWluU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RyZW5ndGggb2Ygd2VhayBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzdHJlbmd0aC5cbiAgICovXG4gIHNldE1pblN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5zdHJlbmd0aC54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdHJlbmd0aCBvZiBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4U3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueTtcbiAgfVxuICBzZXQgbWF4U3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2Ygc3Ryb25nIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF4U3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBnZXRNYXhTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC55O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhTdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBzZXRNYXhTdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuc3RyZW5ndGgueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdsaXRjaCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtHbGl0Y2hNb2RlfSBUaGUgbW9kZS5cbiAgICovXG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBnbGl0Y2ggbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtHbGl0Y2hNb2RlfSB2YWx1ZSAtIFRoZSBtb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnbGl0Y2ggcmF0aW8uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByYXRpbyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYXRpby5cbiAgICovXG4gIGdldEdsaXRjaFJhdGlvKCkge1xuICAgIHJldHVybiAxIC0gdGhpcy5yYXRpbztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmF0aW8gb2Ygd2VhayAoMC4wKSBhbmQgc3Ryb25nICgxLjApIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmF0aW8gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJhdGlvLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0R2xpdGNoUmF0aW8odmFsdWUpIHtcbiAgICB0aGlzLnJhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMSAtIHZhbHVlLCAwKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2x1bW5zXCIpLnZhbHVlO1xuICB9XG4gIHNldCBjb2x1bW5zKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2x1bW5zXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdsaXRjaCBjb2x1bW4gc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbHVtbnMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ2xpdGNoIGNvbHVtbiBzaXplLlxuICAgKi9cbiAgZ2V0R2xpdGNoQ29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5zO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2x1bW5zIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqL1xuICBzZXRHbGl0Y2hDb2x1bW5zKHZhbHVlKSB7XG4gICAgdGhpcy5jb2x1bW5zID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNocm9tYXRpYyBhYmVycmF0aW9uIG9mZnNldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIG9mZnNldC5cbiAgICovXG4gIGdldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY2hyb21hdGljIGFiZXJyYXRpb24gb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZhbHVlIC0gVGhlIG9mZnNldC5cbiAgICovXG4gIHNldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHBlcnR1cmJhdGlvbk1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJwZXJ0dXJiYXRpb25NYXBcIikudmFsdWU7XG4gIH1cbiAgc2V0IHBlcnR1cmJhdGlvbk1hcCh2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRNYXAgPSB0aGlzLnBlcnR1cmJhdGlvbk1hcDtcbiAgICBpZiAoY3VycmVudE1hcCAhPT0gbnVsbCAmJiBjdXJyZW50TWFwLm5hbWUgPT09IHRleHR1cmVUYWcpIHtcbiAgICAgIGN1cnJlbnRNYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB2YWx1ZS5taW5GaWx0ZXIgPSB2YWx1ZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyNjtcbiAgICB2YWx1ZS53cmFwUyA9IHZhbHVlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG4gICAgdmFsdWUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJwZXJ0dXJiYXRpb25NYXBcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcGVydHVyYmF0aW9uTWFwIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSBjdXJyZW50IHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqL1xuICBnZXRQZXJ0dXJiYXRpb25NYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVydHVyYmF0aW9uTWFwO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBwZXJ0dXJiYXRpb24gbWFwIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgICpcbiAgICogVGhlIGN1cnJlbnQgbWFwIHdpbGwgYmUgZGlzcG9zZWQgaWYgaXQgd2FzIGdlbmVyYXRlZCBieSB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBlcnR1cmJhdGlvbk1hcCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIG5ldyBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKi9cbiAgc2V0UGVydHVyYmF0aW9uTWFwKHZhbHVlKSB7XG4gICAgdGhpcy5wZXJ0dXJiYXRpb25NYXAgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcGVydHVyYmF0aW9uIG1hcC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIE5vaXNlVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ZhbHVlPTY0XSAtIFRoZSB0ZXh0dXJlIHNpemUuXG4gICAqIEByZXR1cm4ge0RhdGFUZXh0dXJlfSBUaGUgcGVydHVyYmF0aW9uIG1hcC5cbiAgICovXG4gIGdlbmVyYXRlUGVydHVyYmF0aW9uTWFwKHZhbHVlID0gNjQpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTm9pc2VUZXh0dXJlKHZhbHVlLCB2YWx1ZSwgUkdCQUZvcm1hdDMpO1xuICAgIG1hcC5uYW1lID0gdGV4dHVyZVRhZztcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xuICAgIGNvbnN0IGJyZWFrUG9pbnQgPSB0aGlzLmJyZWFrUG9pbnQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0O1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0cmVuZ3RoO1xuICAgIGxldCB0aW1lID0gdGhpcy50aW1lO1xuICAgIGxldCBhY3RpdmUgPSBmYWxzZTtcbiAgICBsZXQgciA9IDAsIGEgPSAwO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChtb2RlICE9PSBHbGl0Y2hNb2RlLkRJU0FCTEVEKSB7XG4gICAgICBpZiAobW9kZSA9PT0gR2xpdGNoTW9kZS5TUE9SQURJQykge1xuICAgICAgICB0aW1lICs9IGRlbHRhVGltZTtcbiAgICAgICAgdHJpZ2dlciA9IHRpbWUgPiBicmVha1BvaW50Lng7XG4gICAgICAgIGlmICh0aW1lID49IGJyZWFrUG9pbnQueCArIGJyZWFrUG9pbnQueSkge1xuICAgICAgICAgIGJyZWFrUG9pbnQuc2V0KFxuICAgICAgICAgICAgcmFuZG9tRmxvYXQodGhpcy5kZWxheS54LCB0aGlzLmRlbGF5LnkpLFxuICAgICAgICAgICAgcmFuZG9tRmxvYXQodGhpcy5kdXJhdGlvbi54LCB0aGlzLmR1cmF0aW9uLnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0aGlzLnVuaWZvcm1zLmdldChcInJhbmRvbVwiKS52YWx1ZSA9IHI7XG4gICAgICBpZiAodHJpZ2dlciAmJiByID4gdGhpcy5yYXRpbyB8fCBtb2RlID09PSBHbGl0Y2hNb2RlLkNPTlNUQU5UX1dJTEQpIHtcbiAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgciAqPSBzLnkgKiAwLjAzO1xuICAgICAgICBhID0gcmFuZG9tRmxvYXQoLU1hdGguUEksIE1hdGguUEkpO1xuICAgICAgICB0aGlzLnNlZWRzLnNldChyYW5kb21GbG9hdCgtcy55LCBzLnkpLCByYW5kb21GbG9hdCgtcy55LCBzLnkpKTtcbiAgICAgICAgdGhpcy5kaXN0b3J0aW9uLnNldChyYW5kb21GbG9hdCgwLCAxKSwgcmFuZG9tRmxvYXQoMCwgMSkpO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyIHx8IG1vZGUgPT09IEdsaXRjaE1vZGUuQ09OU1RBTlRfTUlMRCkge1xuICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICByICo9IHMueCAqIDAuMDM7XG4gICAgICAgIGEgPSByYW5kb21GbG9hdCgtTWF0aC5QSSwgTWF0aC5QSSk7XG4gICAgICAgIHRoaXMuc2VlZHMuc2V0KHJhbmRvbUZsb2F0KC1zLngsIHMueCksIHJhbmRvbUZsb2F0KC1zLngsIHMueCkpO1xuICAgICAgICB0aGlzLmRpc3RvcnRpb24uc2V0KHJhbmRvbUZsb2F0KDAsIDEpLCByYW5kb21GbG9hdCgwLCAxKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIG9mZnNldC5zZXQoTWF0aC5jb3MoYSksIE1hdGguc2luKGEpKS5tdWx0aXBseVNjYWxhcihyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldC5zZXQoMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYWN0aXZlXCIpLnZhbHVlID0gYWN0aXZlO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGdlbmVyYXRlZCByZXNvdXJjZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMucGVydHVyYmF0aW9uTWFwO1xuICAgIGlmIChtYXAgIT09IG51bGwgJiYgbWFwLm5hbWUgPT09IHRleHR1cmVUYWcpIHtcbiAgICAgIG1hcC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9Hb2RSYXlzRWZmZWN0LmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE1LFxuICBDb2xvciBhcyBDb2xvcjUsXG4gIERlcHRoVGV4dHVyZSBhcyBEZXB0aFRleHR1cmUyLFxuICBNYXRyaXg0IGFzIE1hdHJpeDQyLFxuICBTY2VuZSBhcyBTY2VuZTIsXG4gIFVuaWZvcm0gYXMgVW5pZm9ybTMzLFxuICBWZWN0b3IyIGFzIFZlY3RvcjIyMSxcbiAgVmVjdG9yMyBhcyBWZWN0b3IzMixcbiAgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxN1xufSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9nb2QtcmF5cy5mcmFnXG52YXIgZ29kX3JheXNfZGVmYXVsdCA9IFwiI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBtYXA7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9dGV4dHVyZTJEKG1hcCx1dik7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9Hb2RSYXlzRWZmZWN0LmpzXG52YXIgdiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMzIoKTtcbnZhciBtID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0MigpO1xudmFyIEdvZFJheXNFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGdvZCByYXlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IFtjYW1lcmFdIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge01lc2h8UG9pbnRzfSBbbGlnaHRTb3VyY2VdIC0gVGhlIGxpZ2h0IHNvdXJjZS4gTXVzdCBub3Qgd3JpdGUgZGVwdGggYW5kIGhhcyB0byBiZSBmbGFnZ2VkIGFzIHRyYW5zcGFyZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNDUkVFTl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzPTYwLjBdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbnNpdHk9MC45Nl0gLSBUaGUgZGVuc2l0eSBvZiB0aGUgbGlnaHQgcmF5cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlY2F5PTAuOV0gLSBBbiBpbGx1bWluYXRpb24gZGVjYXkgZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2VpZ2h0PTAuNF0gLSBBIGxpZ2h0IHJheSB3ZWlnaHQgZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZXhwb3N1cmU9MC42XSAtIEEgY29uc3RhbnQgYXR0ZW51YXRpb24gY29lZmZpY2llbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGFtcE1heD0xLjBdIC0gQW4gdXBwZXIgYm91bmQgZm9yIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBvdmVyYWxsIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuU01BTExdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuIEhhcyBubyBlZmZlY3QgaWYgYmx1ciBpcyBkaXNhYmxlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibHVyPXRydWVdIC0gV2hldGhlciB0aGUgZ29kIHJheXMgc2hvdWxkIGJlIGJsdXJyZWQgdG8gcmVkdWNlIGFydGlmYWN0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSwgbGlnaHRTb3VyY2UsIHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sXG4gICAgc2FtcGxlcyA9IDYwLFxuICAgIGRlbnNpdHkgPSAwLjk2LFxuICAgIGRlY2F5ID0gMC45LFxuICAgIHdlaWdodCA9IDAuNCxcbiAgICBleHBvc3VyZSA9IDAuNixcbiAgICBjbGFtcE1heCA9IDEsXG4gICAgYmx1ciA9IHRydWUsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuU01BTEwsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdvZFJheXNFZmZlY3RcIiwgZ29kX3JheXNfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTMzKG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLl9saWdodFNvdXJjZSA9IGxpZ2h0U291cmNlO1xuICAgIHRoaXMubGlnaHRTb3VyY2UgPSBsaWdodFNvdXJjZTtcbiAgICB0aGlzLmxpZ2h0U2NlbmUgPSBuZXcgU2NlbmUyKCk7XG4gICAgdGhpcy5zY3JlZW5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IyMjEoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxNygxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRBLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiR29kUmF5cy5UYXJnZXQuQlwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE3KDEsIDEpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLkxpZ2h0XCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodC5kZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlMigpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0ID0gbmV3IFJlbmRlclBhc3ModGhpcy5saWdodFNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0LmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3I1KDApO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyh0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjUoMCk7XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBLYXdhc2VCbHVyUGFzcyh7IGtlcm5lbFNpemUgfSk7XG4gICAgdGhpcy5ibHVyUGFzcy5lbmFibGVkID0gYmx1cjtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgRGVwdGhNYXNrTWF0ZXJpYWwoKSk7XG4gICAgY29uc3QgZGVwdGhNYXNrTWF0ZXJpYWwgPSB0aGlzLmRlcHRoTWFza01hdGVyaWFsO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmRlcHRoQnVmZmVyMSA9IHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQuZGVwdGhUZXh0dXJlO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICAgIHRoaXMuZ29kUmF5c1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgR29kUmF5c01hdGVyaWFsKHRoaXMuc2NyZWVuUG9zaXRpb24pKTtcbiAgICBjb25zdCBnb2RSYXlzTWF0ZXJpYWwgPSB0aGlzLmdvZFJheXNNYXRlcmlhbDtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuZGVuc2l0eSA9IGRlbnNpdHk7XG4gICAgZ29kUmF5c01hdGVyaWFsLmRlY2F5ID0gZGVjYXk7XG4gICAgZ29kUmF5c01hdGVyaWFsLndlaWdodCA9IHdlaWdodDtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuZXhwb3N1cmUgPSBleHBvc3VyZTtcbiAgICBnb2RSYXlzTWF0ZXJpYWwubWF4SW50ZW5zaXR5ID0gY2xhbXBNYXg7XG4gICAgZ29kUmF5c01hdGVyaWFsLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLnJlbmRlclBhc3NMaWdodC5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEB0eXBlIHtNZXNofFBvaW50c31cbiAgICovXG4gIGdldCBsaWdodFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlnaHRTb3VyY2U7XG4gIH1cbiAgc2V0IGxpZ2h0U291cmNlKHZhbHVlKSB7XG4gICAgdGhpcy5fbGlnaHRTb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICAgIHZhbHVlLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcyB0aGF0IHJlZHVjZXMgYWxpYXNpbmcgYXJ0aWZhY3RzIGFuZCBtYWtlcyB0aGUgbGlnaHQgc29mdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIGludGVybWVkaWF0ZSByZXN1bHQgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnb2QgcmF5cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aE1hc2tNYXRlcmlhbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkZXB0aE1hc2tNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aE1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGludGVybmFsIGdvZCByYXlzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7R29kUmF5c01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGdvZFJheXNNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdvZCByYXlzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ29kUmF5c01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0dvZFJheXNNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0R29kUmF5c01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmdvZFJheXNNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7R29kUmF5c01hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ud2lkdGggaW5zdGVhZC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5oZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzTWF0ZXJpYWwuZGl0aGVyaW5nO1xuICB9XG4gIHNldCBkaXRoZXJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZ29kUmF5c01hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmRpdGhlcmluZyA9IHZhbHVlO1xuICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdvZCByYXlzIHNob3VsZCBiZSBibHVycmVkIHRvIHJlZHVjZSBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MuZW5hYmxlZDtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0tlcm5lbFNpemV9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyUGFzcy5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdvZFJheXNNYXRlcmlhbC5zYW1wbGVzIGluc3RlYWQuXG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzTWF0ZXJpYWwuc2FtcGxlcztcbiAgfVxuICAvKipcbiAgICogQSBoaWdoZXIgc2FtcGxlIGNvdW50IGltcHJvdmVzIHF1YWxpdHkgYXQgdGhlIGNvc3Qgb2YgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBnb2RSYXlzTWF0ZXJpYWwuc2FtcGxlcyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLmdvZFJheXNNYXRlcmlhbC5zYW1wbGVzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTUpIHtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoQnVmZmVyMCA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoUGFja2luZzAgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGNvbnN0IGxpZ2h0U291cmNlID0gdGhpcy5saWdodFNvdXJjZTtcbiAgICBjb25zdCBwYXJlbnQgPSBsaWdodFNvdXJjZS5wYXJlbnQ7XG4gICAgY29uc3QgbWF0cml4QXV0b1VwZGF0ZSA9IGxpZ2h0U291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QSA9IHRoaXMucmVuZGVyVGFyZ2V0QTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRMaWdodCA9IHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQ7XG4gICAgbGlnaHRTb3VyY2UubWF0ZXJpYWwuZGVwdGhXcml0ZSA9IHRydWU7XG4gICAgbGlnaHRTb3VyY2UubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIGxpZ2h0U291cmNlLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoIW1hdHJpeEF1dG9VcGRhdGUpIHtcbiAgICAgICAgbS5jb3B5KGxpZ2h0U291cmNlLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBsaWdodFNvdXJjZS5tYXRyaXguY29weShsaWdodFNvdXJjZS5tYXRyaXhXb3JsZCk7XG4gICAgfVxuICAgIHRoaXMubGlnaHRTY2VuZS5hZGQobGlnaHRTb3VyY2UpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0LnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0TGlnaHQpO1xuICAgIHRoaXMuY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0QSk7XG4gICAgdGhpcy5kZXB0aE1hc2tQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0TGlnaHQsIHJlbmRlclRhcmdldEEpO1xuICAgIGxpZ2h0U291cmNlLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICBsaWdodFNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlID0gbWF0cml4QXV0b1VwZGF0ZTtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoIW1hdHJpeEF1dG9VcGRhdGUpIHtcbiAgICAgICAgbGlnaHRTb3VyY2UubWF0cml4LmNvcHkobSk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuYWRkKGxpZ2h0U291cmNlKTtcbiAgICB9XG4gICAgdi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHRTb3VyY2UubWF0cml4V29ybGQpLnByb2plY3QodGhpcy5jYW1lcmEpO1xuICAgIHRoaXMuc2NyZWVuUG9zaXRpb24uc2V0KFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgoKHYueCArIDEpICogMC41LCAtMSksIDIpLFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgoKHYueSArIDEpICogMC41LCAtMSksIDIpXG4gICAgKTtcbiAgICBpZiAodGhpcy5ibHVyUGFzcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0QSwgcmVuZGVyVGFyZ2V0QSk7XG4gICAgfVxuICAgIHRoaXMuZ29kUmF5c1Bhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRBLCB0aGlzLnJlbmRlclRhcmdldEIpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodC5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbi5jb3B5KHJlc29sdXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0LmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmdvZFJheXNQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0LnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRMaWdodC50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9HcmlkRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0zNCwgVmVjdG9yMiBhcyBWZWN0b3IyMjIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9ncmlkLmZyYWdcbnZhciBncmlkX2RlZmF1bHQgPSBcInVuaWZvcm0gdmVjMiBzY2FsZTt1bmlmb3JtIGZsb2F0IGxpbmVXaWR0aDt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7ZmxvYXQgZ3JpZD0wLjUtbWF4KGFicyhtb2QodXYueCpzY2FsZS54LDEuMCktMC41KSxhYnMobW9kKHV2Lnkqc2NhbGUueSwxLjApLTAuNSkpO291dHB1dENvbG9yPXZlYzQodmVjMyhzbW9vdGhzdGVwKDAuMCxsaW5lV2lkdGgsZ3JpZCkpLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9HcmlkRWZmZWN0LmpzXG52YXIgR3JpZEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ3JpZCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uT1ZFUkxBWV0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZT0xLjBdIC0gVGhlIHNjYWxlIG9mIHRoZSBncmlkIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW5lV2lkdGg9MC4wXSAtIFRoZSBsaW5lIHdpZHRoIG9mIHRoZSBncmlkIHBhdHRlcm4uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLk9WRVJMQVksIHNjYWxlID0gMSwgbGluZVdpZHRoID0gMCB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdyaWRFZmZlY3RcIiwgZ3JpZF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm0zNChuZXcgVmVjdG9yMjIyKCkpXSxcbiAgICAgICAgW1wibGluZVdpZHRoXCIsIG5ldyBVbmlmb3JtMzQobGluZVdpZHRoKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIyMigpO1xuICAgIHRoaXMucyA9IDA7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMubCA9IDA7XG4gICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMucyA9IE1hdGgubWF4KHZhbHVlLCAxZS02KTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBncmlkIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ3JpZCBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBncmlkIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBncmlkIHNjYWxlLlxuICAgKi9cbiAgc2V0U2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsaW5lIHdpZHRoLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxpbmVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5sO1xuICB9XG4gIHNldCBsaW5lV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLmwgPSB2YWx1ZTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBncmlkIGxpbmUgd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaW5lV2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKi9cbiAgZ2V0TGluZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVXaWR0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbGluZVdpZHRoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKi9cbiAgc2V0TGluZVdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5saW5lV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZSAqIChoZWlnaHQgKiAwLjEyNSk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZS5zZXQoYXNwZWN0ICogc2NhbGUsIHNjYWxlKTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImxpbmVXaWR0aFwiKS52YWx1ZSA9IHNjYWxlIC8gaGVpZ2h0ICsgdGhpcy5saW5lV2lkdGg7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0h1ZVNhdHVyYXRpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTM1LCBWZWN0b3IzIGFzIFZlY3RvcjMzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvaHVlLXNhdHVyYXRpb24uZnJhZ1xudmFyIGh1ZV9zYXR1cmF0aW9uX2RlZmF1bHQgPSBcInVuaWZvcm0gdmVjMyBodWU7dW5pZm9ybSBmbG9hdCBzYXR1cmF0aW9uO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIGNvbG9yPXZlYzMoZG90KGlucHV0Q29sb3IucmdiLGh1ZS54eXopLGRvdChpbnB1dENvbG9yLnJnYixodWUuenh5KSxkb3QoaW5wdXRDb2xvci5yZ2IsaHVlLnl6eCkpO2Zsb2F0IGF2ZXJhZ2U9KGNvbG9yLnIrY29sb3IuZytjb2xvci5iKS8zLjA7dmVjMyBkaWZmPWF2ZXJhZ2UtY29sb3I7aWYoc2F0dXJhdGlvbj4wLjApe2NvbG9yKz1kaWZmKigxLjAtMS4wLygxLjAwMS1zYXR1cmF0aW9uKSk7fWVsc2V7Y29sb3IrPWRpZmYqLXNhdHVyYXRpb247fW91dHB1dENvbG9yPXZlYzQobWluKGNvbG9yLDEuMCksaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0h1ZVNhdHVyYXRpb25FZmZlY3QuanNcbnZhciBIdWVTYXR1cmF0aW9uRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBodWUvc2F0dXJhdGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmh1ZT0wLjBdIC0gVGhlIGh1ZSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2F0dXJhdGlvbj0wLjBdIC0gVGhlIHNhdHVyYXRpb24gZmFjdG9yLCByYW5naW5nIGZyb20gLTEgdG8gMSwgd2hlcmUgMCBtZWFucyBubyBjaGFuZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQywgaHVlID0gMCwgc2F0dXJhdGlvbiA9IDAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJIdWVTYXR1cmF0aW9uRWZmZWN0XCIsIGh1ZV9zYXR1cmF0aW9uX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJodWVcIiwgbmV3IFVuaWZvcm0zNShuZXcgVmVjdG9yMzMoKSldLFxuICAgICAgICBbXCJzYXR1cmF0aW9uXCIsIG5ldyBVbmlmb3JtMzUoc2F0dXJhdGlvbildXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuaHVlID0gaHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2F0dXJhdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzYXR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInNhdHVyYXRpb25cIikudmFsdWU7XG4gIH1cbiAgc2V0IHNhdHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNhdHVyYXRpb25cIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2F0dXJhdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhdHVyYXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2F0dXJhdGlvbi5cbiAgICovXG4gIGdldFNhdHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F0dXJhdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2F0dXJhdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhdHVyYXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNhdHVyYXRpb24uXG4gICAqL1xuICBzZXRTYXR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5zYXR1cmF0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBodWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaHVlKCkge1xuICAgIGNvbnN0IGh1ZSA9IHRoaXMudW5pZm9ybXMuZ2V0KFwiaHVlXCIpLnZhbHVlO1xuICAgIHJldHVybiBNYXRoLmFjb3MoKGh1ZS54ICogMyAtIDEpIC8gMik7XG4gIH1cbiAgc2V0IGh1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSBNYXRoLnNpbih2YWx1ZSksIGMyID0gTWF0aC5jb3ModmFsdWUpO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiaHVlXCIpLnZhbHVlLnNldChcbiAgICAgICgyICogYzIgKyAxKSAvIDMsXG4gICAgICAoLU1hdGguc3FydCgzKSAqIHMgLSBjMiArIDEpIC8gMyxcbiAgICAgIChNYXRoLnNxcnQoMykgKiBzIC0gYzIgKyAxKSAvIDNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBodWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBodWUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgaHVlIGluIHJhZGlhbnMuXG4gICAqL1xuICBnZXRIdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBodWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBodWUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGh1ZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgc2V0SHVlKHZhbHVlKSB7XG4gICAgdGhpcy5odWUgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvTGVuc0Rpc3RvcnRpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTM2LCBWZWN0b3IyIGFzIFZlY3RvcjIyMyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2xlbnMtZGlzdG9ydGlvbi5mcmFnXG52YXIgbGVuc19kaXN0b3J0aW9uX2RlZmF1bHQgPSBcInVuaWZvcm0gdmVjMiBkaXN0b3J0aW9uO3VuaWZvcm0gdmVjMiBwcmluY2lwYWxQb2ludDt1bmlmb3JtIHZlYzIgZm9jYWxMZW5ndGg7dW5pZm9ybSBmbG9hdCBza2V3O2Zsb2F0IG1hc2soY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIGZsb2F0KHV2LnM+PTAuMCYmdXYuczw9MS4wJiZ1di50Pj0wLjAmJnV2LnQ8PTEuMCk7fXZvaWQgbWFpblV2KGlub3V0IHZlYzIgdXYpe3ZlYzIgeG49Mi4wKih1di5zdC0wLjUpO3ZlYzMgeERpc3RvcnRlZD12ZWMzKCgxLjArZGlzdG9ydGlvbipkb3QoeG4seG4pKSp4biwxLjApO21hdDMga2s9bWF0Myh2ZWMzKGZvY2FsTGVuZ3RoLngsMC4wLDAuMCksdmVjMyhza2V3KmZvY2FsTGVuZ3RoLngsZm9jYWxMZW5ndGgueSwwLjApLHZlYzMocHJpbmNpcGFsUG9pbnQueCxwcmluY2lwYWxQb2ludC55LDEuMCkpO3V2PShrayp4RGlzdG9ydGVkKS54eSowLjUrMC41O312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9bWFzayh1dikqaW5wdXRDb2xvcjt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0xlbnNEaXN0b3J0aW9uRWZmZWN0LmpzXG52YXIgTGVuc0Rpc3RvcnRpb25FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGxlbnMgZGlzdG9ydGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5kaXN0b3J0aW9uXSAtIFRoZSBkaXN0b3J0aW9uIHZhbHVlLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLnByaW5jaXBhbFBvaW50XSAtIFRoZSBjZW50ZXIgcG9pbnQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMuZm9jYWxMZW5ndGhdIC0gVGhlIGZvY2FsIGxlbmd0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXc9MF0gLSBUaGUgc2tldyB2YWx1ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXN0b3J0aW9uID0gbmV3IFZlY3RvcjIyMygwLCAwKSxcbiAgICBwcmluY2lwYWxQb2ludCA9IG5ldyBWZWN0b3IyMjMoMCwgMCksXG4gICAgZm9jYWxMZW5ndGggPSBuZXcgVmVjdG9yMjIzKDEsIDEpLFxuICAgIHNrZXcgPSAwXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTGVuc0Rpc3RvcnRpb25FZmZlY3RcIiwgbGVuc19kaXN0b3J0aW9uX2RlZmF1bHQsIHtcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImRpc3RvcnRpb25cIiwgbmV3IFVuaWZvcm0zNihkaXN0b3J0aW9uKV0sXG4gICAgICAgIFtcInByaW5jaXBhbFBvaW50XCIsIG5ldyBVbmlmb3JtMzYocHJpbmNpcGFsUG9pbnQpXSxcbiAgICAgICAgW1wiZm9jYWxMZW5ndGhcIiwgbmV3IFVuaWZvcm0zNihmb2NhbExlbmd0aCldLFxuICAgICAgICBbXCJza2V3XCIsIG5ldyBVbmlmb3JtMzYoc2tldyldXG4gICAgICBdKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmFkaWFsIGRpc3RvcnRpb24gY29lZmZpY2llbnRzLiBEZWZhdWx0IGlzICgwLCAwKS5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXQgZGlzdG9ydGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJkaXN0b3J0aW9uXCIpLnZhbHVlO1xuICB9XG4gIHNldCBkaXN0b3J0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJkaXN0b3J0aW9uXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmluY2lwYWwgcG9pbnQuIERlZmF1bHQgaXMgKDAsIDApLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBwcmluY2lwYWxQb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJwcmluY2lwYWxQb2ludFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgcHJpbmNpcGFsUG9pbnQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInByaW5jaXBhbFBvaW50XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2NhbCBsZW5ndGguIERlZmF1bHQgaXMgKDEsIDEpLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBmb2NhbExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJmb2NhbExlbmd0aFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgZm9jYWxMZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImZvY2FsTGVuZ3RoXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBza2V3IGZhY3RvciBpbiByYWRpYW5zLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNrZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwic2tld1wiKS52YWx1ZTtcbiAgfVxuICBzZXQgc2tldyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwic2tld1wiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9MVVQxREVmZmVjdC5qc1xuaW1wb3J0IHsgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTUsIEhhbGZGbG9hdFR5cGUsIFVuaWZvcm0gYXMgVW5pZm9ybTM3IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbHV0LTFkLmZyYWdcbnZhciBsdXRfMWRfZGVmYXVsdCA9IFwiI2lmZGVmIExVVF9QUkVDSVNJT05fSElHSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGx1dDtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbHV0O1xcbiNlbmRpZlxcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBsdXQ7XFxuI2VuZGlmXFxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPXZlYzQodGV4dHVyZTJEKGx1dCx2ZWMyKGlucHV0Q29sb3IuciwwLjUpKS5yLHRleHR1cmUyRChsdXQsdmVjMihpbnB1dENvbG9yLmcsMC41KSkucix0ZXh0dXJlMkQobHV0LHZlYzIoaW5wdXRDb2xvci5iLDAuNSkpLnIsaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0xVVDFERWZmZWN0LmpzXG52YXIgTFVUMURFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbG9yIGdyYWRpbmcgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGx1dCAtIFRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IobHV0LCB7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQyB9ID0ge30pIHtcbiAgICBzdXBlcihcIkxVVDFERWZmZWN0XCIsIGx1dF8xZF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtbXCJsdXRcIiwgbmV3IFVuaWZvcm0zNyhudWxsKV1dKVxuICAgIH0pO1xuICAgIHRoaXMubHV0ID0gbHV0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTFVULlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBsdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwibHV0XCIpLnZhbHVlO1xuICB9XG4gIHNldCBsdXQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImx1dFwiKS52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAodmFsdWUudHlwZSA9PT0gRmxvYXRUeXBlNSB8fCB2YWx1ZS50eXBlID09PSBIYWxmRmxvYXRUeXBlKSkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkxVVF9QUkVDSVNJT05fSElHSFwiLCBcIjFcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9MVVQzREVmZmVjdC5qc1xuaW1wb3J0IHtcbiAgRGF0YTNEVGV4dHVyZSBhcyBEYXRhM0RUZXh0dXJlMixcbiAgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTYsXG4gIEhhbGZGbG9hdFR5cGUgYXMgSGFsZkZsb2F0VHlwZTIsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXI0LFxuICBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXI3LFxuICBzUkdCRW5jb2RpbmcgYXMgc1JHQkVuY29kaW5nMixcbiAgVW5pZm9ybSBhcyBVbmlmb3JtMzgsXG4gIFZlY3RvcjMgYXMgVmVjdG9yMzRcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbHV0LTNkLmZyYWdcbnZhciBsdXRfM2RfZGVmYXVsdCA9IFwidW5pZm9ybSB2ZWMzIHNjYWxlO3VuaWZvcm0gdmVjMyBvZmZzZXQ7XFxuI2lmZGVmIENVU1RPTV9JTlBVVF9ET01BSU5cXG51bmlmb3JtIHZlYzMgZG9tYWluTWluO3VuaWZvcm0gdmVjMyBkb21haW5NYXg7XFxuI2VuZGlmXFxuI2lmZGVmIExVVF8zRFxcbiNpZmRlZiBMVVRfUFJFQ0lTSU9OX0hJR0hcXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIzRCBsdXQ7XFxuI2Vsc2VcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjNEIGx1dDtcXG4jZW5kaWZcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyM0QgbHV0O1xcbiNlbmRpZlxcbnZlYzQgYXBwbHlMVVQoY29uc3QgaW4gdmVjMyByZ2Ipe1xcbiNpZmRlZiBURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OXFxudmVjMyBwPWZsb29yKHJnYik7dmVjMyBmPXJnYi1wO3ZlYzMgdjE9KHArMC41KSpMVVRfVEVYRUxfV0lEVEg7dmVjMyB2ND0ocCsxLjUpKkxVVF9URVhFTF9XSURUSDt2ZWMzIHYyLHYzO3ZlYzMgZnJhYztpZihmLnI+PWYuZyl7aWYoZi5nPmYuYil7ZnJhYz1mLnJnYjt2Mj12ZWMzKHY0LngsdjEueSx2MS56KTt2Mz12ZWMzKHY0LngsdjQueSx2MS56KTt9ZWxzZSBpZihmLnI+PWYuYil7ZnJhYz1mLnJiZzt2Mj12ZWMzKHY0LngsdjEueSx2MS56KTt2Mz12ZWMzKHY0LngsdjEueSx2NC56KTt9ZWxzZXtmcmFjPWYuYnJnO3YyPXZlYzModjEueCx2MS55LHY0LnopO3YzPXZlYzModjQueCx2MS55LHY0LnopO319ZWxzZXtpZihmLmI+Zi5nKXtmcmFjPWYuYmdyO3YyPXZlYzModjEueCx2MS55LHY0LnopO3YzPXZlYzModjEueCx2NC55LHY0LnopO31lbHNlIGlmKGYucj49Zi5iKXtmcmFjPWYuZ3JiO3YyPXZlYzModjEueCx2NC55LHYxLnopO3YzPXZlYzModjQueCx2NC55LHYxLnopO31lbHNle2ZyYWM9Zi5nYnI7djI9dmVjMyh2MS54LHY0LnksdjEueik7djM9dmVjMyh2MS54LHY0LnksdjQueik7fX12ZWM0IG4xPXRleHR1cmUobHV0LHYxKTt2ZWM0IG4yPXRleHR1cmUobHV0LHYyKTt2ZWM0IG4zPXRleHR1cmUobHV0LHYzKTt2ZWM0IG40PXRleHR1cmUobHV0LHY0KTt2ZWM0IHdlaWdodHM9dmVjNCgxLjAtZnJhYy54LGZyYWMueC1mcmFjLnksZnJhYy55LWZyYWMueixmcmFjLnopO3ZlYzQgcmVzdWx0PXdlaWdodHMqbWF0NCh2ZWM0KG4xLnIsbjIucixuMy5yLG40LnIpLHZlYzQobjEuZyxuMi5nLG4zLmcsbjQuZyksdmVjNChuMS5iLG4yLmIsbjMuYixuNC5iKSx2ZWM0KDEuMCkpO3JldHVybiB2ZWM0KHJlc3VsdC5yZ2IsMS4wKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlKGx1dCxyZ2IpO1xcbiNlbmRpZlxcbn1cXG4jZWxzZVxcbiNpZmRlZiBMVVRfUFJFQ0lTSU9OX0hJR0hcXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBsdXQ7XFxuI2Vsc2VcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGx1dDtcXG4jZW5kaWZcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHV0O1xcbiNlbmRpZlxcbnZlYzQgYXBwbHlMVVQoY29uc3QgaW4gdmVjMyByZ2Ipe2Zsb2F0IHNsaWNlPXJnYi5iKkxVVF9TSVpFO2Zsb2F0IHNsaWNlMD1mbG9vcihzbGljZSk7ZmxvYXQgaW50ZXJwPXNsaWNlLXNsaWNlMDtmbG9hdCBjZW50ZXJlZEludGVycD1pbnRlcnAtMC41O2Zsb2F0IHNsaWNlMT1zbGljZTArc2lnbihjZW50ZXJlZEludGVycCk7XFxuI2lmZGVmIExVVF9TVFJJUF9IT1JJWk9OVEFMXFxuZmxvYXQgeE9mZnNldD1jbGFtcChyZ2IucipMVVRfVEVYRUxfSEVJR0hULExVVF9URVhFTF9XSURUSCowLjUsTFVUX1RFWEVMX0hFSUdIVC1MVVRfVEVYRUxfV0lEVEgqMC41KTt2ZWMyIHV2MD12ZWMyKHNsaWNlMCpMVVRfVEVYRUxfSEVJR0hUK3hPZmZzZXQscmdiLmcpO3ZlYzIgdXYxPXZlYzIoc2xpY2UxKkxVVF9URVhFTF9IRUlHSFQreE9mZnNldCxyZ2IuZyk7XFxuI2Vsc2VcXG5mbG9hdCB5T2Zmc2V0PWNsYW1wKHJnYi5nKkxVVF9URVhFTF9XSURUSCxMVVRfVEVYRUxfSEVJR0hUKjAuNSxMVVRfVEVYRUxfV0lEVEgtTFVUX1RFWEVMX0hFSUdIVCowLjUpO3ZlYzIgdXYwPXZlYzIocmdiLnIsc2xpY2UwKkxVVF9URVhFTF9XSURUSCt5T2Zmc2V0KTt2ZWMyIHV2MT12ZWMyKHJnYi5yLHNsaWNlMSpMVVRfVEVYRUxfV0lEVEgreU9mZnNldCk7XFxuI2VuZGlmXFxudmVjNCBzYW1wbGUwPXRleHR1cmUyRChsdXQsdXYwKTt2ZWM0IHNhbXBsZTE9dGV4dHVyZTJEKGx1dCx1djEpO3JldHVybiBtaXgoc2FtcGxlMCxzYW1wbGUxLGFicyhjZW50ZXJlZEludGVycCkpO31cXG4jZW5kaWZcXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBjPWlucHV0Q29sb3IucmdiO1xcbiNpZmRlZiBDVVNUT01fSU5QVVRfRE9NQUlOXFxuaWYoYy5yPj1kb21haW5NaW4uciYmYy5nPj1kb21haW5NaW4uZyYmYy5iPj1kb21haW5NaW4uYiYmYy5yPD1kb21haW5NYXguciYmYy5nPD1kb21haW5NYXguZyYmYy5iPD1kb21haW5NYXguYil7Yz1hcHBseUxVVChzY2FsZSpjK29mZnNldCkucmdiO31lbHNle2M9aW5wdXRDb2xvci5yZ2I7fVxcbiNlbHNlXFxuI2lmICFkZWZpbmVkKExVVF8zRCkgfHwgZGVmaW5lZChURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OKVxcbmM9Y2xhbXAoYywwLjAsMS4wKTtcXG4jZW5kaWZcXG5jPWFwcGx5TFVUKHNjYWxlKmMrb2Zmc2V0KS5yZ2I7XFxuI2VuZGlmXFxub3V0cHV0Q29sb3I9dmVjNChjLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9MVVQzREVmZmVjdC5qc1xudmFyIExVVDNERWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBncmFkaW5nIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBsdXQgLSBUaGUgbG9va3VwIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50ZXRyYWhlZHJhbEludGVycG9sYXRpb249ZmFsc2VdIC0gRW5hYmxlcyBvciBkaXNhYmxlcyB0ZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uLlxuICAgKiBAcGFyYW0ge1RleHR1cmVFbmNvZGluZ30gW29wdGlvbnMuaW5wdXRFbmNvZGluZz1zUkdCRW5jb2RpbmddIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtDb2xvclNwYWNlfSBbb3B0aW9ucy5pbnB1dENvbG9yU3BhY2U9U1JHQkNvbG9yU3BhY2VdIC0gVGhlIGlucHV0IGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobHV0LCB7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDLFxuICAgIHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxuICAgIGlucHV0RW5jb2RpbmcgPSBzUkdCRW5jb2RpbmcyLFxuICAgIGlucHV0Q29sb3JTcGFjZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkxVVDNERWZmZWN0XCIsIGx1dF8zZF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wibHV0XCIsIG5ldyBVbmlmb3JtMzgobnVsbCldLFxuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTM4KG5ldyBWZWN0b3IzNCgpKV0sXG4gICAgICAgIFtcIm9mZnNldFwiLCBuZXcgVW5pZm9ybTM4KG5ldyBWZWN0b3IzNCgpKV0sXG4gICAgICAgIFtcImRvbWFpbk1pblwiLCBuZXcgVW5pZm9ybTM4KG51bGwpXSxcbiAgICAgICAgW1wiZG9tYWluTWF4XCIsIG5ldyBVbmlmb3JtMzgobnVsbCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uID0gdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuaW5wdXRDb2xvclNwYWNlID0gaW5wdXRDb2xvclNwYWNlIHx8IGVuY29kaW5nVG9Db2xvclNwYWNlLmdldChpbnB1dEVuY29kaW5nKTtcbiAgICB0aGlzLmx1dCA9IGx1dDtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGVuY29kaW5nLiBEZWZhdWx0IGlzIGBzUkdCRW5jb2RpbmdgLlxuICAgKlxuICAgKiBTZXQgdGhpcyB0byBgTGluZWFyRW5jb2RpbmdgIGlmIHlvdXIgTFVUIGV4cGVjdHMgbGluZWFyIGNvbG9yIGlucHV0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRDb2xvclNwYWNlIGluc3RlYWQuXG4gICAqIEB0eXBlIHtUZXh0dXJlRW5jb2Rpbmd9XG4gICAqL1xuICBnZXQgaW5wdXRFbmNvZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dENvbG9yU3BhY2U7XG4gIH1cbiAgc2V0IGlucHV0RW5jb2RpbmcodmFsdWUpIHtcbiAgICB0aGlzLmlucHV0Q29sb3JTcGFjZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBlbmNvZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0Q29sb3JTcGFjZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlRW5jb2Rpbmd9IFRoZSBlbmNvZGluZy5cbiAgICovXG4gIGdldElucHV0RW5jb2RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRDb2xvclNwYWNlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBlbmNvZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0Q29sb3JTcGFjZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmVFbmNvZGluZ30gdmFsdWUgLSBUaGUgZW5jb2RpbmcuXG4gICAqL1xuICBzZXRJbnB1dEVuY29kaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5pbnB1dENvbG9yU3BhY2UgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IGVuY29kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3V0cHV0Q29sb3JTcGFjZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlRW5jb2Rpbmd9IFRoZSBlbmNvZGluZy5cbiAgICovXG4gIGdldE91dHB1dEVuY29kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dENvbG9yU3BhY2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBMVVQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGx1dCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJsdXRcIikudmFsdWU7XG4gIH1cbiAgc2V0IGx1dCh2YWx1ZSkge1xuICAgIGNvbnN0IGRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGlmICh0aGlzLmx1dCAhPT0gdmFsdWUpIHtcbiAgICAgIHVuaWZvcm1zLmdldChcImx1dFwiKS52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gdmFsdWUuaW1hZ2U7XG4gICAgICAgIGNvbnN0IHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiA9IHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uO1xuICAgICAgICBkZWZpbmVzLmNsZWFyKCk7XG4gICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1NJWkVcIiwgTWF0aC5taW4oaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkudG9GaXhlZCgxNikpO1xuICAgICAgICBkZWZpbmVzLnNldChcIkxVVF9URVhFTF9XSURUSFwiLCAoMSAvIGltYWdlLndpZHRoKS50b0ZpeGVkKDE2KSk7XG4gICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1RFWEVMX0hFSUdIVFwiLCAoMSAvIGltYWdlLmhlaWdodCkudG9GaXhlZCgxNikpO1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJkb21haW5NaW5cIikudmFsdWUgPSBudWxsO1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJkb21haW5NYXhcIikudmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gRmxvYXRUeXBlNiB8fCB2YWx1ZS50eXBlID09PSBIYWxmRmxvYXRUeXBlMikge1xuICAgICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1BSRUNJU0lPTl9ISUdIXCIsIFwiMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2Uud2lkdGggPiBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICBkZWZpbmVzLnNldChcIkxVVF9TVFJJUF9IT1JJWk9OVEFMXCIsIFwiMVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGEzRFRleHR1cmUyKSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfM0RcIiwgXCIxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvb2t1cFRleHR1cmUpIHtcbiAgICAgICAgICBjb25zdCBtaW4gPSB2YWx1ZS5kb21haW5NaW47XG4gICAgICAgICAgY29uc3QgbWF4ID0gdmFsdWUuZG9tYWluTWF4O1xuICAgICAgICAgIGlmIChtaW4ueCAhPT0gMCB8fCBtaW4ueSAhPT0gMCB8fCBtaW4ueiAhPT0gMCB8fCBtYXgueCAhPT0gMSB8fCBtYXgueSAhPT0gMSB8fCBtYXgueiAhPT0gMSkge1xuICAgICAgICAgICAgZGVmaW5lcy5zZXQoXCJDVVNUT01fSU5QVVRfRE9NQUlOXCIsIFwiMVwiKTtcbiAgICAgICAgICAgIHVuaWZvcm1zLmdldChcImRvbWFpbk1pblwiKS52YWx1ZSA9IG1pbi5jbG9uZSgpO1xuICAgICAgICAgICAgdW5pZm9ybXMuZ2V0KFwiZG9tYWluTWF4XCIpLnZhbHVlID0gbWF4LmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uID0gdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBMVVQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIExVVC5cbiAgICovXG4gIGdldExVVCgpIHtcbiAgICByZXR1cm4gdGhpcy5sdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIExVVC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1dCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIExVVC5cbiAgICovXG4gIHNldExVVCh2YWx1ZSkge1xuICAgIHRoaXMubHV0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNjYWxlIGFuZCBvZmZzZXQgZm9yIHRoZSBMVVQgc2FtcGxpbmcgY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVTY2FsZU9mZnNldCgpIHtcbiAgICBjb25zdCBsdXQgPSB0aGlzLmx1dDtcbiAgICBpZiAobHV0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5taW4obHV0LmltYWdlLndpZHRoLCBsdXQuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMudW5pZm9ybXMuZ2V0KFwib2Zmc2V0XCIpLnZhbHVlO1xuICAgICAgaWYgKHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uICYmIGx1dCBpbnN0YW5jZW9mIERhdGEzRFRleHR1cmUyKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmluZXMuaGFzKFwiQ1VTVE9NX0lOUFVUX0RPTUFJTlwiKSkge1xuICAgICAgICAgIGNvbnN0IGRvbWFpblNjYWxlID0gbHV0LmRvbWFpbk1heC5jbG9uZSgpLnN1YihsdXQuZG9tYWluTWluKTtcbiAgICAgICAgICBzY2FsZS5zZXRTY2FsYXIoc2l6ZSAtIDEpLmRpdmlkZShkb21haW5TY2FsZSk7XG4gICAgICAgICAgb2Zmc2V0LmNvcHkobHV0LmRvbWFpbk1pbikubmVnYXRlKCkubXVsdGlwbHkoc2NhbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcihzaXplIC0gMSk7XG4gICAgICAgICAgb2Zmc2V0LnNldFNjYWxhcigwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmaW5lcy5oYXMoXCJDVVNUT01fSU5QVVRfRE9NQUlOXCIpKSB7XG4gICAgICAgICAgY29uc3QgZG9tYWluU2NhbGUgPSBsdXQuZG9tYWluTWF4LmNsb25lKCkuc3ViKGx1dC5kb21haW5NaW4pLm11bHRpcGx5U2NhbGFyKHNpemUpO1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcihzaXplIC0gMSkuZGl2aWRlKGRvbWFpblNjYWxlKTtcbiAgICAgICAgICBvZmZzZXQuY29weShsdXQuZG9tYWluTWluKS5uZWdhdGUoKS5tdWx0aXBseShzY2FsZSkuYWRkU2NhbGFyKDEgLyAoMiAqIHNpemUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FsZS5zZXRTY2FsYXIoKHNpemUgLSAxKSAvIHNpemUpO1xuICAgICAgICAgIG9mZnNldC5zZXRTY2FsYXIoMSAvICgyICogc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHBhcmFtZXRlcnMgZm9yIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25maWd1cmVUZXRyYWhlZHJhbEludGVycG9sYXRpb24oKSB7XG4gICAgY29uc3QgbHV0ID0gdGhpcy5sdXQ7XG4gICAgaWYgKGx1dCAhPT0gbnVsbCkge1xuICAgICAgbHV0Lm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjQ7XG4gICAgICBsdXQubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyNDtcbiAgICAgIGlmICh0aGlzLnRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbikge1xuICAgICAgICBpZiAobHV0IGluc3RhbmNlb2YgRGF0YTNEVGV4dHVyZTIpIHtcbiAgICAgICAgICBsdXQubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjc7XG4gICAgICAgICAgbHV0Lm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRldHJhaGVkcmFsIGludGVycG9sYXRpb24gcmVxdWlyZXMgYSAzRCB0ZXh0dXJlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobHV0LnNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGx1dC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0ZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uIGlzIGVuYWJsZWQuIFJlcXVpcmVzIGEgM0QgTFVULCBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBUZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uIHByb2R1Y2VzIGhpZ2hseSBhY2N1cmF0ZSByZXN1bHRzIGJ1dCBpcyBzbG93ZXIgdGhhbiBoYXJkd2FyZSBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB0ZXRyYWhlZHJhbEludGVycG9sYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OXCIpO1xuICB9XG4gIHNldCB0ZXRyYWhlZHJhbEludGVycG9sYXRpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OXCIsIFwiMVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT05cIik7XG4gICAgfVxuICAgIHRoaXMuY29uZmlndXJlVGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVTY2FsZU9mZnNldCgpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXRyYWhlZHJhbEludGVycG9sYXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbiBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldFRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbkVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLnRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL25vaXNlLmZyYWdcbnZhciBub2lzZV9kZWZhdWx0ID0gXCJ2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBub2lzZT12ZWMzKHJhbmQodXYqKDEuMCt0aW1lKSkpO1xcbiNpZmRlZiBQUkVNVUxUSVBMWVxcbm91dHB1dENvbG9yPXZlYzQobWluKGlucHV0Q29sb3IucmdiKm5vaXNlLHZlYzMoMS4wKSksaW5wdXRDb2xvci5hKTtcXG4jZWxzZVxcbm91dHB1dENvbG9yPXZlYzQobm9pc2UsaW5wdXRDb2xvci5hKTtcXG4jZW5kaWZcXG59XCI7XG5cbi8vIHNyYy9lZmZlY3RzL05vaXNlRWZmZWN0LmpzXG52YXIgTm9pc2VFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vaXNlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TQ1JFRU5dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnByZW11bHRpcGx5PWZhbHNlXSAtIFdoZXRoZXIgdGhlIG5vaXNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIHdpdGggdGhlIGlucHV0IGNvbG9ycyBwcmlvciB0byBibGVuZGluZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU0NSRUVOLCBwcmVtdWx0aXBseSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTm9pc2VFZmZlY3RcIiwgbm9pc2VfZGVmYXVsdCwgeyBibGVuZEZ1bmN0aW9uIH0pO1xuICAgIHRoaXMucHJlbXVsdGlwbHkgPSBwcmVtdWx0aXBseTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgbm9pc2Ugd2lsbCBiZSBtdWx0aXBsaWVkIHdpdGggdGhlIGlucHV0IGNvbG9ycyBwcmlvciB0byBibGVuZGluZy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgcHJlbXVsdGlwbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJQUkVNVUxUSVBMWVwiKTtcbiAgfVxuICBzZXQgcHJlbXVsdGlwbHkodmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcmVtdWx0aXBseSAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiUFJFTVVMVElQTFlcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlBSRU1VTFRJUExZXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBub2lzZSB3aWxsIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlbXVsdGlwbHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBub2lzZSBpcyBwcmVtdWx0aXBsaWVkLlxuICAgKi9cbiAgaXNQcmVtdWx0aXBsaWVkKCkge1xuICAgIHJldHVybiB0aGlzLnByZW11bHRpcGx5O1xuICB9XG4gIC8qKlxuICAgKiBDb250cm9scyB3aGV0aGVyIG5vaXNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIHdpdGggdGhlIGlucHV0IGNvbG9ycyBwcmlvciB0byBibGVuZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZW11bHRpcGx5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIG5vaXNlIHNob3VsZCBiZSBwcmVtdWx0aXBsaWVkLlxuICAgKi9cbiAgc2V0UHJlbXVsdGlwbGllZCh2YWx1ZSkge1xuICAgIHRoaXMucHJlbXVsdGlwbHkgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvT3V0bGluZUVmZmVjdC5qc1xuaW1wb3J0IHsgQ29sb3IgYXMgQ29sb3I2LCBSZXBlYXRXcmFwcGluZyBhcyBSZXBlYXRXcmFwcGluZzIsIFVuaWZvcm0gYXMgVW5pZm9ybTM5LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxNSwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL291dGxpbmUuZnJhZ1xudmFyIG91dGxpbmVfZGVmYXVsdDMgPSBcInVuaWZvcm0gbG93cCBzYW1wbGVyMkQgZWRnZVRleHR1cmU7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXNrVGV4dHVyZTt1bmlmb3JtIHZlYzMgdmlzaWJsZUVkZ2VDb2xvcjt1bmlmb3JtIHZlYzMgaGlkZGVuRWRnZUNvbG9yO3VuaWZvcm0gZmxvYXQgcHVsc2U7dW5pZm9ybSBmbG9hdCBlZGdlU3RyZW5ndGg7XFxuI2lmZGVmIFVTRV9QQVRURVJOXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBwYXR0ZXJuVGV4dHVyZTt2YXJ5aW5nIHZlYzIgdlV2UGF0dGVybjtcXG4jZW5kaWZcXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMiBlZGdlPXRleHR1cmUyRChlZGdlVGV4dHVyZSx1dikucmc7dmVjMiBtYXNrPXRleHR1cmUyRChtYXNrVGV4dHVyZSx1dikucmc7XFxuI2lmbmRlZiBYX1JBWVxcbmVkZ2UueT0wLjA7XFxuI2VuZGlmXFxuZWRnZSo9KGVkZ2VTdHJlbmd0aCptYXNrLngqcHVsc2UpO3ZlYzMgY29sb3I9ZWRnZS54KnZpc2libGVFZGdlQ29sb3IrZWRnZS55KmhpZGRlbkVkZ2VDb2xvcjtmbG9hdCB2aXNpYmlsaXR5RmFjdG9yPTAuMDtcXG4jaWZkZWYgVVNFX1BBVFRFUk5cXG52ZWM0IHBhdHRlcm5Db2xvcj10ZXh0dXJlMkQocGF0dGVyblRleHR1cmUsdlV2UGF0dGVybik7XFxuI2lmZGVmIFhfUkFZXFxuZmxvYXQgaGlkZGVuRmFjdG9yPTAuNTtcXG4jZWxzZVxcbmZsb2F0IGhpZGRlbkZhY3Rvcj0wLjA7XFxuI2VuZGlmXFxudmlzaWJpbGl0eUZhY3Rvcj0oMS4wLW1hc2sueT4wLjApPzEuMDpoaWRkZW5GYWN0b3I7dmlzaWJpbGl0eUZhY3Rvcio9KDEuMC1tYXNrLngpKnBhdHRlcm5Db2xvci5hO2NvbG9yKz12aXNpYmlsaXR5RmFjdG9yKnBhdHRlcm5Db2xvci5yZ2I7XFxuI2VuZGlmXFxuZmxvYXQgYWxwaGE9bWF4KG1heChlZGdlLngsZWRnZS55KSx2aXNpYmlsaXR5RmFjdG9yKTtcXG4jaWZkZWYgQUxQSEFcXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGFscGhhKTtcXG4jZWxzZVxcbm91dHB1dENvbG9yPXZlYzQoY29sb3IsbWF4KGFscGhhLGlucHV0Q29sb3IuYSkpO1xcbiNlbmRpZlxcbn1cIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9vdXRsaW5lLnZlcnRcbnZhciBvdXRsaW5lX2RlZmF1bHQ0ID0gXCJ1bmlmb3JtIGZsb2F0IHBhdHRlcm5TY2FsZTt2YXJ5aW5nIHZlYzIgdlV2UGF0dGVybjt2b2lkIG1haW5TdXBwb3J0KGNvbnN0IGluIHZlYzIgdXYpe3ZVdlBhdHRlcm49dXYqdmVjMihhc3BlY3QsMS4wKSpwYXR0ZXJuU2NhbGU7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9PdXRsaW5lRWZmZWN0LmpzXG52YXIgT3V0bGluZUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgb3V0bGluZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIG1haW4gc2NlbmUuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU0NSRUVOXSAtIFRoZSBibGVuZCBmdW5jdGlvbi4gVXNlIGBCbGVuZEZ1bmN0aW9uLkFMUEhBYCBmb3IgZGFyayBvdXRsaW5lcy5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbb3B0aW9ucy5wYXR0ZXJuVGV4dHVyZT1udWxsXSAtIEEgcGF0dGVybiB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGF0dGVyblNjYWxlPTEuMF0gLSBUaGUgcGF0dGVybiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVkZ2VTdHJlbmd0aD0xLjBdIC0gVGhlIGVkZ2Ugc3RyZW5ndGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wdWxzZVNwZWVkPTAuMF0gLSBUaGUgcHVsc2Ugc3BlZWQuIEEgdmFsdWUgb2YgemVybyBkaXNhYmxlcyB0aGUgcHVsc2UgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlzaWJsZUVkZ2VDb2xvcj0weGZmZmZmZl0gLSBUaGUgY29sb3Igb2YgdmlzaWJsZSBlZGdlcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhpZGRlbkVkZ2VDb2xvcj0weDIyMDkwYV0gLSBUaGUgY29sb3Igb2YgaGlkZGVuIGVkZ2VzLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5WRVJZX1NNQUxMXSAtIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJsdXI9ZmFsc2VdIC0gV2hldGhlciB0aGUgb3V0bGluZSBzaG91bGQgYmUgYmx1cnJlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy54UmF5PXRydWVdIC0gV2hldGhlciBvY2NsdWRlZCBwYXJ0cyBvZiBzZWxlY3RlZCBvYmplY3RzIHNob3VsZCBiZSB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlzYW1wbGluZz0wXSAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyB1c2VkIGZvciBtdWx0aXNhbXBsZSBhbnRpYWxpYXNpbmcuIFJlcXVpcmVzIFdlYkdMIDIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY2VuZSwgY2FtZXJhLCB7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU0NSRUVOLFxuICAgIHBhdHRlcm5UZXh0dXJlID0gbnVsbCxcbiAgICBwYXR0ZXJuU2NhbGUgPSAxLFxuICAgIGVkZ2VTdHJlbmd0aCA9IDEsXG4gICAgcHVsc2VTcGVlZCA9IDAsXG4gICAgdmlzaWJsZUVkZ2VDb2xvciA9IDE2Nzc3MjE1LFxuICAgIGhpZGRlbkVkZ2VDb2xvciA9IDIyMzA1MzgsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuVkVSWV9TTUFMTCxcbiAgICBibHVyID0gZmFsc2UsXG4gICAgeFJheSA9IHRydWUsXG4gICAgbXVsdGlzYW1wbGluZyA9IDAsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIk91dGxpbmVFZmZlY3RcIiwgb3V0bGluZV9kZWZhdWx0Mywge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wibWFza1RleHR1cmVcIiwgbmV3IFVuaWZvcm0zOShudWxsKV0sXG4gICAgICAgIFtcImVkZ2VUZXh0dXJlXCIsIG5ldyBVbmlmb3JtMzkobnVsbCldLFxuICAgICAgICBbXCJlZGdlU3RyZW5ndGhcIiwgbmV3IFVuaWZvcm0zOShlZGdlU3RyZW5ndGgpXSxcbiAgICAgICAgW1widmlzaWJsZUVkZ2VDb2xvclwiLCBuZXcgVW5pZm9ybTM5KG5ldyBDb2xvcjYodmlzaWJsZUVkZ2VDb2xvcikpXSxcbiAgICAgICAgW1wiaGlkZGVuRWRnZUNvbG9yXCIsIG5ldyBVbmlmb3JtMzkobmV3IENvbG9yNihoaWRkZW5FZGdlQ29sb3IpKV0sXG4gICAgICAgIFtcInB1bHNlXCIsIG5ldyBVbmlmb3JtMzkoMSldLFxuICAgICAgICBbXCJwYXR0ZXJuU2NhbGVcIiwgbmV3IFVuaWZvcm0zOShwYXR0ZXJuU2NhbGUpXSxcbiAgICAgICAgW1wicGF0dGVyblRleHR1cmVcIiwgbmV3IFVuaWZvcm0zOShudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5ibGVuZE1vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmJsZW5kTW9kZS5ibGVuZEZ1bmN0aW9uID09PSBCbGVuZEZ1bmN0aW9uLkFMUEhBKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJBTFBIQVwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiQUxQSEFcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJsZW5kTW9kZS5ibGVuZEZ1bmN0aW9uID0gYmxlbmRGdW5jdGlvbjtcbiAgICB0aGlzLnBhdHRlcm5UZXh0dXJlID0gcGF0dGVyblRleHR1cmU7XG4gICAgdGhpcy54UmF5ID0geFJheTtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTgoMSwgMSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrLnNhbXBsZXMgPSBtdWx0aXNhbXBsaW5nO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFzay50ZXh0dXJlLm5hbWUgPSBcIk91dGxpbmUuTWFza1wiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFza1RleHR1cmVcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldE1hc2sudGV4dHVyZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE91dGxpbmUgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxOCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE91dGxpbmUudGV4dHVyZS5uYW1lID0gXCJPdXRsaW5lLkVkZ2VzXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJlZGdlVGV4dHVyZVwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZS50ZXh0dXJlO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcygpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjYoMCk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLmRlcHRoUGFzcyA9IG5ldyBEZXB0aFBhc3Moc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5tYXNrUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEsIG5ldyBEZXB0aENvbXBhcmlzb25NYXRlcmlhbCh0aGlzLmRlcHRoUGFzcy50ZXh0dXJlLCBjYW1lcmEpKTtcbiAgICBjb25zdCBjbGVhclBhc3MgPSB0aGlzLm1hc2tQYXNzLmNsZWFyUGFzcztcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yNigxNjc3NzIxNSk7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IDE7XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBLYXdhc2VCbHVyUGFzcyh7IHJlc29sdXRpb25TY2FsZSwgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMuYmx1clBhc3MuZW5hYmxlZCA9IGJsdXI7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gICAgdGhpcy5vdXRsaW5lUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBPdXRsaW5lTWF0ZXJpYWwoKSk7XG4gICAgY29uc3Qgb3V0bGluZU1hdGVyaWFsID0gdGhpcy5vdXRsaW5lUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgb3V0bGluZU1hdGVyaWFsLmlucHV0QnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXRNYXNrLnRleHR1cmU7XG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnNlbGVjdGlvbi5sYXllciA9IDEwO1xuICAgIHRoaXMucHVsc2VTcGVlZCA9IHB1bHNlU3BlZWQ7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NlbmUgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoUGFzcy5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5tYXNrUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5tYXNrUGFzcy5vdmVycmlkZU1hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7UmVzb2x1dGlvbn1cbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1Jlc2l6ZXJ9IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5nZXRSZXNvbHV0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgTVNBQSBzYW1wbGVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyBXZWJHTCAyLiBTZXQgdG8gemVybyB0byBkaXNhYmxlIG11bHRpc2FtcGxpbmcuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgUmVxdWlyZXMgdGhyZWUgPj0gcjEzOC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtdWx0aXNhbXBsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldE1hc2suc2FtcGxlcztcbiAgfVxuICBzZXQgbXVsdGlzYW1wbGluZyh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zYW1wbGVzID0gdmFsdWU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrLmRpc3Bvc2UoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBhdHRlcm4gc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcGF0dGVyblNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5TY2FsZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgcGF0dGVyblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJwYXR0ZXJuU2NhbGVcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2Ugc3RyZW5ndGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZWRnZVN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImVkZ2VTdHJlbmd0aFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgZWRnZVN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJlZGdlU3RyZW5ndGhcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHZpc2libGUgZWRnZSBjb2xvci5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKi9cbiAgZ2V0IHZpc2libGVFZGdlQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwidmlzaWJsZUVkZ2VDb2xvclwiKS52YWx1ZTtcbiAgfVxuICBzZXQgdmlzaWJsZUVkZ2VDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwidmlzaWJsZUVkZ2VDb2xvclwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGlkZGVuIGVkZ2UgY29sb3IuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICovXG4gIGdldCBoaWRkZW5FZGdlQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiaGlkZGVuRWRnZUNvbG9yXCIpLnZhbHVlO1xuICB9XG4gIHNldCBoaWRkZW5FZGdlQ29sb3IodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImhpZGRlbkVkZ2VDb2xvclwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyUGFzcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtLYXdhc2VCbHVyUGFzc30gVGhlIGJsdXIgcGFzcy5cbiAgICovXG4gIGdldEJsdXJQYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGUgc2VsZWN0aW9uLlxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHVsc2Ugc3BlZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwdWxzZVNwZWVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNwZWVkLlxuICAgKi9cbiAgZ2V0UHVsc2VTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWxzZVNwZWVkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwdWxzZSBzcGVlZC4gU2V0IHRvIHplcm8gdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHB1bHNlU3BlZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNwZWVkLlxuICAgKi9cbiAgc2V0UHVsc2VTcGVlZCh2YWx1ZSkge1xuICAgIHRoaXMucHVsc2VTcGVlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLndpZHRoIGluc3RlYWQuXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24uaGVpZ2h0IGluc3RlYWQuXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzZWxlY3Rpb24gbGF5ZXIuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24ubGF5ZXIgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzZWxlY3Rpb25MYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ubGF5ZXI7XG4gIH1cbiAgc2V0IHNlbGVjdGlvbkxheWVyKHZhbHVlKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ubGF5ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5kaXRoZXJpbmc7XG4gIH1cbiAgc2V0IGRpdGhlcmluZyh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZGl0aGVyaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzLmtlcm5lbFNpemUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG91dGxpbmVzIHNob3VsZCBiZSBibHVycmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzLmVuYWJsZWQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBibHVyKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmVuYWJsZWQ7XG4gIH1cbiAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmVuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgWC1yYXkgbW9kZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB4UmF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiWF9SQVlcIik7XG4gIH1cbiAgc2V0IHhSYXkodmFsdWUpIHtcbiAgICBpZiAodGhpcy54UmF5ICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJYX1JBWVwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiWF9SQVlcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIFgtcmF5IG1vZGUgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHhSYXkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBYLXJheSBtb2RlIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc1hSYXlFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnhSYXk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgWC1yYXkgb3V0bGluZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB4UmF5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIFgtcmF5IHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0WFJheUVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLnhSYXkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBhdHRlcm4gdGV4dHVyZS4gU2V0IHRvIGBudWxsYCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBwYXR0ZXJuVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJwYXR0ZXJuVGV4dHVyZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgcGF0dGVyblRleHR1cmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlLndyYXBTID0gdmFsdWUud3JhcFQgPSBSZXBlYXRXcmFwcGluZzI7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiVVNFX1BBVFRFUk5cIiwgXCIxXCIpO1xuICAgICAgdGhpcy5zZXRWZXJ0ZXhTaGFkZXIob3V0bGluZV9kZWZhdWx0NCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJVU0VfUEFUVEVSTlwiKTtcbiAgICAgIHRoaXMuc2V0VmVydGV4U2hhZGVyKG51bGwpO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5UZXh0dXJlXCIpLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhdHRlcm4gdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBhdHRlcm5UZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgbmV3IHRleHR1cmUuXG4gICAqL1xuICBzZXRQYXR0ZXJuVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMucGF0dGVyblRleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvblNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBuZXcgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIHNldFJlc29sdXRpb25TY2FsZShzY2FsZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zY2FsZSA9IHNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCBzZWxlY3RzIGEgbGlzdCBvZiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEW119IG9iamVjdHMgLSBUaGUgb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBvdXRsaW5lZC4gVGhpcyBhcnJheSB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T3V0bGluZVBhc3N9IFRoaXMgcGFzcy5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlbGVjdGlvbi5zZXQoKSBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uKG9iamVjdHMpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5zZXQob2JqZWN0cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgbGlzdCBvZiBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLmNsZWFyKCkgaW5zdGVhZC5cbiAgICovXG4gIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdHMgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIG91dGxpbmVkLlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLmFkZCgpIGluc3RlYWQuXG4gICAqL1xuICBzZWxlY3RPYmplY3Qob2JqZWN0KSB7XG4gICAgdGhpcy5zZWxlY3Rpb24uYWRkKG9iamVjdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VsZWN0cyBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgbm8gbG9uZ2VyIGJlIG91dGxpbmVkLlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLmRlbGV0ZSgpIGluc3RlYWQuXG4gICAqL1xuICBkZXNlbGVjdE9iamVjdChvYmplY3QpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5kZWxldGUob2JqZWN0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICBjb25zdCBwdWxzZSA9IHVuaWZvcm1zLmdldChcInB1bHNlXCIpO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuICAgIGNvbnN0IG1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2s7XG4gICAgaWYgKHRoaXMuZm9yY2VVcGRhdGUgfHwgc2VsZWN0aW9uLnNpemUgPiAwKSB7XG4gICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgIHB1bHNlLnZhbHVlID0gMTtcbiAgICAgIGlmICh0aGlzLnB1bHNlU3BlZWQgPiAwKSB7XG4gICAgICAgIHB1bHNlLnZhbHVlID0gTWF0aC5jb3ModGhpcy50aW1lICogdGhpcy5wdWxzZVNwZWVkICogMTApICogMC4zNzUgKyAwLjYyNTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZSArPSBkZWx0YVRpbWU7XG4gICAgICBzZWxlY3Rpb24uc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICB0aGlzLmRlcHRoUGFzcy5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgc2VsZWN0aW9uLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICBjYW1lcmEubGF5ZXJzLnNldChzZWxlY3Rpb24ubGF5ZXIpO1xuICAgICAgdGhpcy5tYXNrUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0TWFzayk7XG4gICAgICBjYW1lcmEubGF5ZXJzLm1hc2sgPSBtYXNrO1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgICB0aGlzLm91dGxpbmVQYXNzLnJlbmRlcihyZW5kZXJlciwgbnVsbCwgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lKTtcbiAgICAgIGlmICh0aGlzLmJsdXJQYXNzLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZSwgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSA9IHNlbGVjdGlvbi5zaXplID4gMDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuYmx1clBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2suc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLmRlcHRoUGFzcy5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZS5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMub3V0bGluZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUodywgaCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIFVuc2lnbmVkQnl0ZVR5cGUxNSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmRlcHRoUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICAgIHRoaXMubWFza1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgICB0aGlzLm91dGxpbmVQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvUGl4ZWxhdGlvbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtNDAsIFZlY3RvcjIgYXMgVmVjdG9yMjI0LCBWZWN0b3I0IGFzIFZlY3RvcjQzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvcGl4ZWxhdGlvbi5mcmFnXG52YXIgcGl4ZWxhdGlvbl9kZWZhdWx0ID0gXCJ1bmlmb3JtIGJvb2wgYWN0aXZlO3VuaWZvcm0gdmVjNCBkO3ZvaWQgbWFpblV2KGlub3V0IHZlYzIgdXYpe2lmKGFjdGl2ZSl7dXY9ZC54eSooZmxvb3IodXYqZC56dykrMC41KTt9fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9QaXhlbGF0aW9uRWZmZWN0LmpzXG52YXIgUGl4ZWxhdGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgcGl4ZWxhdGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZ3JhbnVsYXJpdHk9MzAuMF0gLSBUaGUgcGl4ZWwgZ3JhbnVsYXJpdHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihncmFudWxhcml0eSA9IDMwKSB7XG4gICAgc3VwZXIoXCJQaXhlbGF0aW9uRWZmZWN0XCIsIHBpeGVsYXRpb25fZGVmYXVsdCwge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYWN0aXZlXCIsIG5ldyBVbmlmb3JtNDAoZmFsc2UpXSxcbiAgICAgICAgW1wiZFwiLCBuZXcgVW5pZm9ybTQwKG5ldyBWZWN0b3I0MygpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIyNCgpO1xuICAgIHRoaXMuX2dyYW51bGFyaXR5ID0gMDtcbiAgICB0aGlzLmdyYW51bGFyaXR5ID0gZ3JhbnVsYXJpdHk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwaXhlbCBncmFudWxhcml0eS5cbiAgICpcbiAgICogQSBoaWdoZXIgdmFsdWUgeWllbGRzIGNvYXJzZXIgdmlzdWFscy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBncmFudWxhcml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhbnVsYXJpdHk7XG4gIH1cbiAgc2V0IGdyYW51bGFyaXR5KHZhbHVlKSB7XG4gICAgbGV0IGQgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICBpZiAoZCAlIDIgPiAwKSB7XG4gICAgICBkICs9IDE7XG4gICAgfVxuICAgIHRoaXMuX2dyYW51bGFyaXR5ID0gZDtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImFjdGl2ZVwiKS52YWx1ZSA9IGQgPiAwO1xuICAgIHRoaXMuc2V0U2l6ZSh0aGlzLnJlc29sdXRpb24ud2lkdGgsIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaXhlbCBncmFudWxhcml0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdyYW51bGFyaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGdyYW51bGFyaXR5LlxuICAgKi9cbiAgZ2V0R3JhbnVsYXJpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhbnVsYXJpdHk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpeGVsIGdyYW51bGFyaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ3JhbnVsYXJpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBncmFudWxhcml0eS5cbiAgICovXG4gIHNldEdyYW51bGFyaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5ncmFudWxhcml0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBncmFudWxhcml0eS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgZCA9IHRoaXMuZ3JhbnVsYXJpdHk7XG4gICAgY29uc3QgeCA9IGQgLyByZXNvbHV0aW9uLng7XG4gICAgY29uc3QgeSA9IGQgLyByZXNvbHV0aW9uLnk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJkXCIpLnZhbHVlLnNldCh4LCB5LCAxIC8geCwgMSAvIHkpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9SZWFsaXN0aWNCb2tlaEVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtNDEsIFZlY3RvcjQgYXMgVmVjdG9yNDQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9yZWFsaXN0aWMtYm9rZWguZnJhZ1xudmFyIHJlYWxpc3RpY19ib2tlaF9kZWZhdWx0ID0gXCJ1bmlmb3JtIGZsb2F0IGZvY3VzO3VuaWZvcm0gZmxvYXQgZm9jYWxMZW5ndGg7dW5pZm9ybSBmbG9hdCBmU3RvcDt1bmlmb3JtIGZsb2F0IG1heEJsdXI7dW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VUaHJlc2hvbGQ7dW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VHYWluO3VuaWZvcm0gZmxvYXQgYmlhczt1bmlmb3JtIGZsb2F0IGZyaW5nZTtcXG4jaWZkZWYgTUFOVUFMX0RPRlxcbnVuaWZvcm0gdmVjNCBkb2Y7XFxuI2VuZGlmXFxuI2lmZGVmIFBFTlRBR09OXFxuZmxvYXQgcGVudGFnb24oY29uc3QgaW4gdmVjMiBjb29yZHMpe2NvbnN0IHZlYzQgSFMwPXZlYzQoMS4wLDAuMCwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTMT12ZWM0KDAuMzA5MDE2OTk0LDAuOTUxMDU2NTE2LDAuMCwxLjApO2NvbnN0IHZlYzQgSFMyPXZlYzQoLTAuODA5MDE2OTk0LDAuNTg3Nzg1MjUyLDAuMCwxLjApO2NvbnN0IHZlYzQgSFMzPXZlYzQoLTAuODA5MDE2OTk0LC0wLjU4Nzc4NTI1MiwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTND12ZWM0KDAuMzA5MDE2OTk0LC0wLjk1MTA1NjUxNiwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTNT12ZWM0KDAuMCwwLjAsMS4wLDEuMCk7Y29uc3QgdmVjNCBPTkU9dmVjNCgxLjApO2NvbnN0IGZsb2F0IFBfRkVBVEhFUj0wLjQ7Y29uc3QgZmxvYXQgTl9GRUFUSEVSPS1QX0ZFQVRIRVI7ZmxvYXQgaW5Pck91dD0tNC4wO3ZlYzQgUD12ZWM0KGNvb3Jkcyx2ZWMyKFJJTkdTX0ZMT0FULTEuMykpO3ZlYzQgZGlzdD12ZWM0KGRvdChQLEhTMCksZG90KFAsSFMxKSxkb3QoUCxIUzIpLGRvdChQLEhTMykpO2Rpc3Q9c21vb3Roc3RlcChOX0ZFQVRIRVIsUF9GRUFUSEVSLGRpc3QpO2luT3JPdXQrPWRvdChkaXN0LE9ORSk7ZGlzdC54PWRvdChQLEhTNCk7ZGlzdC55PUhTNS53LWFicyhQLnopO2Rpc3Q9c21vb3Roc3RlcChOX0ZFQVRIRVIsUF9GRUFUSEVSLGRpc3QpO2luT3JPdXQrPWRpc3QueDtyZXR1cm4gY2xhbXAoaW5Pck91dCwwLjAsMS4wKTt9XFxuI2VuZGlmXFxudmVjMyBwcm9jZXNzVGV4ZWwoY29uc3QgaW4gdmVjMiBjb29yZHMsY29uc3QgaW4gZmxvYXQgYmx1cil7dmVjMiBzY2FsZT10ZXhlbFNpemUqZnJpbmdlKmJsdXI7dmVjMyBjPXZlYzModGV4dHVyZTJEKGlucHV0QnVmZmVyLGNvb3Jkcyt2ZWMyKDAuMCwxLjApKnNjYWxlKS5yLHRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZHMrdmVjMigtMC44NjYsLTAuNSkqc2NhbGUpLmcsdGV4dHVyZTJEKGlucHV0QnVmZmVyLGNvb3Jkcyt2ZWMyKDAuODY2LC0wLjUpKnNjYWxlKS5iKTtmbG9hdCBsdW1pbmFuY2U9bGluZWFyVG9SZWxhdGl2ZUx1bWluYW5jZShjKTtmbG9hdCB0aHJlc2hvbGQ9bWF4KChsdW1pbmFuY2UtbHVtaW5hbmNlVGhyZXNob2xkKSpsdW1pbmFuY2VHYWluLDAuMCk7cmV0dXJuIGMrbWl4KHZlYzMoMC4wKSxjLHRocmVzaG9sZCpibHVyKTt9ZmxvYXQgZ2F0aGVyKGNvbnN0IGluIGZsb2F0IGksY29uc3QgaW4gZmxvYXQgaixjb25zdCBpbiBmbG9hdCByaW5nU2FtcGxlcyxjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIHZlYzIgYmx1ckZhY3Rvcixjb25zdCBpbiBmbG9hdCBibHVyLGlub3V0IHZlYzMgY29sb3Ipe2Zsb2F0IHN0ZXA9UEkyL3JpbmdTYW1wbGVzO3ZlYzIgd2g9dmVjMihjb3MoaipzdGVwKSppLHNpbihqKnN0ZXApKmkpO1xcbiNpZmRlZiBQRU5UQUdPTlxcbmZsb2F0IHA9cGVudGFnb24od2gpO1xcbiNlbHNlXFxuZmxvYXQgcD0xLjA7XFxuI2VuZGlmXFxuY29sb3IrPXByb2Nlc3NUZXhlbCh3aCpibHVyRmFjdG9yK3V2LGJsdXIpKm1peCgxLjAsaS9SSU5HU19GTE9BVCxiaWFzKSpwO3JldHVybiBtaXgoMS4wLGkvUklOR1NfRkxPQVQsYmlhcykqcDt9dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gZmxvYXQgZGVwdGgsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe1xcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyLGNhbWVyYUZhcik7ZmxvYXQgbGluZWFyRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZWxzZVxcbmZsb2F0IGxpbmVhckRlcHRoPWRlcHRoO1xcbiNlbmRpZlxcbiNpZmRlZiBNQU5VQUxfRE9GXFxuZmxvYXQgZm9jYWxQbGFuZT1saW5lYXJEZXB0aC1mb2N1cztmbG9hdCBmYXJEb0Y9KGZvY2FsUGxhbmUtZG9mLnopL2RvZi53O2Zsb2F0IG5lYXJEb0Y9KC1mb2NhbFBsYW5lLWRvZi54KS9kb2YueTtmbG9hdCBibHVyPShmb2NhbFBsYW5lPjAuMCk/ZmFyRG9GOm5lYXJEb0Y7XFxuI2Vsc2VcXG5jb25zdCBmbG9hdCBDSVJDTEVfT0ZfQ09ORlVTSU9OPTAuMDM7ZmxvYXQgZm9jYWxQbGFuZU1NPWZvY3VzKjEwMDAuMDtmbG9hdCBkZXB0aE1NPWxpbmVhckRlcHRoKjEwMDAuMDtmbG9hdCBmb2NhbFBsYW5lPShkZXB0aE1NKmZvY2FsTGVuZ3RoKS8oZGVwdGhNTS1mb2NhbExlbmd0aCk7ZmxvYXQgZmFyRG9GPShmb2NhbFBsYW5lTU0qZm9jYWxMZW5ndGgpLyhmb2NhbFBsYW5lTU0tZm9jYWxMZW5ndGgpO2Zsb2F0IG5lYXJEb0Y9KGZvY2FsUGxhbmVNTS1mb2NhbExlbmd0aCkvKGZvY2FsUGxhbmVNTSpmU3RvcCpDSVJDTEVfT0ZfQ09ORlVTSU9OKTtmbG9hdCBibHVyPWFicyhmb2NhbFBsYW5lLWZhckRvRikqbmVhckRvRjtcXG4jZW5kaWZcXG5jb25zdCBpbnQgTUFYX1JJTkdfU0FNUExFUz1SSU5HU19JTlQqU0FNUExFU19JTlQ7Ymx1cj1jbGFtcChibHVyLDAuMCwxLjApO3ZlYzMgY29sb3I9aW5wdXRDb2xvci5yZ2I7aWYoYmx1cj49MC4wNSl7dmVjMiBibHVyRmFjdG9yPWJsdXIqbWF4Qmx1cip0ZXhlbFNpemU7ZmxvYXQgcz0xLjA7aW50IHJpbmdTYW1wbGVzO2ZvcihpbnQgaT0xO2k8PVJJTkdTX0lOVDtpKyspe3JpbmdTYW1wbGVzPWkqU0FNUExFU19JTlQ7Zm9yKGludCBqPTA7ajxNQVhfUklOR19TQU1QTEVTO2orKyl7aWYoaj49cmluZ1NhbXBsZXMpe2JyZWFrO31zKz1nYXRoZXIoZmxvYXQoaSksZmxvYXQoaiksZmxvYXQocmluZ1NhbXBsZXMpLHV2LGJsdXJGYWN0b3IsYmx1cixjb2xvcik7fX1jb2xvci89czt9XFxuI2lmZGVmIFNIT1dfRk9DVVNcXG5mbG9hdCBlZGdlPTAuMDAyKmxpbmVhckRlcHRoO2Zsb2F0IG09Y2xhbXAoc21vb3Roc3RlcCgwLjAsZWRnZSxibHVyKSwwLjAsMS4wKTtmbG9hdCBlPWNsYW1wKHNtb290aHN0ZXAoMS4wLWVkZ2UsMS4wLGJsdXIpLDAuMCwxLjApO2NvbG9yPW1peChjb2xvcix2ZWMzKDEuMCwwLjUsMC4wKSwoMS4wLW0pKjAuNik7Y29sb3I9bWl4KGNvbG9yLHZlYzMoMC4wLDAuNSwxLjApLCgoMS4wLWUpLSgxLjAtbSkpKjAuMik7XFxuI2VuZGlmXFxub3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvUmVhbGlzdGljQm9rZWhFZmZlY3QuanNcbnZhciBSZWFsaXN0aWNCb2tlaEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYm9rZWggZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2N1cz0xLjBdIC0gVGhlIGZvY3VzIGRpc3RhbmNlIGluIHdvcmxkIHVuaXRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jYWxMZW5ndGg9MjQuMF0gLSBUaGUgZm9jYWwgbGVuZ3RoIG9mIHRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZTdG9wPTAuOV0gLSBUaGUgcmF0aW8gb2YgdGhlIGxlbnMgZm9jYWwgbGVuZ3RoIHRvIHRoZSBkaWFtZXRlciBvZiB0aGUgZW50cmFuY2UgcHVwaWwgKGFwZXJ0dXJlKS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmx1bWluYW5jZVRocmVzaG9sZD0wLjVdIC0gQSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlR2Fpbj0yLjBdIC0gQSBsdW1pbmFuY2UgZ2FpbiBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iaWFzPTAuNV0gLSBBIGJsdXIgYmlhcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyaW5nZT0wLjddIC0gQSBibHVyIG9mZnNldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEJsdXI9MS4wXSAtIFRoZSBtYXhpbXVtIGJsdXIgc3RyZW5ndGguXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmluZ3M9M10gLSBUaGUgbnVtYmVyIG9mIGJsdXIgaXRlcmF0aW9ucy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zYW1wbGVzPTJdIC0gVGhlIGFtb3VudCBvZiBzYW1wbGVzIHRha2VuIHBlciByaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNob3dGb2N1cz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBmb2NhbCBwb2ludCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWQuIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hbnVhbERvRj1mYWxzZV0gLSBFbmFibGVzIG1hbnVhbCBjb250cm9sIG92ZXIgdGhlIGRlcHRoIG9mIGZpZWxkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBlbnRhZ29uPWZhbHNlXSAtIEVuYWJsZXMgcGVudGFnb25hbCBibHVyIHNoYXBlcy4gUmVxdWlyZXMgYSBoaWdoIG51bWJlciBvZiByaW5ncyBhbmQgc2FtcGxlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uLFxuICAgIGZvY3VzID0gMSxcbiAgICBmb2NhbExlbmd0aCA9IDI0LFxuICAgIGZTdG9wID0gMC45LFxuICAgIGx1bWluYW5jZVRocmVzaG9sZCA9IDAuNSxcbiAgICBsdW1pbmFuY2VHYWluID0gMixcbiAgICBiaWFzID0gMC41LFxuICAgIGZyaW5nZSA9IDAuNyxcbiAgICBtYXhCbHVyID0gMSxcbiAgICByaW5ncyA9IDMsXG4gICAgc2FtcGxlcyA9IDIsXG4gICAgc2hvd0ZvY3VzID0gZmFsc2UsXG4gICAgbWFudWFsRG9GID0gZmFsc2UsXG4gICAgcGVudGFnb24gPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIlJlYWxpc3RpY0Jva2VoRWZmZWN0XCIsIHJlYWxpc3RpY19ib2tlaF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OIHwgRWZmZWN0QXR0cmlidXRlLkRFUFRILFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZm9jdXNcIiwgbmV3IFVuaWZvcm00MShmb2N1cyldLFxuICAgICAgICBbXCJmb2NhbExlbmd0aFwiLCBuZXcgVW5pZm9ybTQxKGZvY2FsTGVuZ3RoKV0sXG4gICAgICAgIFtcImZTdG9wXCIsIG5ldyBVbmlmb3JtNDEoZlN0b3ApXSxcbiAgICAgICAgW1wibHVtaW5hbmNlVGhyZXNob2xkXCIsIG5ldyBVbmlmb3JtNDEobHVtaW5hbmNlVGhyZXNob2xkKV0sXG4gICAgICAgIFtcImx1bWluYW5jZUdhaW5cIiwgbmV3IFVuaWZvcm00MShsdW1pbmFuY2VHYWluKV0sXG4gICAgICAgIFtcImJpYXNcIiwgbmV3IFVuaWZvcm00MShiaWFzKV0sXG4gICAgICAgIFtcImZyaW5nZVwiLCBuZXcgVW5pZm9ybTQxKGZyaW5nZSldLFxuICAgICAgICBbXCJtYXhCbHVyXCIsIG5ldyBVbmlmb3JtNDEobWF4Qmx1cildLFxuICAgICAgICBbXCJkb2ZcIiwgbmV3IFVuaWZvcm00MShudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yaW5ncyA9IHJpbmdzO1xuICAgIHRoaXMuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgdGhpcy5zaG93Rm9jdXMgPSBzaG93Rm9jdXM7XG4gICAgdGhpcy5tYW51YWxEb0YgPSBtYW51YWxEb0Y7XG4gICAgdGhpcy5wZW50YWdvbiA9IHBlbnRhZ29uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGJsdXIgaXRlcmF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByaW5ncygpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHRoaXMuZGVmaW5lcy5nZXQoXCJSSU5HU19JTlRcIikpO1xuICB9XG4gIHNldCByaW5ncyh2YWx1ZSkge1xuICAgIGNvbnN0IHIgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiUklOR1NfSU5UXCIsIHIudG9GaXhlZCgwKSk7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlJJTkdTX0ZMT0FUXCIsIHIudG9GaXhlZCgxKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgYmx1ciBzYW1wbGVzIHBlciByaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0aGlzLmRlZmluZXMuZ2V0KFwiU0FNUExFU19JTlRcIikpO1xuICB9XG4gIHNldCBzYW1wbGVzKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQU1QTEVTX0lOVFwiLCBzLnRvRml4ZWQoMCkpO1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQU1QTEVTX0ZMT0FUXCIsIHMudG9GaXhlZCgxKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBmb2NhbCBwb2ludCB3aWxsIGJlIGhpZ2hsaWdodGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBzaG93Rm9jdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJTSE9XX0ZPQ1VTXCIpO1xuICB9XG4gIHNldCBzaG93Rm9jdXModmFsdWUpIHtcbiAgICBpZiAodGhpcy5zaG93Rm9jdXMgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlNIT1dfRk9DVVNcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlNIT1dfRk9DVVNcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBEZXB0aCBvZiBGaWVsZCBzaG91bGQgYmUgY2FsY3VsYXRlZCBtYW51YWxseS5cbiAgICpcbiAgICogSWYgZW5hYmxlZCwgdGhlIERlcHRoIG9mIEZpZWxkIGNhbiBiZSBhZGp1c3RlZCB2aWEgdGhlIGBkb2ZgIHVuaWZvcm0uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IG1hbnVhbERvRigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIk1BTlVBTF9ET0ZcIik7XG4gIH1cbiAgc2V0IG1hbnVhbERvRih2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1hbnVhbERvRiAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiTUFOVUFMX0RPRlwiLCBcIjFcIik7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZG9mXCIpLnZhbHVlID0gbmV3IFZlY3RvcjQ0KDAuMiwgMSwgMC4yLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJNQU5VQUxfRE9GXCIpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmdldChcImRvZlwiKS52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBibHVyIHNoYXBlIHNob3VsZCBiZSBwZW50YWdvbmFsLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBwZW50YWdvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlBFTlRBR09OXCIpO1xuICB9XG4gIHNldCBwZW50YWdvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLnBlbnRhZ29uICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJQRU5UQUdPTlwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiUEVOVEFHT05cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1NjYW5saW5lRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00MiwgVmVjdG9yMiBhcyBWZWN0b3IyMjUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zY2FubGluZXMuZnJhZ1xudmFyIHNjYW5saW5lc19kZWZhdWx0ID0gXCJ1bmlmb3JtIGZsb2F0IGNvdW50O1xcbiNpZmRlZiBTQ1JPTExcXG51bmlmb3JtIGZsb2F0IHNjcm9sbFNwZWVkO1xcbiNlbmRpZlxcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtmbG9hdCB5PXV2Lnk7XFxuI2lmZGVmIFNDUk9MTFxcbnkrPXRpbWUqc2Nyb2xsU3BlZWQ7XFxuI2VuZGlmXFxudmVjMiBzbD12ZWMyKHNpbih5KmNvdW50KSxjb3MoeSpjb3VudCkpO291dHB1dENvbG9yPXZlYzQoc2wueHl4LGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9TY2FubGluZUVmZmVjdC5qc1xudmFyIFNjYW5saW5lRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzY2FubGluZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uT1ZFUkxBWV0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZW5zaXR5PTEuMjVdIC0gVGhlIHNjYW5saW5lIGRlbnNpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY3JvbGxTcGVlZD0wLjBdIC0gVGhlIHNjYW5saW5lIHNjcm9sbCBzcGVlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uT1ZFUkxBWSwgZGVuc2l0eSA9IDEuMjUsIHNjcm9sbFNwZWVkID0gMCB9ID0ge30pIHtcbiAgICBzdXBlcihcIlNjYW5saW5lRWZmZWN0XCIsIHNjYW5saW5lc19kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiY291bnRcIiwgbmV3IFVuaWZvcm00MigwKV0sXG4gICAgICAgIFtcInNjcm9sbFNwZWVkXCIsIG5ldyBVbmlmb3JtNDIoMCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyMjUoKTtcbiAgICB0aGlzLmQgPSBkZW5zaXR5O1xuICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSBzY3JvbGxTcGVlZDtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjYW5saW5lIGRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5kO1xuICB9XG4gIHNldCBkZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5kID0gdmFsdWU7XG4gICAgdGhpcy5zZXRTaXplKHRoaXMucmVzb2x1dGlvbi53aWR0aCwgdGhpcy5yZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICovXG4gIGdldERlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVuc2l0eTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBzY2FubGluZSBkZW5zaXR5LlxuICAgKi9cbiAgc2V0RGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuZGVuc2l0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbmxpbmUgc2Nyb2xsIHNwZWVkLiBEZWZhdWx0IGlzIDAgKGRpc2FibGVkKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY3JvbGxTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzY3JvbGxTcGVlZFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgc2Nyb2xsU3BlZWQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNjcm9sbFNwZWVkXCIpLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5kZWZpbmVzLmRlbGV0ZShcIlNDUk9MTFwiKSkge1xuICAgICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmRlZmluZXMuaGFzKFwiU0NST0xMXCIpKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiU0NST0xMXCIsIFwiMVwiKTtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiY291bnRcIikudmFsdWUgPSBNYXRoLnJvdW5kKGhlaWdodCAqIHRoaXMuZGVuc2l0eSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1Nob2NrV2F2ZUVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtNDMsIFZlY3RvcjIgYXMgVmVjdG9yMjI2LCBWZWN0b3IzIGFzIFZlY3RvcjM1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc2hvY2std2F2ZS5mcmFnXG52YXIgc2hvY2tfd2F2ZV9kZWZhdWx0ID0gXCJ1bmlmb3JtIGJvb2wgYWN0aXZlO3VuaWZvcm0gdmVjMiBjZW50ZXI7dW5pZm9ybSBmbG9hdCB3YXZlU2l6ZTt1bmlmb3JtIGZsb2F0IHJhZGl1czt1bmlmb3JtIGZsb2F0IG1heFJhZGl1czt1bmlmb3JtIGZsb2F0IGFtcGxpdHVkZTt2YXJ5aW5nIGZsb2F0IHZTaXplO3ZvaWQgbWFpblV2KGlub3V0IHZlYzIgdXYpe2lmKGFjdGl2ZSl7dmVjMiBhc3BlY3RDb3JyZWN0aW9uPXZlYzIoYXNwZWN0LDEuMCk7dmVjMiBkaWZmZXJlbmNlPXV2KmFzcGVjdENvcnJlY3Rpb24tY2VudGVyKmFzcGVjdENvcnJlY3Rpb247ZmxvYXQgZGlzdGFuY2U9c3FydChkb3QoZGlmZmVyZW5jZSxkaWZmZXJlbmNlKSkqdlNpemU7aWYoZGlzdGFuY2U+cmFkaXVzKXtpZihkaXN0YW5jZTxyYWRpdXMrd2F2ZVNpemUpe2Zsb2F0IGFuZ2xlPShkaXN0YW5jZS1yYWRpdXMpKlBJMi93YXZlU2l6ZTtmbG9hdCBjb3NTaW49KDEuMC1jb3MoYW5nbGUpKSowLjU7ZmxvYXQgZXh0ZW50PW1heFJhZGl1cyt3YXZlU2l6ZTtmbG9hdCBkZWNheT1tYXgoZXh0ZW50LWRpc3RhbmNlKmRpc3RhbmNlLDAuMCkvZXh0ZW50O3V2LT0oKGNvc1NpbiphbXBsaXR1ZGUqZGlmZmVyZW5jZSkvZGlzdGFuY2UpKmRlY2F5O319fX1cIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zaG9jay13YXZlLnZlcnRcbnZhciBzaG9ja193YXZlX2RlZmF1bHQyID0gXCJ1bmlmb3JtIGZsb2F0IHNpemU7dW5pZm9ybSBmbG9hdCBjYW1lcmFEaXN0YW5jZTt2YXJ5aW5nIGZsb2F0IHZTaXplO3ZvaWQgbWFpblN1cHBvcnQoKXt2U2l6ZT0oMC4xKmNhbWVyYURpc3RhbmNlKS9zaXplO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvU2hvY2tXYXZlRWZmZWN0LmpzXG52YXIgSEFMRl9QSSA9IE1hdGguUEkgKiAwLjU7XG52YXIgdjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjM1KCk7XG52YXIgYWIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjM1KCk7XG52YXIgU2hvY2tXYXZlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzaG9jayB3YXZlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHtWZWN0b3IzfSBbcG9zaXRpb25dIC0gVGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zcGVlZD0yLjBdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJhZGl1cz0xLjBdIC0gVGhlIGV4dGVudCBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndhdmVTaXplPTAuMl0gLSBUaGUgd2F2ZSBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW1wbGl0dWRlPTAuMDVdIC0gVGhlIGRpc3RvcnRpb24gYW1wbGl0dWRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhLCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzNSgpLCB7XG4gICAgc3BlZWQgPSAyLFxuICAgIG1heFJhZGl1cyA9IDEsXG4gICAgd2F2ZVNpemUgPSAwLjIsXG4gICAgYW1wbGl0dWRlID0gMC4wNVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIlNob2NrV2F2ZUVmZmVjdFwiLCBzaG9ja193YXZlX2RlZmF1bHQsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogc2hvY2tfd2F2ZV9kZWZhdWx0MixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImFjdGl2ZVwiLCBuZXcgVW5pZm9ybTQzKGZhbHNlKV0sXG4gICAgICAgIFtcImNlbnRlclwiLCBuZXcgVW5pZm9ybTQzKG5ldyBWZWN0b3IyMjYoMC41LCAwLjUpKV0sXG4gICAgICAgIFtcImNhbWVyYURpc3RhbmNlXCIsIG5ldyBVbmlmb3JtNDMoMSldLFxuICAgICAgICBbXCJzaXplXCIsIG5ldyBVbmlmb3JtNDMoMSldLFxuICAgICAgICBbXCJyYWRpdXNcIiwgbmV3IFVuaWZvcm00Mygtd2F2ZVNpemUpXSxcbiAgICAgICAgW1wibWF4UmFkaXVzXCIsIG5ldyBVbmlmb3JtNDMobWF4UmFkaXVzKV0sXG4gICAgICAgIFtcIndhdmVTaXplXCIsIG5ldyBVbmlmb3JtNDMod2F2ZVNpemUpXSxcbiAgICAgICAgW1wiYW1wbGl0dWRlXCIsIG5ldyBVbmlmb3JtNDMoYW1wbGl0dWRlKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnNjcmVlblBvc2l0aW9uID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJjZW50ZXJcIikudmFsdWU7XG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtcGxpdHVkZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBhbXBsaXR1ZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW1wbGl0dWRlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBhbXBsaXR1ZGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImFtcGxpdHVkZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2F2ZSBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdhdmVTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIndhdmVTaXplXCIpLnZhbHVlO1xuICB9XG4gIHNldCB3YXZlU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwid2F2ZVNpemVcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gcmFkaXVzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1heFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXhSYWRpdXNcIikudmFsdWU7XG4gIH1cbiAgc2V0IG1heFJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWF4UmFkaXVzXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjN9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBwb3NpdGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGVwaWNlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgfVxuICBzZXQgZXBpY2VudGVyKHZhbHVlKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBvc2l0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjN9IFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIGdldFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBvc2l0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdmFsdWUgLSBUaGUgcG9zaXRpb24uXG4gICAqL1xuICBzZXRQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMucG9zaXRpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3BlZWQgb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzcGVlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzcGVlZC5cbiAgICovXG4gIGdldFNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnNwZWVkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzcGVlZCBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNwZWVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzcGVlZC5cbiAgICovXG4gIHNldFNwZWVkKHZhbHVlKSB7XG4gICAgdGhpcy5zcGVlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgc2hvY2sgd2F2ZS5cbiAgICovXG4gIGV4cGxvZGUoKSB7XG4gICAgdGhpcy50aW1lID0gMDtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhY3RpdmVcIikudmFsdWUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICBjb25zdCB1QWN0aXZlID0gdW5pZm9ybXMuZ2V0KFwiYWN0aXZlXCIpO1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY29uc3Qgd2F2ZVNpemUgPSB1bmlmb3Jtcy5nZXQoXCJ3YXZlU2l6ZVwiKS52YWx1ZTtcbiAgICAgIGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbih2Mik7XG4gICAgICBhYi5jb3B5KGNhbWVyYS5wb3NpdGlvbikuc3ViKHBvc2l0aW9uKTtcbiAgICAgIHVBY3RpdmUudmFsdWUgPSB2Mi5hbmdsZVRvKGFiKSA+IEhBTEZfUEk7XG4gICAgICBpZiAodUFjdGl2ZS52YWx1ZSkge1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJjYW1lcmFEaXN0YW5jZVwiKS52YWx1ZSA9IGNhbWVyYS5wb3NpdGlvbi5kaXN0YW5jZVRvKHBvc2l0aW9uKTtcbiAgICAgICAgdjIuY29weShwb3NpdGlvbikucHJvamVjdChjYW1lcmEpO1xuICAgICAgICB0aGlzLnNjcmVlblBvc2l0aW9uLnNldCgodjIueCArIDEpICogMC41LCAodjIueSArIDEpICogMC41KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZSArPSBkZWx0YSAqIHRoaXMuc3BlZWQ7XG4gICAgICBjb25zdCByYWRpdXMgPSB0aGlzLnRpbWUgLSB3YXZlU2l6ZTtcbiAgICAgIHVuaWZvcm1zLmdldChcInJhZGl1c1wiKS52YWx1ZSA9IHJhZGl1cztcbiAgICAgIGlmIChyYWRpdXMgPj0gKHVuaWZvcm1zLmdldChcIm1heFJhZGl1c1wiKS52YWx1ZSArIHdhdmVTaXplKSAqIDIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdUFjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU2VsZWN0aXZlQmxvb21FZmZlY3QuanNcbmltcG9ydCB7XG4gIEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTYsXG4gIENvbG9yIGFzIENvbG9yNyxcbiAgTm90RXF1YWxEZXB0aCBhcyBOb3RFcXVhbERlcHRoMixcbiAgRXF1YWxEZXB0aCBhcyBFcXVhbERlcHRoMixcbiAgUkdCQURlcHRoUGFja2luZyBhcyBSR0JBRGVwdGhQYWNraW5nNSxcbiAgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxOVxufSBmcm9tIFwidGhyZWVcIjtcbnZhciBTZWxlY3RpdmVCbG9vbUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgQmxvb21FZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzZWxlY3RpdmUgYmxvb20gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBtYWluIHNjZW5lLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuIFNlZSB7QGxpbmsgQmxvb21FZmZlY3R9IGZvciBkZXRhaWxzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlcyh0aGlzLmdldEF0dHJpYnV0ZXMoKSB8IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCk7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5kZXB0aFBhc3MgPSBuZXcgRGVwdGhQYXNzKHNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyh0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjcoMCk7XG4gICAgdGhpcy5kZXB0aE1hc2tQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IERlcHRoTWFza01hdGVyaWFsKCkpO1xuICAgIGNvbnN0IGRlcHRoTWFza01hdGVyaWFsID0gdGhpcy5kZXB0aE1hc2tNYXRlcmlhbDtcbiAgICBkZXB0aE1hc2tNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgICBkZXB0aE1hc2tNYXRlcmlhbC5kZXB0aEJ1ZmZlcjEgPSB0aGlzLmRlcHRoUGFzcy50ZXh0dXJlO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmRlcHRoUGFja2luZzEgPSBSR0JBRGVwdGhQYWNraW5nNTtcbiAgICBkZXB0aE1hc2tNYXRlcmlhbC5kZXB0aE1vZGUgPSBFcXVhbERlcHRoMjtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE5KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUubmFtZSA9IFwiQmxvb20uTWFza2VkXCI7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKCk7XG4gICAgdGhpcy5zZWxlY3Rpb24ubGF5ZXIgPSAxMTtcbiAgICB0aGlzLl9pbnZlcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lnbm9yZUJhY2tncm91bmQgPSBmYWxzZTtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5kZXB0aFBhc3MubWFpblNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoTWFza01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlbGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoZSBzZWxlY3Rpb24uXG4gICAqL1xuICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggbWFzayBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoTWFza01hdGVyaWFsfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGRlcHRoTWFza01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmRlcHRoTWFza1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBjb25zaWRlcmVkIGludmVydGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52ZXJ0ZWQ7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5faW52ZXJ0ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoTWFza01hdGVyaWFsLmRlcHRoTW9kZSA9IHZhbHVlID8gTm90RXF1YWxEZXB0aDIgOiBFcXVhbERlcHRoMjtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1hc2sgaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBtYXNrIGlzIGludmVydGVkLlxuICAgKi9cbiAgaXNJbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZlcnRlZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlIG1hc2sgaW52ZXJzaW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIG1hc2sgc2hvdWxkIGJlIGludmVydGVkLlxuICAgKi9cbiAgc2V0SW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLmludmVydGVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBiYWNrZ3JvdW5kIGNvbG9ycyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlnbm9yZUJhY2tncm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lnbm9yZUJhY2tncm91bmQ7XG4gIH1cbiAgc2V0IGlnbm9yZUJhY2tncm91bmQodmFsdWUpIHtcbiAgICB0aGlzLl9pZ25vcmVCYWNrZ3JvdW5kID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5tYXhEZXB0aFN0cmF0ZWd5ID0gdmFsdWUgPyBEZXB0aFRlc3RTdHJhdGVneS5ESVNDQVJEX01BWF9ERVBUSCA6IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYmFja2dyb3VuZCBpcyBkaXNhYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlnbm9yZUJhY2tncm91bmQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgYmFja2dyb3VuZCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzQmFja2dyb3VuZERpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlnbm9yZUJhY2tncm91bmQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGJhY2tncm91bmQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpZ25vcmVCYWNrZ3JvdW5kIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBiYWNrZ3JvdW5kIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIHNldEJhY2tncm91bmREaXNhYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuaWdub3JlQmFja2dyb3VuZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxNikge1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhCdWZmZXIwID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhQYWNraW5nMCA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSB0aGlzLmludmVydGVkO1xuICAgIGxldCByZW5kZXJUYXJnZXQgPSBpbnB1dEJ1ZmZlcjtcbiAgICBpZiAodGhpcy5pZ25vcmVCYWNrZ3JvdW5kIHx8ICFpbnZlcnRlZCB8fCBzZWxlY3Rpb24uc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2s7XG4gICAgICBjYW1lcmEubGF5ZXJzLnNldChzZWxlY3Rpb24ubGF5ZXIpO1xuICAgICAgdGhpcy5kZXB0aFBhc3MucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIGNhbWVyYS5sYXllcnMubWFzayA9IG1hc2s7XG4gICAgICByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldE1hc2tlZDtcbiAgICAgIHRoaXMuY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0KTtcbiAgICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCByZW5kZXJUYXJnZXQpO1xuICAgIH1cbiAgICBzdXBlci51cGRhdGUocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgZGVsdGFUaW1lKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHN1cGVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRlcHRoUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHN1cGVyLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuY2xlYXJQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZGVwdGhQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICBpZiAocmVuZGVyZXIuY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5MT0dfREVQVEggPSBcIjFcIjtcbiAgICB9XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAoZ2V0T3V0cHV0Q29sb3JTcGFjZShyZW5kZXJlcikgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1NlcGlhRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00NCwgVmVjdG9yMyBhcyBWZWN0b3IzNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NlcGlhLmZyYWdcbnZhciBzZXBpYV9kZWZhdWx0ID0gXCJ1bmlmb3JtIHZlYzMgd2VpZ2h0c1I7dW5pZm9ybSB2ZWMzIHdlaWdodHNHO3VuaWZvcm0gdmVjMyB3ZWlnaHRzQjt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBjb2xvcj12ZWMzKGRvdChpbnB1dENvbG9yLnJnYix3ZWlnaHRzUiksZG90KGlucHV0Q29sb3IucmdiLHdlaWdodHNHKSxkb3QoaW5wdXRDb2xvci5yZ2Isd2VpZ2h0c0IpKTtvdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9TZXBpYUVmZmVjdC5qc1xudmFyIFNlcGlhRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzZXBpYSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmludGVuc2l0eT0xLjBdIC0gVGhlIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uLCBpbnRlbnNpdHkgPSAxIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU2VwaWFFZmZlY3RcIiwgc2VwaWFfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIndlaWdodHNSXCIsIG5ldyBVbmlmb3JtNDQobmV3IFZlY3RvcjM2KDAuMzkzLCAwLjc2OSwgMC4xODkpKV0sXG4gICAgICAgIFtcIndlaWdodHNHXCIsIG5ldyBVbmlmb3JtNDQobmV3IFZlY3RvcjM2KDAuMzQ5LCAwLjY4NiwgMC4xNjgpKV0sXG4gICAgICAgIFtcIndlaWdodHNCXCIsIG5ldyBVbmlmb3JtNDQobmV3IFZlY3RvcjM2KDAuMjcyLCAwLjUzNCwgMC4xMzEpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibGVuZE1vZGUub3BhY2l0eSBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibGVuZE1vZGUub3BhY2l0eS52YWx1ZTtcbiAgfVxuICBzZXQgaW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5ibGVuZE1vZGUub3BhY2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNlcGlhIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kTW9kZS5vcGFjaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIGdldEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlbnNpdHk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlcGlhIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kTW9kZS5vcGFjaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBzZXRJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmludGVuc2l0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0cyBmb3IgdGhlIHJlZCBjaGFubmVsLiBEZWZhdWx0IGlzIGAoMC4zOTMsIDAuNzY5LCAwLjE4OSlgLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yM31cbiAgICovXG4gIGdldCB3ZWlnaHRzUigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ3ZWlnaHRzUlwiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdlaWdodHMgZm9yIHRoZSBncmVlbiBjaGFubmVsLiBEZWZhdWx0IGlzIGAoMC4zNDksIDAuNjg2LCAwLjE2OClgLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yM31cbiAgICovXG4gIGdldCB3ZWlnaHRzRygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ3ZWlnaHRzR1wiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdlaWdodHMgZm9yIHRoZSBibHVlIGNoYW5uZWwuIERlZmF1bHQgaXMgYCgwLjI3MiwgMC41MzQsIDAuMTMxKWAuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IzfVxuICAgKi9cbiAgZ2V0IHdlaWdodHNCKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIndlaWdodHNCXCIpLnZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9TTUFBRWZmZWN0LmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE3LFxuICBDb2xvciBhcyBDb2xvcjgsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXI1LFxuICBMb2FkaW5nTWFuYWdlciBhcyBMb2FkaW5nTWFuYWdlcjIsXG4gIE5lYXJlc3RGaWx0ZXIgYXMgTmVhcmVzdEZpbHRlcjgsXG4gIFRleHR1cmUgYXMgVGV4dHVyZTMsXG4gIFVuaWZvcm0gYXMgVW5pZm9ybTQ1LFxuICBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDIwXG59IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9zZWFyY2hJbWFnZURhdGFVUkwuanNcbnZhciBzZWFyY2hJbWFnZURhdGFVUkxfZGVmYXVsdCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUFRQ0FZQUFBQ201M2twQUFBQWVFbEVRVlJZUisyWFN3cUFNQXhFSjE2OGVQRXF3UlNLaElJaXVIakpxaVUwZ1dFKzFDUWRBcGNWQU1VQXVBUmFNR0NYMU1JTC9PdzEzKys5bFcyczNtVzlNV3ZzbldjLzJmdkd5Z3dQQU40RThRekFBNENYQUI2QUhqRzRKVEhZSTFleTNwY3g2RkhuRWZoTERPSUJLQW1VQks2L0FOVURUbFJPWEFIZDlFQzFBQUFBQUVsRlRrU3VRbUNDXCI7XG5cbi8vIHNyYy90ZXh0dXJlcy9zbWFhL2FyZWFJbWFnZURhdGFVUkwuanNcbnZhciBhcmVhSW1hZ2VEYXRhVVJMX2RlZmF1bHQgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBS0FBQUFJd0NBWUFBQUFCTm1CSEFBQWdBRWxFUVZSNFh1eTlDYmhsVjFrdE92YnBxMDlEa2lJa1VCSTZreEFTSUgwRGxBUWlJSzF3UmZTSlR4K2k0Slg3dktJaWdzOEhYcFh2cVZjdnJjQzlhZ1E3SURUU1NXZ3FDUVFsaURSQkpLa2toRFNrcVZQTnFWT25QKzhiLy9ySDNQK2VaKzE5OXRsem5WVGx2VnJmdDcrMVQ3T2F1ZVpZNDIvbTM3UUFMS05rMndIZzFwSVRsQjE3bUMrUHAxMVczWC9MSHlUMzJ2aGc0OC81U092K1Bud3BzSEE3MEpvR2x1ZUIxaUtBcGVxenZPem40NEdhdFRCNzZYemhkN3N1QlI3K1dXQURnREVBd3dDRy9MNTRiL3BvRExySHV2dm03MFoyQXZoc2MrUFZjeHNjQlU4RjhDOEFEZzUraXBJakQvUGxHd2ZnanU4QjkyNEU1c2VBUlVmTHNpTm1xUVcwSWpMOCs3TDJOWUQvN0NPQnpmY0NtK2FCOFNWZ2RBa1lJUkNYS3lEYXg0RWRBYW5MNVB1TlBsbE52WERsQUh3RmdQOEFjQzJBaFJJb0RYYnNZYjQ4ZGw1V2tWRlRFM0xHRGNDOW00Q1pDV0J1RkZnZUFaYUdBWUpRUUNScURIVCtNY0pyVmI4endBVFVYSDAyTUhZZk1IRUlHRnNBeGdqQXBRcUFDWVFPUmp0ZC9CN0F4dC96NzlzQzArY01QZ2pqbHdQd1Z3SGNBK0RmQUh6VHhjVmdXQnJvcU1OOCtjWUJlTTcxd0gwVHdLRXhZSFlVV0NJQUhZUkxUbGtDWWdjSUJjQWdVL24zcXk4R1J1NEhSZ25BT1dCa0VSaGRkUEFKaEdKREJ4a3Z3N2NxaW1yK3pGTS9aTG5aRjY0Y2dMOEJZRCtBV3dCOHgvZGxXdVdhZ0hpWUw5ODRBSi8wUldCeTFBRTRBaXp5TTF5eFlBY1RpZ1c1NXhNYkFreEVpd0Vka0ovWkNReFBBaU9IZ0JFQ2NLRUM0VEJaY0trU3YrbVRpZU5jTlBOQzI2bUxOc2o0NVFEOExRRFRBTzRHY0p0LzdpdzJiZm9HNFdHK3ZBR3dtOUV4aUVnNjl6cGcvd2d3UFFMTWpnQUx6bjRFNGFJem9KalE5ZzQwMjR1eWdraitweXVBb1gwVkFJZm5nT0g1TmdDSE1oQW04U3YyeTNYRFplQmhOSXA4T3pKRThPc0J6QUtZQkhBWGdEdDgvNE8rTVZUMGo0ZjU4bzBEOFB4cmdmM0R3TXdJTUVQUUVZUmtOd2Znc3V1RFpMc2tpcDBObzBnV01ELzlIR0RvQURBa0FDNEF3L3dzQWdaQWdzMlowQUJJMEdVNklWbUt2K2YyOEtEbkh4a0EvRzBBOHk2RzczTjlrT0NqWG5oL0ViYjZPdmd3WDc1eEFGNXdMVEExVklIUEFEZ01MRGo0eUlBNUFBbTZhQ1VudjRvejQ2ZWVEd3hOQVVNendKQXo0QkFCU05ERlR3U2ZnN0RES0hFMjNNRzVQcUlZOEExdS9kSU5zOWRCZHk4QWduR1BNMk5mVUJyc253N3o1UnNINElYWEFBY0p2aUZnbHVBYnlnQklOblNMV09Bakd4SjRwZ09LRFYwdi9PU0xLcDhpR1hCb3ZoTEJCT0NRTTJBQ29UT2huWXJBZEl0WWJDaWo1SkZ6UnlJQXFSY2NBbkRBUVVqZzZVTlE3aHNNWFAwY1JRQWV4c3MzRHNDTENFQ0NMd0NRek1jUHdVaTJNd0FTY0FLYmZuWS9ZUkxGUThESFgrSUFKQU1TZkRrQUYxM2tMdmxlSWpoalFRSHhVVlMzampnR3BLZWVOellWUUVqZ1VTOGsrUGdoT05kaEl3QVA0K1hYQllDSEtJSmJ3SnlEVGdhSUFkQ0JKeDNRMk04dFlBSFA5bTRkZi95bFFPc1EwSnF0UkxDeDMwSzF3dExCZ2dTY1FPZ3NLQkdjV0hBSmVPd1JDMEJTTTFtUUlLUmJoaCtCajk4SlFQNnQ0VTBBUEV5WFh4Y0FFbnhrUUFGd29WVXhJRDlrdlFnK2MxQzd2aWRSYklEa2MyNEIvL2hUUUd1bURjQ1dBNURnTXhBU2ROSUZCVUk1cENNTDh2OEFQSTV6ZkVReDRCdWRncWljenZpU25KaFF3Q1A0Qk1DR2wrd084K1U3QUppL1c0TzRZUzYrcG1LLzJjaUFEc0FPQmhUSUlpQUpuUEI3QXZOalArMEFuQU5hWWtBSFgySkJBYyt0WWFKWE9xQlp2MjRWYzM4NlhXNWR0a0hHVys0SEZBSm9ucE9lK1lZUVpBU2hnS2p2M1BOdlBRYXhWb0k4ekpkZkZ3QVNmUHpNVXdTM0t0MXYwVUZJbG9zNm9ERmRBR0ZjbGlNQVAvcnlBRUFHTndRUm5ET2dMYmRsSUV3cklzNkFaL1Fna01NSFFGNlpBS1FjSkFzU1lQd0llQUlrOXdKZ29QSzFnaTcrUHdGNEdDL2ZPQUF2SVFQU3MwVVJUUEJKL1BwM0dTRUdSSGZCQ0lRMHhvd0J0VWJjQWo3eXM1WDRKZnUxSElBR1FySWdRUlhFc0FGUUlPUkRGaGlEWS9yTUhtclU0UVVnUjA4QWtnVWpDQVc2Q0Q2Q2t3QnNBSVFDNEdHNmZQTUEzT1hpTnpDZzJJOWdOQ01rc21BQW9lbUR6b2ltRndMNDhNODVBS2tpdVFWTUFBcDhDWVJSREF0OEdRaUo2N042R0pPREFYQUhsc0dndXNjQTJBSmcxSVBHWW14T3BCeEZXa1JOOUxzQVRnSXdYbk5zL3YvNXovOVhDZjhCTzNZQXR4YmMvNDYvS0R0KzUrZWExWWt1MlZVeEh6L3owdjI0RndNR0sxZ1dzSzJPVVV4SEhkQ0JlUlVCNk94SEFCcjRaSUNJQmQwUVdTRitYUmRNVEFqZ0NkVHJHOWNCTndFNEY4Q3BEa0lDeVlMR3N1aEZ0NnpzK2dJU3dVZW44ekVBamdNdzRjZngySDZPLzkweUFGbzg0Q2JnNElEMy85VGZMVHQrNStlYm5SQUJrT0RqeDBTd1BpNWVjL0ZyWXBtcVNBeE04RG42MENzcUFGSTZHZmhxQU1pREUvZ29rbXZFcjBDNFBnRGtCUW00MHdFOHpNRkVVREtFVm94SU1MbC9LUzczbUU3SDlkK3ZjS0hRUWNqd1cwWXU5blA4bThzQW1PSUJ1V1k2d1AyLzRzMGV6ampnOFR1dmFSNkFCSjcwdnhVQXBHcm03RWJHRStpNDcyQkFCK1dIZnFIUy9lb0FhRXdZMkU5K3dMU1hUcWhJN0NYZ25CNkxDb09KNEJpU1QraFRuRzBIY0N3QWdsQ3gzQVJvWkVWRlhuQlBwL08vQS9oWEFDYzdDUHM5L2kxbEFPeUlCK1JEWCtQOS8rcGJRampqQU1mdi9QTDZBRkRzMXdGQWdzLzlmZ0tmZ2RFL1pFcHVpUWxid0FkZTZRQU1CZ2lSbXNTd0E5QlkwSmZqb3ZHUkRCTUg0VGxjWEdoY0JPYzZIa0YwZ2pQaFpnY2h4VExaTUFjaS8wNFcvQjZBYjN0MDlFUFhjUHlmbGdGd1JUd2dKMk1OOS84YmY1cUZNNjd4K0IvYVc0WFF6NDJGZUwwWXJSeWlrenRVRncwNzA0bWY5a1hneGhPQXFjM0FBc1B5Unh4UUNzL1BkWE9GWTBXMUtIeTNRSVVHdHgrNnZkbngxdnNCK2RzVG5jbTJBb2dnbEZnVkVBbFVXck9NQjJSeUVtTUNHUS9ZNy9IdktuczZ0ZkdBbkpRK3IvOWI3Nm9KWjF6RDhXZHlRallCaDhhQmhWRUhqRUxvdVE4dWtRN1ZSU0NKQUFMd2tyK3NBTGhuR3pERDNKQUpZSkhnOXVob2k0Yng4eXRrV1V0dkhULzcrWmM0ZHcxdVozNjEyZkgyZGtRZjd5eElFRW9ja3drSlFuNElRb3E4dW5oQWhtUFJLS0Z4MHV2NEs4dWVUczk0d0Q3dS8vVlg5Z2huN09QNGMrNEc3aDhIcHNlQitkRjJBS2xGTHd1QUlaOGpENk5Qck9oQWZmbWZBOS9aQnV6WkNreVJXU2VxQkNXeW9ZR1E1eVFyQnBEYnVtL01FMUhvUG8wWEVrU0QyemxmYm5hOHE2K0VVSmNUQ3hLRXRITDVFUWpQNkJFUHlJZ1lBWkJ2WXQzeEh5eDdPcXZHQTY1eS83Lzl3VlhDR1ZjNS9zbDdxeEQ2NmRFcWlZZ1J6QXFoTjFBNENCTkFBbER5QUZJK2laOS9OM0RMSnVDK2pjRFVCbUNXeVVuT3JtVFlDTUlPa05jbExnMEI4L1JzTkxnOStVdk5qbmQxQVBMbW1RcEZIeUVCUk91V0FDUVQ4bk4rSC9HQXZZNy9WTm5UNlNzZXNNZjEzL0NwYWhHblp6aGpqK1BQbXdYMk1ZZERJZlFleFd5QkF3RVVPUURyUkROLzk4cDNBN2R2QU82ZkFBNXNxSEpEQkVBeW9VVkdrd0VkNkhSMTJYVTRrd3pmbDZmQ1hUWnpqeTU3dnZuUjUxM1g3SGo3QXlEdmdnQVVpOUV5RmdpWnFOeFBRRjYzNDVuT1diRDFIUS9ZNWZwdnVMYS8yKzgyL3ZOSGdBUERGUURuaG9GNWoyQzJxQldDSThidzFlUnc1Q0w1bDk0TDNERU9USTREQjhZOU9XbXNFdS96QkozcmdzYXlicUJvYi83QTRDN2p0V2Nvb1JyY3pyK3UyZkgyRDBBT1FnQVVDeEtFUDdhR2dMeTY0K202S2RqV0ZBOVljLzAzL09zYTRnbHJqcitBdXBxSHoxc0VzMGN4RzBCQzlISWVQTG9pdDllTmtWZjlMK0R1VVdCeURKZ2FxNHliR1lMUEFXZ2lYbUxlZFVFN2R3QzdzYUw3Q3FmUEtYaTROWWRheWtDRDQxMGJBSGxERXNOaXdaOXdBUFlia0pjZno2VDJnbTNOOFlEWjlkL3dIeFVBKzczOWZQd1hQclNLWUdiK0J1UDNqQUZERWxGSDlISVd3YnpDSUdrQnIvb3I0SjRSWU84b01PVzZaVmNBdXZpMUNnb2hhMDRCQ3dUNWdmTUtIbTdOb1JkZTIreDQxdzVBM2hRWmtBRGs1K2NHaUFlTXgzKy83QUVORkE4WXJ2L0c3MWNBWEZNNFl6aitvdE9BYVFMUUEwZ1p4YUlJWnRNREZUaWdLSlY4SDlJcTZhWjU5WlhBdlNQQXZwRUtnQlR0Qk9EY1NDV0NaZVJZdHB6cm1MeWVHTkNBeUZsMXYrSGVpOHFlYjM3MFJkYzJPOTdCQU1pN0VnQi8yUUc0MW5oQUhVOUx1V0FiT0I3UXIvL0dQUlVBMTNyN0d2OUZad0lNb1ZjRXN3RXdmRG9pbUVQMHNoS0t0SXBoYVpRQVh2MStZTSt3QTNERWRjdlJLa0dKQURRUUVzUXVoaTFUanQ5NXZCc2g1bngySU81OVNzSERyVG1VT1N0TmpuZHdBQXFFcnkwSXlDTUlDa095aXVJQk53QnZQRlFRVDdnQnVQamM5b1JZQUlIeU9FTDR2SUZFWVZOYU9vdTV2Q0dFL3RWL0Ewd09WY25wekk0N05PcmkzUUZJQnBTZWFTRFVkWUxPU1d2WUltU0dnZnRwSkRhNE1XSmJBR3hpdkdVQTVNQU9jMEJlNmVWTGo3LzRNaytoekNPWVBZcFpEQmlOa0xoK0cvTTN5Rnl2L2x0Z0wzVzNZUWZnY0ZVaGdSWTJQd1krWjcvRWhBUjFTRnlYQ09iNTdyMjhRZlFCc0pRQk1uNUQ0eTBIWUxQamU5Q2Q3UklDMFBNM0VpTW9mRjRnVkNCcDFQODQwaXgvZ3l6NTZyK3ZBTWprOUdsMzc1aUI0K0N6dmV1WmRMa2tFUEo4WkVmWC82Ujczdk9qelQ1U2k5aHVjTHhIQVZnNFB3SmdSd2g5Q0tPWEs4WUE0WkVxS1pYU1FXaDVQKzVBZnRYZkEvdUdLdllqQ0tuNzJjY3RiRnJaTkVDa2E1TDVDUHdJUHRNSDNUVnoxN01MQjVnZExnQTJOZDZqQUN5Y0h3TFF4RkVVU1I1QVN2QVJEQjBoOUFRYjliWElnQ0drNmxVZkFQWVRnRVBBSVRLZ2cxQk9iazU4c3JUSmdHNThXTWtXTWFBYlFRVDFuYzhySEdBTkFKc2M3MUVBRnM0UEFhZ1Flc3RnQzFsc0JKNEJNQ1NPSzZkRFVjd3FxYUZpUXIvMFFlQUFBZGp5K2pCaVFRZWVNU0JaVDNuQ1BVRElhOXorL01JQjFnQ3d5ZkVlQldEaC9CQ0FlUVN6Z2tqRmZHTEJCRDVueFE0RHhOMHd2M2hWeFg1VEJHRHdMNW9ieHZWQTVZcVlMNUJlTUxkNjZZWXhKcFJCMGdLKzk2TENBZFlBc01ueEhnVmc0ZndJZ01yaFVQS1EyQytCejBQbUJUcUJNUWVoQWJEbElqajRGODBLSmd1U1ZaMEZ1WHBqb0NPZ1hhd0xqQUxoYlQ5ZU9NQXVBR3hxdkVjQldEZy9sMUlFMDVFZDB5Z1pueUhkejBWd0NxRVBJZk55eDBRUXZ2TERGUUNwKzhuZlprNXVuZDh0WHdJZ1djSFNOWDBOMkNKbW5BbDN2NlJ3Z05uaGwxN1Q3SGlQQXJCd2ZnaEFTN21WL2hleTJKUzlGdk0zQkxwVVVpMVl3RFJNWHZrUllKb0FsQWgybDBkY1owNHM2SlVURElqeUJjcmw0eURjL2RMQ0FkWUFzTW54SGdWZzRmeHdLVndKZ0dFSk5tV3R4cFFNcFg5b24yZVJoVkErTzU2QWpNZm5QK2UzWHZmM053RzR4SVBUbGVpWTU1YnBHaDZVYmFmTlUwbDB6MHArNUpoNUhxWUo2YjUxblA2WFA4Y3gxMlhOSFFWZ0lRQi9iRlBWZzJPQzdRK1dnVkZXbmcvRnZ0V0xJMDZ1V2g1b2d1S0VjWFZTLzlzRUFGLy9WR0Q3dDRFVERnSmJGNENOaThDR1pXQnMyZlBML0g2VndwMktFdFZrNGZKK3YvRUlZUE45d0thNXF1K0luY2ZQd1hIVlplL2FPTDNFYndTN3h2OEExclF2bk8wajhQQXJUZ1RHWjRCeEZ2OW1JeGhPQ0dzdiswT1BZRFJnaGNMZmtXa0V1cTArRzAweDRPdGZER3orZDJEYkhtRExqTDhzaThBWVAvN0NHSUFpRUVNVEc5MnpYcVNiSCtkOVIyYUEwWG52TytKanRoaUlyT1ZESEhQT2tCcnpVUUFXQVBzWnAzb1BEcGEvWGFnNkVWa0xCSys1ckFuSkMzL25Zay9BUEQ3MDRXaUVBVjhPVEh3WDJMUUgyRGdGYkpnRk5yQmhqZDhyNzlkZUdvRXdzbGxnTkJPenk4Q2Rqd2VHOXdCajA4QUlBY2kyRDZIYWZteUFrNC9aN1NKNzJoR1lSd0ZZQU1ETFR3T0dwNEZSRmdEM0hoenFSR1FpeWV1cnFPZEc2cjBSbThJRVpqelJsa2lxQ1dvRWdLOEF4bTRCSnU0SEpoeUFiRmhEeG1iREduWk80ajBTZ0xHRGtwaWJnRXE2NlRKdy8xbkEwRjVnZExwcSt6RHFGZmQ1TE1lV3F1NUhOU1QwdUpPSWxsZytxZ01XZ0krSFB2MHh3TEEzZ1dIcFcyc0M0NDFnQ0VDYm1LemlhR3JuVWRNTzRhSGVoNk14QVA0U01ISTdNTDRIR0Q4QWpIdkhKR05BZ3BEZ1kvY2szc3RpcFJlbXZWaGMrdUFTTVBVRVlHaC85ZElSZ0d4OFkrTU5iUi8wMHVWdEgwd0V4OTRqL3Ywb0F4YUE4RWQrR0JpZUFZWlpnNWtBREMwUVdHT0Z6R0psY0dQemwxQnhOTFhEOHNrNHhmdHdOQWJBL3d3TTN3R01VbXhPT1FCbkhYemV0SVl2aWJvbm1TaXVZVE5qcmlWZzdnbEFpd0JrMGZOWkg2K1BtWDlQNmtmTm1DWEdwZnRKN1RnS3dCSUFubG4xNEJBQVl4TVltNUM2UmpDeUNvT3lyMHFrRC9jK0hJMEI4RFhBOE4zQXlDUXdlc0QxVlFLSDdFY0FTbTFRK3k0Q2tOOXBVS2lWRjVuTHZ5K2ZCYlRVZDhRQmFIMUh2TkJST2ladmZzTm5yRjRrY3ZQd3Bkc0JMQmVVMThOZjdBQjIzRHA0ZWNIQzhvQmdVbEpKZWNMUys3K1dPcEUzZ2JFK0hLdyt5b2V2Q1lrTUdLcVBKcmRFS0FSdXRhRllSczFmaUVaMHdQOENETjhMRE84RlJxWXEzVzEwcGdLZ2ZZTGFZQ3pvb3RnQTZLWGFUQTkweTM3NFRLQjFzQm96eTc3eEhGWjUzNnV0UmdBbUVhdzZnNWtVU0Zad1NYbkEzMzBxc09sZmdITVBEbFplc0xBOElPam9MeXBQV0hqLzExRW5DaVZ3a3o3a0FFeHRzR3JhWVVXZFNEWDVUbXNhZ0w4S0RCR0E3QmQzMEpzVzBvV2l2bkVPUU5QN3lHVFNCUjEwMUFsWlNVdEd5ZmdaRGtDV1kxSG5KZGNCVmU2MzI1aFR2ZWxnMkNRalpORHlnRy8yQW4wajF3S25MNnk5dkdCaGVVQzhwclE4WWVIOVgzOU9WUVNjN01jNmZDYUt2QWVIZENJVmY0eU1ZQ3luVHBYK25iOTdOSm1sU1FiOHI4RFFIbTlZT0ZVWlRLT3pvWEdoczZBeEYwSElleGNMQnZXQnVpSE44czJuZTk4UjNxYzZMNFZ5YjJvQlZqZm05TUlGSGJqRENoNmtQT0JiUW9HK29XOENPNWJXVmw2d3NEd2dmcjIwUEdIaC9YLzFpYUVJdURjQ1RJVy8xUTRyRnY4T25ZaVczYytXMmlLd1VqS2J5alFOd0wxdXVSNnNBRWdEZ3ExYnJYT21WODFQeGhOQjZEVURCU1l6UUp3RnR6NjIzWGNrdFgxUTFWV0thVEYvelpoVmF6QlZZQTF0WDVNYXpzR3ZvYndlL2pRcjBOZTZCVGg1dWYveWdvWGxBZkc2MHZLRWhmZi9yU2UxaTREblRXRFVBQ1kxZ3VGVERxTFlkQ0J2ZjZESllTTVlBVEJmT3gxa0xmajF2MWF4SDEwblEzU2QwR1VrQm5UZnBlbXRCSmdzZUlLUUFITFFjVnhhMlRudU1XMEFxdWk1ZXM4eEJJZWdWZFZWRThWaHpIbkxoNjVXTUI5QW4rWDE4SzZhQW4ydE80RVRsNnZxYkt1VkZ5d3NEd2hldnFnOFllSDkzL1JrNzBKRTkwbm93eFpiSUpqdlMzV1lOU0dVd0dISlRwUHh3d2NiQnVCcmdSWUJlS0FDbjdWdHBkVXUvYzBOSnhPOUJJeGNLdTRUVE9EemJrb25QTG9hTDB2eVVRUmIyeThIc0wxY2tmV3pNZXVGaTQwUWV6cWkreWlQaHl0N0ZPanI2L2dDRndnUDdYYjV2c3NURnQ3L25RUmc2TUdSV21EUm9leVRscGd3NjhHUlR3Z1pnbzFnR21YQVg2LzhkdGF5bFNLWS9rb3lJRDlCaHpNTDNxMWdBb3MyQWNPclpZU29xL3BKcDFWdE9EUm05WjNMUy83V2pWa3ZYT3pFdE9wS3lHcmxBVCs0U29HK1ZZOHZCR0N2eS9kVm5yRHcvdmVlNjVOQkppQWpCSVZjQUpRak9tK0RrQ1pFZWlHQU13NnNBd0Rac0pyQWRoRk05clBHaGQ0OTA0Q281b1Z1Q1pQVjZrRDQwRWM2KzlXOGRCVEJzZmRjM25rcHZuQjgyZnAyUlBjczc5ZEhnYjUxTEE5b2ZzRFY2dnV0NS8zUG54Y0FtTFZCaURxZ2V2RGFKTGtZcnB1UXh6Y053TjhBV2dJZ1JiQjhsb0VCelhEd2w0Y0dpREdmdDU4U0NPV0dlZGdqdk9KK2JQdmdSa2l1QStaanpoblFRT2lGTlZibG9hN2wvZm9zMExkTzVRRU5nRVhsQ2ZzOFFiZjdIeU1BM1FWallpaFloTEVOZ2pYOXkvcXd4UW1SVS9hc2ZkMFpjTFUyQ0hWR3l1c0pRTEtmVmk5OENTMTJUNWY3aUVDa0hwc01rQWhDRjgrbnNoV0gySS9qWHNPWU8xNDRHVi85QXBBSXJTM3Z0NFlDZmV0UUh0QUEyRysvNFBXNC8yUFBiek1nbVVNaTJOb2VTQ1J4SXQyL0Z2dXhXVVJJV0NYZzM1N2dmVGpFRE5JSG5UUlhSQ3BINXVnS3dHbDNIcE1CWFFjMHY2V0xZVm0vNWxpbWowNHJHNzYySzJ1WVk5akJrcjkrckkwM05MNVpiY3pTL2RKK0xReW9nYTRvNzdmR0FuME5sd2RNQU95M3ZsL1Q5MzhLQWNqMTIxejhCbitZOWVXUUpSejhZNmtOYWdEaDJleTVFdnhqeFFEOFRXZEF1bmVDQ080QW4xdnc1dmR6UU1tZGt0d3E3cExaUVIrZE0zNCtadW1BeHZZMVkwNHVxT0FKNkZzRXh6ZXRvN3pmQUFYNkdpd1BhTFdSMWxyZnI4bjdmL1JsM1FHem1zaXMrL3VPNzFWOU9GZ1AyZ3BQaGdyN1RHUnFSVVQ2ZHl2cjRhSXMvcG0vMnpWVU5iQlN2Nkc4ZTVwRXYwQ3ZlYzdQbzcrYlR0amxCUmxrdkFNQmtEZVF5dnNOV0tDdm9mS0FDWUJycmUvWDFQMC9vV0VBbm5GRDFZZGpodFh4UjczbVgxMEZmQ0hIRTlwVldjR0FJL1MwZ0tzZkEyeSt0d3JGWnc2SHhmL0YwUGs4Umkva3BHU25NdUR4NVQwaUFDZ1FIaW9vME5kQWVjQlVIVzZRZHNWMi9jTDd2L0N5cXI1Z25jNDJDQ09jZlgxVklaL1Y4V2U5SURtVHpWWHdQREppWHVLWFB4dERCbWE4K2x6UDRXQWdLa1B4Q1VBUEU0djVHekV1TVgwUFlKUExoQjZGSnNjN01BTW1rVnhhWUMvSzlnRytGMSsrOEFRN0d3YmdrNzhJN0dGcFhnSXdGaVJYT3dhSlpQVWJpUjB5Q1VEUmsrY0hmK1lwd01qOUhnZkk4Q2xHUHl2c1NpSDBXU0tSdVlsaXRMYi96SE0vSk9TczVDL1lJQzljTVFEWnIvZHd4Z09XOWd0R1lVQmkwd0E4bDMwNHZEUXZBY2hpbEZicElCUWhaN0VqcTZaUTAvWWhpbDh5NGo4OUF4aWU5REFzRDZGWDlIT0szUXRST1RGa3ZpTjgza0c0ZmVsSVk4RENlTHJTZU1EU2ZzRW92QUVDVUZzVGpIRCt0Y0IrdGtGZ2NYS3ZCUmlyN3F0Rmw5b3dtTzRYeS8xRzNiQUZmUHJaSG9yRk5XQkZ3SGpRQUZjdElnaGoya0JhcncwNklmLytNTTlacVRONkRnc0RvakNlcmpRZXNMUmZNQXB2b0drQVdoOE9iL3RnQVBTS1dDcDhuZ05RdGFkam1UZGx0dk52bjNwZUZZaGdRUWdoK2lVbUVhVUFVb1hNMXlSTG1XdUZMYUU5WitYSUFXQmhQRjFwUEdCcHYyQVUza0RUQUx6d21xbzZxdFZoOWtKRXJBdWRBQmlhMzhUQzV3SmdTMnhJaEF3Qm4zeWhCeUw0RWh6WGZSWHhZc0RUSjRJdnJOTjJKRk14WmNCelZvNGNBQmJHMDVYR0E1YjJDMGJoRFRRTlFMWkJZSDFBVnNRU0FBVStpbUkxb2JIeWJsbmpHL2tKazNVOEJIejh4VlVRQWhuUUlsNUN5TmdLQUdwNUxLU1NDb0F5U2g1Smo3OXZUYWdjeFVhSUJlUk5lNzlnOWdxK0RYaWc0d0d6eStQT05mVDdSV0ZBNG5vQWtHWFpWQWhjQmNrSlFnTmdyTGlhTmIzcGFJRG8xdkhIWCtvQTlMUUJpNER4SmNPVVBKVW5UZ1UyTkpVeVJPczhpckdBUnhRQUMrUHBDdHNGZDQwSC9BRWYwZ01Ra0xnZUFDVDQxUGlHb0xPS3F5ckpxM0svWWE5bU55cjVGdXNOL3VQTFBJZURhOEJjK3czcnR5bDRWRkhhTVpjM2k5UldCTTlqanpnQUZzYlRGYllMUm1tL1lCVGVRTk1BdEQ0Y0JLRFhCVFFHZEFCMk1HQm84U0NMbUV1UzFBRlZBSjNBL05oUHQwUG9DY0E4YlNERzc2WEk3YXlTZzZKWXVHZkt3SkhGZ0gwRTVCM3VlTUNlL1k0TCt4VkhBT1orOUVIY0VnUWd3YmVpRVl4Nmp3VGR6NHFmdTdFaEVKcXhHcXJ1Zi9SbkhJQUVueGd3Qk0wYUM4YVVBWVdOQlJDbW9JbGw0SFRxTzEyMlFjWmJyZ01XeHRNVnRndnVPeDZ3YTcvandodG9Hb0RXaDRNQkoxNldONGxmcjhBcUkwVFZWMU8xZmE5QmJRem92a0F5NEVkK05nQ1FVU3haQ0ZXdkNPYU9GUkVYeVV3Wk9QSUEyR2RBM3VHT0I2d1BhT3orUVB2NVMrTUEzT1hpTjlhY2xnaFcrZDNJZ3VwQkYycFBxeGN4R2VuRFB4ZlNSaDJBU2lLS2lWUDJQYVpTY3ZBS29BMFZEYzZjT2xJQjJHZEEzdUdPQjF6Ujc3aXdYL0Y2QUZCOU9OU09RVzBmckE1MHNJTFZjY2tXSnlJRFNnd1BBVmNKZ0ZiWXVaM0ZKdkFsRUhiSjNJc2dKTEdlZGVCSUErQUFBWG1IT3g2d285OXhZYi9pOVFLZzJpQUlmREpFSkhxajRTRXhiRXR5MGdrZGhCLzZQOW9aYkJaSUdpS1lWYjlHS2FONTBsUkhCTE92aER4aC81RUt3RFVHNUIzdWVNQjJRR00vZ3JiNy82d0hBUE5HTUFZK0dTR1VqQzUyVlgyZjJDRDQrSE8wZ3FrWmZlZ1hLZ0JhSGtjV3RTMEFXaWk5eEcxSW1yTGxONVhSOEw4Zm1RRDA1QlZybUVFTm1wWVNQOVFYK0tIaXFqMi84MitIcXFEV3duYkJSZkdBVGR6QWVnR3dydTJEcFJxN016cTJmcEFmME5xMFJsMndCWHpnbFo0eVVBUEFtRFNWV0RCUEhRakxjZ1RxT1o2elV2ZEtIaDRydURDZXJveC9EbnU3WXF3WEFDMU5JL1FjRVF1SzZXSy9rZGdDVEdDMFBZQVAvS0lETUJnZ2xxK2hJa3JPZnNhQ3ZpTFNvZmNKZ0o1QWRNN2trU2FDai9IcVFLVklHdkQ0c3dGOGJjQmptempzYVEySDVELzZhY0JkOXdBTEI0REZXV0I1QVZoZXJNcDRHS0lZRU9wNysyNlVGMGFTZlQveFl1REc3d0RqcklwQUVSeXRYZjJ2YWpqN3VlcnlRWFNGbDEwSy9PTjNnSVdEd0NMdmpmR0I4WjU0TytFZTR2ZTY1MTN1QjJSMXl6c3FDK3R3YkM4SGNOVmhmQWVhQnVEUC9Udnd0UzNBL2VQQUlmWUZWbFBxMkhIVHV5dWxaQ1RsaGJqaEVURjV5eFRRR2dQR2hvSGhJV0M0VlNYR0QzbjB0TGtNSFhIeHUrWXlCK01sUHdEdVpzNUs2RmxzYkN6ZFZPOUR1S2ZrSE04QUVrUDdCOGZPa3dEY0QrQjducDQyK0prR092S2RBTDRFNEs4UDB6dlFkRVQwYjE0RDNEZ0IzRDBCN0I4SFprYTlXenJEODhONnNGbStZY1Vqcm43RTFaRHZNdEY5REJnZUFZYUhnU0dCMFBOSENENEJMd0xSc0J5QXlYL2lqMC9kRFV4dXFsSUc1aGl4N2VGaHZMY09WVUF0eVBTeWRBRm1PUU5lNkVZR1YvOVpFU2lLZ0lFZ3RiYUQvZ0hBTFFDNG92WTVyNUt3dGpPVS9YZlRBSHp6THVDbUllRHVNV0R2S0hCd3BNb04wV1F6TnRBYVlTczBLNFpsT1NBakdHOWtQakNCUndaMEFCS0VCSmV4WUFaRUFVM0E3T2kxQmVEeW00RURualExVHdDR1dNVzhNWGNLa3MwWU95Wk5sUU9RamNnWUlVSGxsRXpZUTBrdG0rcjZvejhHNEY0QVh3WHdSZDgva085QTB3Qjh5NjVLbVB4Z0dKZ2NxWUpUS1lwVHYyQ0N6eWRkUUpSRE9qS2l2bitEZWg4QkY4Qm53QnRhQ1VBK1lZRXlBVThoK2M2QXo5Z05ISFJtcmdPZ21EQTNqSFEraVd1cENlVUF2TlNyQTlITndxeCttdWs5bkpWTmcvQ1Rmcm1iQVB3YmdLOEQrUGNIa0lpYmpvYjVvMTNBM1h5cFdzQWtHMWNQQTlQREZRRFpNMWlkMGkxS3hzV2ZPcktuQUZYbGlmQ0ZGTU1SY0FTaWdPY3MyTUdBSWZFOWlXWHBsUzZPbjdVYm1QYVVVVFhRcmdzVk16Y1JqNUZvbGcyVjVheVVBNUJXWUt3T3hLVWFmbm9zV2pjSndrKzdXNUYyRUt2bEUzeGNYYU5ZZmlDWXNHa0Evc211cXVnNmhjbGVBbkFJbVBiTzZZd1JwTWdqQ0FWQW0veVFtS1R2NWhOc0FmL2k3U3lOQlNsMmE4UXYvNC9NMXlGK0JaU1lsTlFDbm5WcnBiQyttVG9BQUNBQVNVUkJWSmNhSTdzT1NFWTJOcGFEWExxcFIrdkUvT1Zrc0RnSW1nR2dnaEhvWUpiVFdjN29KdEZXYzY1L2NnMkFZdmgyQUxzQjNBemdWdjk1blMvZjRRZHNJa1Q5VDNjQnJHdElUV1pmQzVocXRRSEluc0VHUW4zVUREdkVERVkvSUNmN1N4TU9yQWc4VCtjMDBKR2t2SEdkMkRBQlVZWklBT056Q1VEcHBDRmhTdWtDQnNMUXJGdFplL0lpeFlRcFN5RW9Kb3FudVBXclZSQXViUWg4M0hObFpCMjN6N2oxeXdtajZDSUlxVVB4dzJYZXU5YngyangxMHd6NFo3c3FUWVphREQ4RUlEdW9FM2hNVkVwaFdnNjZKSXA5MGswc0J4QmN5K2lQSUlhVDFSdEVzSFMveUlBcXcrVlNOUFdRZmU1dGxWRWs4YXVYZ1ZhNUJVc0VKdVQ1dW9saUFiRTVBR290bUlBakNQblI5eERHM1RRZXJuWUFVdXBUZEJHRUZNZjgzT2tBcEhHK1hsdlRBUHdmdXlyZ1NaT2hhczN1NmN3VHNVQlZuMmdUd3lGTWk4d2pIWkFBMU05ZllHSERVTEpEMW04Q3BhOGZSeERhZCtsK1lrZi8zWE52ZDExVStxaUwzOVN4WGV2U3NzaGRERnZnYkkxTzJBd0F0UlpNWnpUQlJ1REZqeGUxWGc4UUVJQjh5eWo1eVlJVXhmUUlrZmtJUm5tSENNNzEySm9HNEZzZGdISHAzQUNvTUgyRzZqTTRsV3pvUWFyU3Z3UTZNU0IvdnBvclZhRmtoK21DTGxwVlI4WitkcURaTG9ET3BIU2lRZUFGRGtCalBybGdDSGdDVWFGaWZnNjdILzl1WWpuNEFpMXZwVEVSVEFBU0Jhb1FKQkFLZU5xSGxMNm13UERaWUFPUk9hZy9FWVJrUFgzNE13SEl2elc5clFjQStUTHBJMjJHN0VjUUtsSkdzWUlKaEM2Q2xVTWlYZkJUYkZVUUFlajZuUFMvT3VBbDlwT09xSWMyQkx6ZysrM1ZtV2dJRVV6ODJjUnVDQXRMSUhRUW0wZ081MnVPQWIyMnNDM0pFV2dSZlBwWmYyc1FCUUlnTHlkUEVJRkd3UEVqOE1sRjJiU2JzdWxnaExmdHFzQ1hxOUhHZ0h5c3puckdnaTVxelRVVEZIOEZMaEFVbjNoSUp3Q04wSExuY3czN3FhRjJ6b1l2dUtOaXZtUUl1VU5jN0d2V3Q2c0hOczI2dHdBNnZoeXE4TkVNQUhseW50RnJEQ2NRZWh5YVBUbCtGd0FiWERjbUFLTVJUaGFrRWs4UThrUGc4U1BMMHF6TEJsK0E5UUNnUjZ1WkdzM3ZmSHo4VHRCWnZrZ0dRckVQQlZBVWcyU2lqNTBRQU9qaVZLSTNzYUFESlJtN2RTTFlXZlNGRGtDZW0vZGhaZU15OXBQWTVRdlNEWVF5VUpvRElLOHFNZXpoM3dZNmZTTDQ5UGNHZ0NBQThwU2NKTElnQVVZUUVtejhSUEExN1N0dkdvQnYzOVcyNGVSRWlCb05RU2dXTkkxSEJrZGd4SlN3MUFJK2RGSWJnT1lta2ppbVExcjZYWEMzckFiQ0h5Y0FneXRvaGY4dnNCL3IyS1JhUnE3enBaK0QzN0hNWDBzM0REY0NVR0xZYXc1M01KNFlVT0R6dXNxbEdDUUFPUUNlanV4QThVVUxVa3hJd0FtTUFwOFdhM3FrTi9SOVcrc0J3T2hJRVBqazVTTHI4SGVLRmJUUWZiNzdjc1BJTUhHbC80TVBiUmVzbFBoTmU0K01pVHBpOUFGR1Y0bkk3TWZ2YWdOUUxoL3BmclluREFTOGFKUTQyQTJ3NGVtMmNBeVdRVXVKVlFUR1dMczF1TDdERzlKMVJqaEEranZZazR0M0tYZU1xaWpwenJ1ZDRBdDl6M1h0UDE2eUdmaktabUNHb29ZaDF0Wnp2djh4WFBGbDRQb0pZQzk3azlGbHdaV0QrQXppL2RlTVpXZVAxM2VRQ0dFeW9FUnVkQ2hJamJiM21KWXdIN1YwUUlLdUN3ai9nZk1qMGFzbjJJMEZYUlNIWGZML2lSa05nTHllVmo4Y2NNWS8vSjFmeXh6VEFYVDIreG9RVmlLWUQvMWhEcUx4UGlZeFRnU3ZRcnBocGhHOTd0ejRTbHFhZm5qN3VrMWtJUURacnZXVHc4QjNqd0VXK1JMeFBnU2lDRVJkUHdQUjcrd0NQZy9ndWxGZ2ZydURrT01Ra0ZjNXg4NGU3MDhKQU1tQ3VSTkJYaTRUSWc1Q0dSekdpQkdFL0Q0RS9DMnIydmNBWUpvaWZ5NjJpMGFKU01oQisySUhvTnd1MGZrY2pRODVwdTNhY2s1bklCUkVxbmVZRnlXTGtBWElKSEVTZTAwQ3l4NVF5ZUw2Ri90eUVjRGNyT1cybjdmWDhkZjBtTUUrL3ZRL1BRamhveTNnem8zQUlTWWY4ME1RYVF4MXBlSDl3Yjd2Mm1ydG1DQmtJTU1lanAzaklKRDFNc2F4YU1aOHY1Ti82N0lOQXNCM0JBWVU0Skw0RFNvMUoxNUFGUEFFd3VRSFpKemtLZlVBdE9ITEpTT1FSV25kQllRdkNRQTAxY2ZuTm9wZnNhQ0phRDJiYUJuNzlRalNUaU9FUDFFY2F3SXBrcTJrZWdCVE5nSFdFcE9LRjhVd3EyTlJGUE00QXFDZjQ2L3JBMlU5L3VWRHZ1ckIwMXp2QUpwaWl3T2wzZkVlY2lDR0YrSWoxMWYrUWtiU2ZNUGZJenF3NTdtRUZaOURsM1BzNUhYV0FZQnlISkFKS1Y3TitzMGNDUVFod1NsZm00bEdaMEtCOEMvckFCZ1pVUzZaSElUQlNFaENvd1VZQUFrc0Y3Y1N0V1JFeXhSd3R1UHBPbGd3KzVzOXNxNk9hSUpJSWxVZ0VoQTFlZG9UZ0h4YTlIVnc1amliWk5GK2ovOXlHUUEvN3BidWpaNGJ3djIrY1dCNnRGbzBOellua3hGQStjdkVBbzQzVkJvRW8yZSs0OEVNWEVPbUQ5RjZ4aENFOFJ3WkVKODBWYmxLdkRsbXp3aWNmcXk5My9vKzhLOFR3QjJqVlNnVzEzOEZySlFUWEJObG5KZ21yalp3YW5vdzlDQlAvckw5d0YwandBR1dEdEZ5b045UEh1dG5JSFQwNW1QWHo5M2RNR1FBUG5pSnNqaUJYaVRieERaRk1GOU5MVVBReEtSNXFlenoxWTYvWVpESDBENkdrZEFrWUpJdlJhbEFkSEFNbVBab1loYjZOaERXdkV5Zi9tYTczN0NYTjdSMVpDN2hVYlBnY0ZncXQvWlpqQURuTTF4cUVWaFlCcGI0Q1VrNVVzTDdqUXZqLy8vNWJ1RHJMZUNPRWVEK1lRY2hZd0c5VklmeWcxTmFac3pGaUNINkRrUkdMemU1L2RnazhJTVdjTUNqZENpQ3pSOG9kMUI4T1R3dkpNOEpFU2hGdXQxZnpNaGkrZVJKcjZMSTdoWVAyTS94Vkx3S05vWmpVVHdSTUFRUW1ZeWhXR1F4c1NBRE9mbFo0a3VrajdQaFo3NWJFVGpCcGtBR2FoTWtjckdnd2hzWGVDeUJIQmoxd21PQlF3dkF3cUt6b0ZlUlY4WmFlcmpLWUF1aXJtUFkvbzlYN3E1Q3lyN2ZBdllNQWZ0Q1BHQUVvWWxCaVZ0RndManRwMlU0aXJqN3lPQU5iaStjckh5cmZDYlRxdUpWNDRPMEYxRnJ3UUdJTVpGcWRRRHlQL2dHU1o4VEMwWlJSc09sVnp6Z2FzZC91K3pwTUJ5TGVoQWZDZ01RQ0R5R1pKSEZDQ2dMWjJmOG1nSTVxYXVFY1Z4OWU1dkFDVGdDVHdFTVdyNVRkSXBXS0piNU12cm5vb2NEc3d2QVBBRzRWTEdnNlVLZXFtaTRpdUR6NGVyMzBvWDBGUDd1NW1vTXZJZjdXOEIrandsVU5BekZubFpDSWh2R0ZSQ2VXenJnWFNTSUJyZVhURlpTZ1ZMSEFwNFVIT0Z1b2NpRUVzbjJQSndsL1hFazBkemZTb2plZXJGZzFJT281QktBdmVJQmV4MVA2N2xnVXpnV1FhSndMQUtSSDA0aTE0SXRnREtFdEdzUm5XeDQ5YjJWa2s5d1VlZlRHcktDRjdSMEp4Wk1xeE44Y21QQXhXY0FjeEdBQktFQUtQQTV1OWxFYUFiQ21LTUkrc0ROMVgzeitybzI0d0VaRmMwVkVFNjRBQmdUMTgwUEY5WmRCY0RiNkpwcWNQdFBrKzFBQ2JtS2pKbmxsd3l1SUx1bkVBV2paSGtCc3JzUlVuZkQwcUVpQzVJSmZ5aXNnTWh6V2hjUDJPMTRSbzRXYkFTZ0FNUUo0OFNKd2NobUJDREZhOHFweUJiU1A3T3ZVNFBRMHAyVzcrTFNuU0pVRk9ySTRWN3c1SW9CVFFRVGZKNm9UU1lrMm1RY3BHUnlIMnN5R2pJRjZFTTNWL2ZNKytDMUNmd1VFeGhDc216Q2FRVDQzbFpDM2UxaEJwRUhoMzZYRXFyQjdTY21xNWRWMFhaeG1WOFd1REZ6QUY5aXdob3c5c2VBR29CY0d0S2pxQWMrMWw5ckxiLzFpZ2VzTzU1eXNtQ3JDOGVpNkl4Uk1BS1RXTkJpNlh3OTh4TlRGVWkwakVjbXBZZ1JBUGhkZHBWaTlPSUVQUDVjWUQ0Q2NMa0Nvb0hQd2FXOWtWK2l3V3JRSFQ4dUExZmQzRjdERnZnVUhVUDJrOGpUaW9nQXFMb3hGcERnYk1qOWpYU3VON2k5ZExJZGF4ekJwNVhWQk1JTWdGRW5GQVBLVDlxUGQ2QTlCSUdJN01mUG1mNFUrNDBIekk4bldncTJQQnhMNEZFa2pLSml4R1JSRnlRUVB6emQxaUFVekNBUWFzMVlPbUFFb0Zqd2tlY0RDL1BBd2hLdzZDeElrQ1h3T2RWSkx4VG9iTWpCZHlJZ2Z2aW1Odk5KN0V2ZjRqV3RkblJZRDFZTkdWdUc5M1ZXdVdzNEpmK21sWkNDWnh3UC9jbko2bVhWS2syK3RLOGxRUVZIUlRHYzY0U0RBWkIzRXkzSmN4eUFDa1RvSng0d0hsK1l3cWxvR0RJQ21ZbVRGZ01RRkJFVDh5eVl6eUFHL0FmV1g4bUNHUWcwQlRSb0h3dDlLVmFQRS9IUTg5MEFJZmdXSytDUkFhTVJZblZkeEhiaGRZOFdzbHcxVjkzVURzbVBJajlHeGdpQWlvUlJNSUpOdm90aStTVy9Ja2QwZ3dBVTgrWHhKY2JHSVRKUER2STZYZENGUkVGU2tuVEI4M3hrYTQwSDFQR0Y5ZG55Y0N4Rnd5Z2tLMGJBU0pRU1ZBYkFZZUQ5OHhVQWU1VTNqS0l3Qm9zU2dOc3VBQllvZ2wzL0l3Z0ZQck9JZzFYYzRacnBBc1NydnJ1eWtsMnVjeWthcGtNTWg0Q0V4RDVEd0pmV0FZQXh3azRNS1BBSmdPSWpHU0VHd3VDYWtSaGVtdzZZdjBVVXdSZjdMMDBMOXBuc054NlF4NGZlWTRPOHBERWNpeE9qc29US0twTVlqU0ZZWWpPQzhFcTNXbm5yMFlZUyswVG1pMkh5c3JQR0xxd0FTTll6Qm5UMk16MlFEOTFsYXhMQjBnczEyR0FoODFjZi9vL09jSHlKK3FqMFMvenhuaFVaYlN5WVdhTDgrUnEyUzI5d293aVdrSlBhbjRNdmdyRERHQWxSZTdLSXl3RElnUjNtZUVEV2c5SGJKZ0FwTlRrWG84bzBpN29WZ3huRWdGcjhGN2pFZG5VNUd2cWZKUUtRS3lFT1Bsc05JUXZ5dnVwQUdIUy9Pa3Y0cXY5b2grUEh4TUxrOGdnQkNSeHZBbUVOK0FpRXp6MmlRZlFCZU5ta2g0SzUyaEpCS09hTmUvRlNMb2JMUlhDejQzclFudTJ5aTlvTVNNRHhzMmpvODMwM0VSejF3c0NHWkVDRjRrZDNEd0VZWXdKamhvTmxRcmdJamxZb2RiQlByd01BWmZFbXl6Y0l2MjdnczZYRHpDL0lSMURPZ0E5YTZEUno0d1pBc1orTFlYdlFZc0hvRDR6aU9Ga2xuYTZZRDMrbm5VNmRaN2JHREFjQlVJbUlBbUVVdy96YkoxaS9zY0dOREppTFhtbGUzUmhRK2wvYXE1N2dVUUNXend3QktQZUxzWi9MRnJHZy9TaFJYQWU2NEFqa3YzMGtBTEFqRjhSMTFEeTNLN0tSd0pjc1VUYXFXU2NBUm91M3cvSU5WbkNIK0EzNm44UnZNM25CNVhQNG9ENkRBVEJZd0diNWFqbE9MT2g2WDhKYUJLUkc3Nys3eWdHWXAxYm4rVjI1LzAxQXpCbndRMXlwYW5EN0tXZkExUURZQzN6SklqN0tnT1V6YzluRmJldFgvcitPNWJpd05oeVg1dVNFRHI1bzB4c0p3THA4L200QTdHYUpVdi9qMy81K0hRRllKM29GUFBraG8vaE5lcUJjTWtjQjJCQUE2WHJ4bU1Ca2ZGQWNpL20wSnB3elh3MFRYdlh0enJ6K1BLYy9NbC91Z3pNOU1EcUNBYnova2VWampHY1FBL1lMdmpvZ3VvMW1Sc2xSSTZSd2ZzaUE1bnFoTDVENm5zY0Y4Z2ZUZGZ4cFMrL2hMenZXZnpNUUNvQjFGcS84YjNWV2FQSURacXNSVjY0REFMc1pIVkhzMWdFdnNxRkFlQlNBcFFDOHBISzkwT3FsNFVFQXl2Q3dOZUdjQlhOTE9QTUxmdGdac0k3NW91VXI5b3VzcDJURXlJSi9zVTRBekMxZStXSUZzaHlBSFBaUkVWd0l0cnJEM3dHQWhpYlRZQmh4VnBlL3hlUHlyTkJ1V2FvTnAzRGdGd0M4MU8rUkFlcEsvYTVMZmU1MWp4cjdKd0E4M25QWFlncTFhc2wweVg1TjQ4K2Y0VkVHTEFUbEsxdkFvNVlCMWdCU1Jtc00rTkZFNTdsY2ZQRDVwUEZXQ0pJbXR5dkdnR2ZPQWFjQllPNTl6RmdsZ0hnUGVmWnNYVjYvZ1BYQlllQzBSVmd5Sk5PR1l1SmpQa2E5ZUhXZ2pMOWJXemhXazAvbi93UG4razhiZ0ZObWdZY3NWZmxabkJSbUlTaHRKTS9tN0pHaWJHQm9PSUllejl3S1BQNEFjTnB5bGZiTmxHZmRJKzlOakJqejhKVnpwcGNrWnVKK2RCdzRhUTQ0ZHJrNmoxTElZOUprUEQ3UDRzMmx3VkVHTEh3Sm5uY3NjTkloNE5oNVlNc1NzSG01bmRPdTFCR0ZUaEo4L0s2SnJadG9zbFNUMitYSEE2ZnRCMDVaQUU1Y3JnQXVwczVUZmFMNkVGK1V5SWlmM2dBY093dHNYZXA4MmVJWVk5SmtYcE1nTXAvQWVaUUJDMmI4T2R1Qll3OEMyK2FBTFF2QVJnSndHWmhZN3N3RXpiTmE4OElSdkFWTzFxa0Y5MUozNkROT0JFN2VEMnlmQjQ1ZnFwaExuZXZ6ZEdlQktCZkw4VVg1L0NaZ3l5eXdlUkhZc0Z3eFlIelJOSzZvZXRTQk1ETGpVUUFXVFBxUG5ncHNuUUsyemdLYkNNQWxZTU1TTUU0QUxyY25SNkpZUUl3c29VbmpwRFJzdE9MeTdjQkpCNENIVUd3dUF0dVcyblVEVkgxRUZVaHljU3dXakdENjRtWmcweHl3Y2FFQ29JMHo1UDNYNVA2bldsSGRnSGdVZ0FVQWZPWU9ZTXRCWU5Nc3NIRWUyTGdJVEJDQURrSXpTSlpYcENPbklnMjV1UHJoZ251cE8vVHlod0xISHdTT213VzJMVlNpazJwQ3JEc1Fza3pOSUJHSXBCZEdJK1ZmTmdNYjVvRU5DeFg0eVBSalBqNHhhSjArV0dlRUhSWEJEVXoyTXg0RmJEb0liSnlwQURpeFVBRnd6QUZJOEtVSkNoTVYyU1VhQUdjMWNFL3hGSmVmM0ZZUnRpNjRua3FXRHJxcUVoYnJzbTV6dlpDZFBDZDhuSHpKT0xadUFCUno5aFRIWndQTDdMbkxub05NSVkyVnlhS2NqdFpMSE9BYk5nTlBuZ0tlNEJhY2ZHRjFwbnlkRCtocGhRLzhYVjVVaUV1ZUxHbkROMXRXWGovMy80Y1R3QVV6d0dQY1JjRkppRHBQdDNGTG1mNXZqd0UySEFRMnpQckV6RHY3T1FnNU9TTStTY1lReTVYYm84NDY1dS9aZkxUSjdmS0hBZHVtS3hWaDh3S3dlYWxTRTZpbkVvU3kyTVdDZGJVSElnaHYzQXFNendIamk5VkxadUR6RDhjWHh4V1pzNWM3YXBtVzBmTUJuSUhLbjVYN2Q2STVucHZSejk0TzdMZ1h1R0lSZUpTYitYbDF0enFmbHlid1J3cWY5aTk3QlFSV29tV0pRN29aVkZ0Sm9xRFgvYi9vR09Ec3ZjQlRBVEI5Z3NmR3FtemRqdFZ6K0crUEF5YW1nWW1aQ29EakZFMmFuQ1ZnMUNlSndPTW5UUkIvRG1VSU5Wa2tnaWEzeTA4QnRrd0RXK1lxQUZKRk1EMVZBQXc2WEc2MVIzMU85L2ZkcmNEWVBERG1ZMHpqYzFVaml2QnVBTXgxUWRNQitXQVlYVThkaEVVMTZkT1NrcHBiY0hGU3JuZzhNSHduc0dNUGNONXlwVVJIcDJ4TUlhN3pEejJ6OEduL2tWZTBZb21PMHdFd0JZS3VqTDd2L3pIQTZDM0F4Zk9WaDU4ZzVBc1p4eDRmWk03c2YzaDZCY0R4V1dlR0JaK2NNRUZpd0dFSEhSbkR6dW43T05Icy9kamtSZ0J1bnFsMFZET1NISURVM2N4U0Q0YUVhamhGWFM0SDRTMWJnVkdOMFY4d2U3RTBGaDlqVkRHNk9icjFMSk1Sd24ra09DYVRFWVQwZHNmcVpIWGwvcDdQckxpOXdJWTdnTzBIMnlBZ0NBV0NXQ293S3JZRThuTUxuL2E3UFFuOVg3eklKUFBrQ2NLKzc1OHk3eDdndU5zQjZsOThnWmpMTFlldDNBeTVuMHN2NFIrZkNZeFBBMk1Pd0xFQVFMSURQeVA4dUJnMmNSWW16RndlQVlpbEtrbitPQzgvRmRoMENOaEVBNG5HQTQwa2Q2RkVTMTNXTE84djFxSEtBZmg5QitEb1lqVTJBay9qcy84TkFJd2c3T1ViN0xDQytXQWZCNENwQkpvSWlUUk5SbVMxbDEza3FXaDNBZHYyQThjZHFxcDFNQithSU9TeFd2NnBxNUQya2tJQXZ0OHJGN0JMSmtzTi9qTXFmYTd2KzcvQWs0QjNBNmNlcXBhc0tNcTVha0FtbExXWTM3dDhaVzk3UERCMnFBTGcyQnhnQUZ3QU5FR2NuSTVKY3JEWlJQbGthWEw0dTFLSlVBZkFqYlRRNTl4NmRTdmRMUFhBZ0dZc2haV1I2SklSYVhCL053Rkk4QzFXd0xNWHpNZVN3TGZjWHVLckEyRyt3ckxDRGNOL0lJZzRFUlJuMHF2eXlTQVFYNm1HMVh1QTRmdUFiVE9Wd2t0UlJyMk1MQ29ReXZFWi9VWS9Xd2pBajNqdEZKWmtVNzlnMWdoa2dFQmY5OCswVW1iLzNBMk0zbGtCbC9mT2NkTW9rMkVqa1p5djg3NzNMQWZnSERES2p3Tnd4RVV3OXlhaWxwd2R4QkFFWWhCYkF1R3pHM2FLa1FFSndBa0NrT0NqbGI3WTZTWXlmMlV3bEFTK3ZLWW5BWGpmTm1ERVg3REVmQTVDalVjc256dmJ1MW5EdFVNbUNEa1JaRUV5R2RsQWs2RzZsUVRTYTZtME1QNkh1WTczQXhOVGxjSkxaNldPSllDNS9DTnhMcEhNZ2RLSUtObDY5UXZ1Ni83NUFqSE9pVFU4N2dLT09WaUpiNzQ4QktDV3JuSy9tYVRBKzU4QWpNMEFvN1BBNkx4L3hCQXVwb1lEQzlva0JSQW1QZEJaNDdsTkEvRGh3TVJzeFg3bVBnbCtTcm1LNUVhUk5Sc2xYRlE5Q0tCOURrQURuNzljWnRrSEZreXNKMTAzZUJicWxoOTdEcG1UUVRZZ2s5Vk54dSt4WWJYS1UzbGhGb0pQT2dkRkdZK2xQa2dReG9ra2dGOVhnajRBdmZvRnM4NGVYNEtlOXg5ZklDK3RSZkR4dnZuaWlmMzU4c1NpcjJMQ2o1d05qQktBYzhDSWkyQXh4TEN6SUFHWTlMN0FoR0lLZ3BBVHc0bDh3VG9CMEpqUHJmVGtwK1NMUWJIck9xbTVqTnlhalM2VkNNSXBBcERBV3dRNExyR2dYcXpJZm5xNWN2MHZOMFpYSFRJbk1FNUdCTkxiMURHZE9ZUXNJN0FmR0tGamxncXZlOHdKd0c0VCtmdUZBRnl0WHpDTGIrVmdXbkgvZklHWWZjNDZIczdpSEM4WmtQY2RYeDRWZlZYSnc4K2NBNHdJZ002QUhTTEtXWkNURVNmTGZnN1dzSXlSRjNja2lSUStIQUNYa3dIcHR5UDRLSHJwSnZLVkduT2hSRjllQkY5d0UwbVVFb2d6MndDK1dHSS92VnhpUVFJeEFzOStybUhBNkUxWUZZQjhESndRTVpsME9yTForK2k3c2ZUOHpyb1lITFM5ZGY0UkFDV0t4U1p2TFh6Ry9mUUxacWsyZ3FuMi92VUNVUTlVWmFNOXdEYVBlU1ByQzRBNUMxS1YrTklUS3dDUy9TaUNSL2pSQkRsTG1QN25IeW5zeG5vMUlQd0pTeVJwYmlNQURYenVQRFlmWmZCVEVvQW1jdVZRZGlhVzB6d1h3UXNDWURZbU1hREExd0c4VEJTdmFvUjBHNzdFY0dTRVQ2aGpPdlZBcGZSUEFVTjB6anI0NUp6VmNTcWlUeEQrVmVHelhrdS80TnI3SndESk9reEZJd3Q2ajYrUnFVcmxrTzRiWHpwMWdDQUF2MDRBemdMRERzQmhLdWdMRlV2UVVoVHdDRUtibktDdzE0SHdKOWNEZ0dROVdlZ1JnREk4WEVjVkVEdkFsN2xWbGdsQWdpK0k0Q1IrWmYxbUxHZ01tREZoQkdGZkRDaWNSSkZFUnZpU0FCakxTN0ZDME1GS01VKzA3d09QRTBrR3Zhb1FnR3Z0Rjl6MS9pT0Rrd24zVldvRVh4cmVzNWliOXh4MXdadWZCQXdMZ0FRZXhiQUQwSmlRd0pPdUpCQTY4L0gzWmhrNiszQ2lmcXF3V05NS044d2pLZ2JrNmdXSmdDK0ZNYUJiNXZKVm1zVWJWMnZDcW8zY1JXWmNDSUFDb2F4NTMrdWxrcU5kN2lxT2NVMVdjQzljeEVtNWtRQlVkWitzVG5TTC9qRXRUV25naTIxamhKTkpCaXZaQnVrWHZPTCt5WUJrY09xeEtqSjRBR2d4ek1yQlZ3ZEFNbUhyWk9BWUYybDZ5L213VjZ4RDE3em1XbzZNYlJ5ZVd0T0h3eEo5MUlJaHI2cnFaUzcwRFBQTFhEVlVyZkJ3ekhLcjFFVXA2L2gwVC82TC9HY0Nxc2x0NElob1Rjd2RBcURTczdJNjBXUUg2UjMyOXBIdUZ5dVhESm1FanVPU2JkQit3U3Z1UDViR1VqbXNBNVhvVXZjdkJYS0tBUW5BcFVkWHdhaDBiOGpYUjJZekpUc0MwWkhCMzNGTCsyeWlYM2gvMVllRDFmRlpHVDgxZy9INnlxa1ZhOVlFcHFNaFRBRGxlOGVySEE2dDdNaDZqNFpCWGRCR2pGeU80Q1NJbTl3R0JpQnZncXh3SUFKUWxYSXlFSkx5SS9pMFNrQUcvRmJoYUVyNkJYZmN2KzVkTEtoQ2c0ejFDMUhFQko4K0JPRFFHWlhmay9xdUFaQzZrZXRBWkVRQ1RXQVU4UElKdDBmZ3dIelp2VldOYUtxaTdKTE9tdERXRnk0MmcxRnhIL1hmcUdrSUkwQythMHRuRGtmc0d4UWpuM1ZQc2s3dFhtdXkrWHAwSmh0b0pvc0FhRmNVQUpVWUtpWUp4Y3FIcUtBSDlyUGxHMmNNcm1DVWJNWDlndU1McEdUY0NNS0RsWkdoTUs4SVBuUEluMVg1UEEyQXdlZ3dFRVltREdCTWpPSTV3aEdRUDNOUEJUN1ZKbFJOYUt2RjR0MklXSGJERXJ0RGxTazFwNGxKNy96ZDI0NnRnbEdacnlJZnJGaFE3cFU4V0NBWDBaRU5HKzU3VTE0WjRZckNlTHJTeFhkZXY2VGZMd3JieFQ3em5NcmZLUVhmSExRQ255dm1SSXYwUTM0MzBlek1tTDk4UDM5M0czd3F6NmFtMU5ZenpvR24rc3ZxUm1UQVUyY2l0Y3RxQVgvMkVJOEY5QUNFbUxIWExaR29GeHRTbDJ4eUsyYkFZd3JqNlhyMTIrMW5vTC9qVVRDRDl2dkZybjZ1MHYxL252R2thb1ZCQVFpMGV1bW1NQXVYUUhNV0pBQTdnQ2l4RzhVMGdGZmNYZGxCS2s0WjZ6RUxnQUpmWkVLcnhwQzF4T0lsLytTazdqa2NkWWxTY285MHk5K2dLNnZKclJpQUREMHBpYWQ3UnVGbzN1ZE5DZ2Z0OTR2Q2RyR1huK3R1amdWM1FBY0hMY0Zucm9lbGl2SGtjaEVMOHVlMHVRNzRTM2V1YkFJVFMzSVFoS2tNUmpCTW9rZ1dHM0wvLzJ6M1ZTblA0VkRnUVd4VUVFVXhBWkZITDBlUjNIRGZtM0lSYkRIa0JmRjB6eTRFSUtOaFN2cjlnb0dFQmR2VHovTUlZUUxRZFZzVHdSVEZEajVqUW1kQXJSRFlKUU5EU3M5NjFSM3RQaHg1TlhvVmdveGxlSG5hcmpvaGdMZWMzRDJISTQ5MnlRTnZJd3ZxTzlmSm05ektHYkF3bnU2RmhhUDVwRnVNZy9iN3RUYnBCZHZUejY4Y3ovekk4YXpWajhpQUhUcWdtRkhYRFVCODlSMmR0YUM3dFVHdzRrRE9nRmIwUjJ3WVJER1o4ZzlPOGFVNFh3UE9jemhpd0dsTWpxcUxXaUZZR3U1NzB3QURGc2JUdmF4Zzhua293N0U4bk0vYXRmS3psbjYvMW1TNFlIdjZCUTQrWjBCYnFIY2QwTnd3WWJWRDMrMXlXaFhKeFBCcmJxOEFxRS9YQXBTcUF4aUJWMk1aLzU0RE1PWndLRTAwcm5EVVdjUjVLaVYvYnJqdFNBTUFMSXluKy9tQ3llZWhqSVlwNmZkcnZWRUx0aDhSQUNseUhYeG1oUGk2cjFtOEZNMHVjZ2s4K3k0UkhDMWtBSy81WGdXKzJoWllvZmFmV2NQcTFCNUFxRHFFWXNRM25lcFIyZ3FoVjJ5aW9sMUNPa0QwQythT2FvR3g0YUw3RFFDd01KN3VWd29tbjRmbTdWclgydS9YQWxFTHRoKzVzSFB0TitsL0FwNnNYMmRDc1ovcGhaa0lKZ3Y5bCsrMXdiY3ErMldGdjJOWElqTktBUHp1dzdNVUFWOERUdXluRklFc1F5ODNSZ1RBaGl2K05nQkFCYVFPR0UvM213V1RMd0FxSG5hUWZyOUdud1ViQVJnRE5CVWxrcHpRYm95WUN5WURZZElMZGYwbDROZHVXOWtHb2E0Z2VOZGF6TEVsS29BM1ByeDdEb2ZpRVR0QzZYdkU3aEdFekpscGNpczNRZ3JqNmQ1VU9Kb1lEY01nbHJYMit5ME5QdGw1VVpVamtmeC9IcWJlY29lME9aemRGMWdIUXJsbjlCaGVlNHMzZjNaeG00TXZBazlWU0ZkVUl3MGkrUTJQYUJ0SVNpQlNTRmdDWU1qTVcwME1QN3B3dnZMRG13RmdRVHpkSHhjT1NHdkJnL2I3WlJaQnlXWUFsT0VSbHVLTTNSYTlDS1djMHE3M2RUQmhNRlQ0WndJdzlsNUxycGVzK0hqZUJpR0NVT0tYZXVCdlBjS1RpRUlPUjBmK1JoREJNWWkwTGhlYTRHVGFhNU5iT1FBVkR6aGdQQjFMYTVSc3NWM3JJUDErN3l5NU9BQURvQWNoRUhCa0ZiS2ZHUnBpd2VBUHRNczVJRk5va3lPR2svN3JBWUM5T2hCRndOWFZZMWF0NXRmdENCSGFXVlMyQUpkRWNFaW5yRE5DK0x1bWl5YzFCOEFCNCttdUxBUkFYVERDV3ZyOTNsUjQvWjBYdDZPREZRa2o4V3R1bUV3SFRLRExRZWpBZk4zdWRzL2Rmam9RZGF0R0x4YjhqUUJBWXo2L2JveGlGZ0FWdWR6TkljMi9zM3hMazFzekFPUm9CNHluKzJEaGFBVEFHSkN0YnBrQ1lxOSt2NFYrYUJnQVE0aTY2WHRhQzg1WWtEb2cvemRadnpVZ2ZOMU43YTYzM1hxdjZmZTltc0RJSGZOYUI2QXkySlJFMUFIQUVESWZJNW56WkNMZU40TmJtOXlhQStDQThYU3N1bDZ5cVYwckoyV1FmcitzcGxDeUNZQlIvSEp5S1g0cGhzMFBLQlowbHFPWVRwdm5pQWlVQW1BZCtIS2pvMWN2RGpIZ3IrM3dQSlFzVkN5bVVaclBNdVJzUkJERzRBUUNzdW55SnRGR0h3QUFJQUJKUkVGVWNjMEJVSmx4UW9INjJxOFNUOGNnZ3BLTkFGUkd3Q0Q5Zmt1dmJ3QWt5R2dKRTNDK056MVAxcTkvVDNGMUVaQnh2Wmg1MHM2QUVZQzV5eVVIWHQ1L1E4ekk1L0tyQW1BSWtraXBreUdQWXdYejFhUlQ4djVaTzZqSnJSeUF2S092TlhsTGF6c1hzOWJvL3p0YzI5UG9oZ290cDVKNDlSY2ovcHpmSXdHUy8vM09NNENOZDFkcG50UXBGVW1qRUg0TFlJZ255bi9PTGpMOEZlREdod0piTmdGakk4RElFREE4QkF5MVBGSzdGU0tmNDNjTktydkh4KzhDL3ZteHdNZ21ZSGdFYUEzNUowU3RwdnZ6TC9uUDhSYkxBZmh5VDIwN1RDaGdEUml1L1pMOURzZldOQUJ2WXpiaENEQktvQkFrL3BFb2JHV1RxcDgxOWh6UTEvMGswUG9hTURFSmJKanhWWkZnRGFkMFNhVU81TGtzV1ZqK1hTY0RtdzVVRVVESjZVNGQwblZiQzkxUzNvdmZWSHA1YWw2NGNnQytrN21aQVA3NjhLQ0EwV0QzQS9pZUx6MDkwQ0RjZVZtbEF1aEJsakxncmZjQXc2UEF5REF3UEZ3QmtDQWJJdE00YS9GaU50RVJqQmw3Nlc5ZmZEMkFid0pEZHdGais2c3lJbVJYcmQ1WTJGaklZY256V1BMRXFuc2ZDMHpzcjZxQk1RbWZJRFIvcHlKNnhNaEt5TXJTRGlLRDJ4amE2VEFEVHQwL0FHQXMxS2NBVUNGck9MRjZ0YnRpUlZGYXZUL3d1TUNhN01mVlRsSDA5OFlCZUJjd05BSU1FWUFVbFM0dUJVTE9tSzNMQ253T1BBTmxFSU9Tb0Y5K0M0RHZWb1dYaHZkV1pWT1lxV2dpM3ZPWERVUWhnaWVCMEVFbFZpTVlKMDhIeHFlcW5HOEQ0SUlEa0F6bzUxREtRUUp2QktVbUtBQ3piTTQrNWhVaXZ3cmdpd0M0THp2am1nQ2g2bkJjZ2lNVGN2OUFibzBEOEU2ZzVlQ2pmcFVBNkF4b1FJemdpOEFMbVd3QzR6Ly9EeGNQUHdCYWs4RFFGREI4eUpQcFBaSGVHQ3lDMEtONURGQ0J5Zmg5LytPQXNla0tnRXpDVHdEMDQ3WDBTQ1BNMUlZUWpDdjJFL01Kb0dWd1VVUW9QYm9xME1kcWtXVm43UnRERE1haEI0ZytQNnFoWEZwalZ0a0R0UkdBMm5Lam9zN0l5T3lIRlViSXJYZTBGWHNUdXpJWWZOYjRPMk0zQVRHSVlRT21QbjZoRzZnaTNlVWtRUUFlQUlZT0FVT3pBTE1WaDJwQWxFU3FHRkJBWEFZT01RVmp4bGwwM2lPL3lZS1JBVDBGUVhrd1pranAxcHo1MUxPMlhBVDNLdEQzQUlBd2o0V2cwNWtmaXVVSFlsc1hBSkxWblAwSU5MTTBPWUZ4NzhBemNSeVNlVHN3MkFKdWVJK0RqMkZuZTRFV0t6NU1BME16RGtDQ2tBQnlVV3FzSnphckVhbnpqMnpYd2pFR0ZIdUdZK3BZc01vanpaTDFHOUVCZXhYb3UzMzlJUkJyQzNsSkdtTkR1U0hYK3c3V0M0Q202d1d4bThEbmdMVEltZ0M4cEJjR0J1VFhmLzFmWG55VHVnbkZ3eFRRT2dpMENFQ3lJRmxzdnZKZkVuaDBtaHNZSS9zNXV4RllpMXhab2Y3b09xU0Fhd3dZalJHQnpZR1hidFdYYUNJcmx2SFVhZ1g2U1AvcnVNVllDRWJFcUVDWEFNamZyZWUySGdBMEVTdXIxLzB2dG5Od0dTc0cwUnNaTUUyMC8rL1hXSDZNdWdrL3luZ1BBR3k1R0RZQUxqaUlISWdSVUlyc1pqTTdBeCtCU3gxUzRwZmZmUVZJZXA4ZEw3ZE1Ec1RHakpCK0N2UXhUSG1kdHJ3NGwwQ292RnJ1QzJOT2U5NzVlZ0RRc0NYUksvZUs2MzRKaEJLOTBxMkM3STFpK0d0MGp4RjQwazFjUEpBQjdVUDJtM01HSkFBRlFyR2VpOWlVVEg5eUJVRFRIZlUzQjUrQk9JS1E0M0JXdE50UGNXSU96RVpFOEZvSzlLMERDR054TGkzRnFhS0E5Z1RnZW9Gd1BRQW9JME91bFdUMTFvRXdpRno3Y3diRXJ6TnhXdEVZQkIrVlk3NlZoNERXckg4SU9vR1E3T2NnMUNxTVJMUGx0bXh2czEvU0hhUDRkY0FKZVBZeXlVQ1JJenJUQjh0RThGb0w5RFVNd2w2MWtRUTg3Um15MlBTMnJnQjBhMWNpMThSdWRFSkg1N09zWTAyeS8rODMvc1pkQktyNEZYUVRBcEJ2cHJHZ1FDZzlVRUFNK2g5RjZ1Z0pEa0MzZ0pQQkV2UkdyWW9ZQ0JYOUl4RWNTNUs0aTZjWkFISXc4b1hRNG1MQmIzNVlINWQ3T2VrYWR0VFYxVVpTamFFSVBING5RellOd2dqQUhOd0R1V0dZcFpjN2x6UGZYMWNRdXI1b0JvcmZ6RGYremkweVZUdVNrdXhCSTJRK1BoUURJVUVuTUxvMVRCQ1pMdWZHdy9peGJRYTBLQjhDVE9EalBvaGRZNzhJUW1mRGptVzdZby9kb0FYNkdxSWlBdERIYVlzd1NtZU11YlY4MWtwMTFMNmh5MlBkQWNnYmxmc2xPS0MxSWlLUm15UnhaZ1YvOCsrRFM4QkZyeFhpNUhkL1U2TWVTS2RxRXNFS2hwQlJzZ1JNYkF0dUc0S1UvKzlyeTVicnpQL2xQVk12MUVQT1FlZ2hhcnJWY2daVWhWSEZ4TlBjcDlWRnRsT1drTDQzN0MwV0FCV3lwRlJHc1Ywc2I1SG4yellCd3ZVR29LbDEwdjFrbkRnbzB5N1hBOFBmdjBVQUNuamFLMzNDbzlnSlFBT2U2NEZrTnZ0WkFIUWRqejl2Mk56MkdTYTNqWWVqMlczS0d1WjlpeEdkSVZTb0tUMTNCMnM1QUhrR2hlU1Q2cW4wZXJIdjVBSWdBQVUrTFZmdy93cTNDRUFWN2NsQktEREdaRzkvNW9WWHgvb3lZQVJjemNxSDVHeUg4ZUZwbFRhd0Z2QXRydFhMR3BOclFER2JlanVwQjNvbWxJSFFHYy9FcnpPY0dTUnM4enJoQWJidUwxVGNvL0pmYkxsTndIT21pMmtJY3Mzb3diZHdOcFl0eW5EUWhzRmNndnVHOS9ZYXBHRnZZWDIyelpjQVUwL0d3QTJMSi80QW1HRjltd0ViQnU5OFkzY01GK3VBR1FDajJIVnAzQmJQdW8zSWxxeEF5NXdIQXE0T2ZBUm1FQlhHZk5JQmEwQklzRzBlY3dDNjdtZXJIZ1JwWkx3b2NyV2FvdnVUeGV3L1YwdHhKUTJEV2VhZTNXQUdiZGhiMkRCNCt3Unc3dzVnOFFwdjg4bGl5R3RvV0h6TWk0QzlmQUVIYkJpOGt3VUt1MnhOQWRCeGFHQkxiSmRadXgxTHdBR0VDWUFFbTZ3eWZwZWxKckVnRm5SRHhFU3dneVV4SVVzVk13alZ5NUFZTzBiRzg5QXV1MS81QkYzOEtxakJIbFVBWVhzdGVOQ0d3VGVXTnV3dGs0Sk1rcmx6R05pekExaG02OWcxTml4K3pET0JXMGFCZVJaWkdxQmg4TTRlbWZXTkFERFQrenFNalF5RVNkUUZIZkRiWkVDQ0xSZ2RIZUNUZThDQmFLSlkxckRuQlJDSUF1R1c0VFlBWmVGRzhadU1rR2lRMUlFd0dDSnRIWkJteTFvYkJzdlZNbkREM2pJQWVydGkzTEVCT01qR2NPcGEzV2ZENGljOXQ2b3ZlRHRMZnc3UU1Iam5INndQQXliVzZ5YUc0KzhENEhJUWZ2dERJVnRMZWpwQkZzVnZVSTdOSUJIdzNEVWpSekwzckRWdHNZUE9rQVNjdVgzY29ORHluVDJWWUpDa24rUGpxdlVEOGhWYlM4TmdqcGhHeGNBTmU4c0FHTm9WWS84MjRCQ0J0SWFHeFJlOHBMS1pkcE1rVHZYaUoydG9HSHpTTkhEUFNjQXlxM2VyNHFQeUdhTmM3SkNSWFdMVDJUandHbUNPZVFhc2hxNitxU3BabXA4dm9qUXBoZUY1OG5jZFpWakxualdQSHI0VldLVEt4ckhHVXFxOTdxWHUzanAwd1B5K2VFQy9EWU5ac1pBTzZJRWI5cFk5bE5DdUdQY05WODMwWm1rTTlkbXcrT0tmYmRjWHZKTVBkWTBOZzAvN0duRFhLY0RNY2NCUzdNd2RLejhLQ0FLUUlnWTBNV0dDdHI0VE9IQWFzTXdPa1RxZjZ1bnl1THlrZmQyNTRua2I3cXN3L2lWZzdqaGdtU1gzMVZwZDl5UkhlTHgrelJoakVHUmJCNndEWVQ4TmR5bXl1YnpEekNDR2ZwTUpXZlNSWWZyOUhQL2FNZ0JtN1lveE5RSE1iUUhtK0lENmFGaDh5UzkzdEF2R1FiN2RhMmdZZlBvWGdidFBBcWFQQSthM0FFdWJnR1UxUk02QjA2MGZna1JvQ3pqK1RjRCswNENGRTRCbGRaZFJjNC9ZeGx4Z2pKTWV3U2l3TjF6V2ZzT25nZGxqcTNFbVkwOHZtNWkvN2o1eUlNcXB2dXBLeUdvTmc5bG5nWW9zbDl3WS8wZFpkck16WWw4TmU4c0FXTk91Mk1BM3p3L0YyQ29OaXk5OVhidmZ0cmNMcml6NlBoc0duM1U5Y005eE1PRE9iUVlXQ01BTndQSjQ5VWxpdVc2U2FxcUJuL2dHWVA4cHdQeUp3Tkl4d0RLNzZhaERlTjZ1WFlDdVl5QUJrRXphNExicFk1V0VXZFNMeGpGMjYvZFFCMFNKNnI0QnlBTjZOUXhta1djcXJuUTAweDFERURKRmpSOENjTldHdldWUHA2WmRNUTZPVk9DYjN3QXNjUEo2TkN5KzdQZXJrUDVRM3RCWTFQclQ5dEV3K0p3YmdQdTJBbE5iZ1ZrQ2NDT3d0QUZZY2dBdWl3V2xNL1hxRGpNRWJQOXQ0TUIyWU81NFlKRk1vLzVnSEljQUxWMVRSWjE3RlhPaFB0dmd0dmtxZjlINGt2SERseUtLNGw2Vnp2VlNCRjIydXdqT2I3cGJ3K0NmY3dCU2t5ZUZFSEFVeC95dzlKVHlFYm8yN0MxN09sM2FGV051QWxnSW45UXhPMnRZZk5sYks2TXZheGVNUllxdXZMOXJUY1BnSjMwVHVIOExjSEF6TU91Z1gzUUFMbzIxV1hCWkxFSHdSRjFPZ0hTMmVPZ2JnSVBIQTdQSEFlek51N1FGV0ZaN0puWEo1cm5xeEhFdWx2bHp3eVZOTjMrd2VybjVZb3ZsN1NYTEd3dm40cmlMV080ZmdNUkpYY1BkLytwbU95bUVMRWhSekJ4SkFvOWdWTDRrd1ZuYnNMY2NnSEVwV2kzZXBvY0NBTWVCUlU1ZVRjUGl5LzZxdGwwd3B2aEErMmdZZk83TndPUW00T0JHWUdhRHMrNUV4WURHZ3FQK2NjQWtJTmFWcEI4R1R2NGQ0T0J4d053MllHRnJ4WUNtVjBZeExOWWhlQ1hhdTdFaFYzZ2EzTGI4ZzQrUjQ1dW9HTEFEZ0hXcWhzQlhBOEsxQVpBRHlSdnV2dGtCU0FyaCtpOURzUWhDT3RmMFVVZ1cvN2FpWVcvWjArblJyaGl6b3hYd0ZoeUFpNXk0ckdIeFU2NnFBRmhUM3JEU0lWZHBHSHplbmNEZWpjREJEY0RzQkRCUDF1WDFDTUpSd0ZpUUlCenhpZUwzS0lZMVlXNU1QT3hOd0xSYjhnczBhZ2hBc3MxR1oxTytTRkhzZFJQdDBpL1BMSHUrK2RGYi94NG1YZmhjYld4aGZDdFlNRnIvdVd2S3hmRGFBY2c3aXBQQ3ZGT1ZwdW8zSHJDallXL1pBK3JScnRpNlRTNk1WUStMNE5QSDJueDY5OEduWEYwQnNLYThJYWI0ZEZacEdIeitKTEJ2QXBpZXFBQTRKOENQT1F1T0JCQU9WMENVWWJJc2tSa0FlY3J2QWROYlhjL2FEQ3hTcHlUNENFSXlUZ1JnbmVpTElwM25QNmZzK2E0QTROOEI4LzQ4Q1VDK1pHSkEyOWZwdUxteEpXKzVoNWtORmcyamlXSFNpMHIwVXY0cENvWnN4dzhEVWZuaGQ0VmswWEdkR3ZhV1BhQlYyaFZqZGpnQTBCbHBrUS9LOWJtbi9IT1ZxdENsdktFQnFsZkQ0QXRtZ1AzakRzQnhCNkRBN3RkYmN2WXpKdlFKa2lpMm40Tk9lTXBiZ0prdGJZUEdBQ2lGM3dGb0V4MVpNTmUvNGpuUExYdStLd0Q0dC81U08vaU1CY1h1ZXNIeWx5QUNNQlBEZ3pHZzdvcE04bUVISUdkd3JmR0ExckMzN0FIMTBhNjRZcjRBUHZ2T1Nkd0VQT1ZiS3h1K0sycGRLUlRtZEkzZHFrUFBWZ2JTVEJHQVk4QXNBVGpXbmlCZHgwUXhKeWxPRkNjcjZIQml3MVAvQ0RnVTNFZ0VJTVc1Mk04WWtMb2xRUmRkSU4xQXlLV2lCcmV0ZjlNSlFONkhzYUNQeGU0cnZnRGRIT2NPeERJQWNtREZEWHZMbms0ZjdZcXQ2M2dFSUIvWW9qKzRwOXhhQWJCSGVVUE04cUYyYVJoODRRUXdOUVljR2dkbXg0QzUwV3FDRm5nTnNnU3ZRK0R4dTRNdWlhd2h3SUFYVmsxTytlL0E3Q1pnVGhZMWRjbm8xbkhMMm9ESXlaVUxwQnNBRlRCWjlwalQwUVFnbjJWNnVmUmljUzhRUmdiczVaWXBFc0VORGVqQmZwb0xyd0FPamdJelpNQlJaMEFIb1VDK1NPQTU2eEp3TmxFeVRGdzVGeEJQZVd2bHpwbmJBTkNkUTFlU0dUUnliTXV5ZGdNZ2dWQnNLbXRZb0M2TXQ4em5aeHNaTUx6QXhvQU92c2greWREcXRYeDRGSURsOEwvb21RN0EwUXFBODJTL0VSZFRJMjJtTmZhVHVCSUl4UjRCaEtlK3k2MXB1blFDK015dEkvWnovYzlFdXZ5QmVldExBZkdaNVdPTVo5ajIvZ3FBQkIxZk1Mc0hBVkJxaGZUY3lINWQ5TUJ5RWR6cytCNTBaN3ZvR1pYK056TlNzZDhjd1VjRzVBU1JLWWJkSFJOWXdoaERJSFJnR21PMGdGUCtISmgxNWpPWGpueUtibFZUNUNiZm9xK3lKT3N6RjhQOCtWbk5QbElDa01BemRzL1lMeGxZem5ySndJcE82ZWdUUE1xQTVaTkRBQjZpQ0NZQXlZQmNCcVRSUTBlNDYzMFN4WnlRSlFJdk1KOG1TZUxyWWUrcC9HekdmblRwRUlCeTZVUy9vdXQrSzF3ZyticnM4OHJIbURPZ0FWQ01uckVmeHhNdGUxTXQ2ajd1OXp6S2dJWHpjekVCT0pJQjBCbkNKb3FnSWZERWhNNThTV3pKRVBHSmU5aGZWSDQydW4vTWZ4bDliZ1NpQnlTSUJXbkFKQkRHRURBQjhRV0ZBOHdPMy9hK3dINCtyZzRSTFBZTHVsOHRDSThDc0ptSk1RQU91d0ZDOXFNSTlnOVowQ3hoWno2NUswd2ZGQlBxdTdQRXlWZFdBT1RIVmxUY3B4aFhIWkx6MXcwWkE2RURMaGtDc2tSZjBzdzRkUllDMFBRL3ZWU1JBWVBvN1FDZGo3R3FWT1NNZUJTQXpVek14WmNETXdMZ2NLWC96YnY0NVNRbEhYRElnYWdKYytialpCcUFXaFVvSC9ZK0IyRDBKN3JGYTZMWURSbXpvbXNBYU9lS3F4RXZiV2FjSFFCMDhKa1JJdGVTWGlTQkxZSk9MQitYNHhyekF6WTd2Z2ZkMlM0UkFLa0REZ1B6TkVBSXhNQVNTV0YzOFdzZ2t1WEx5WFRSU1JDZS9EZHVTWk1CTXdlNk9iVGQ4SkJqMjRBb3QwN3VET2JQUDlYc0l6VUdGUHM1K0pKL002b1Q0YnV4SHY5WDdCZVk4S2dPV0RnL1o1OEdUQzlYcTVGeFRYT3c5YzNDbTZrNWZQY2pnYkhiZ0FsdlZHMnRIMVQzT2F2b3E2QmxuaVorMTJuNXUvMnNEYk92YXNxb0ZnOHgyTG5iY2QxR2RoU0FoWE4rN3FNckFDNHNBOHNPUko2eUh3RDI4eitGdDRmZHY4VXlxVURyRG1DRUJjcFozOWtMUzZhcTlsNEQyckxiL0tZc0ZUUFdkZmJ2aDg2dlF1MnMxSy9LK3pJalRzWElWUTlhNTlFZ3M0WTZzWmZJQS9FY1NwL2pFWHY4QldjQWh4YUErU1ZnU1FBa0dBTUlDY3dWbE5MbHFUYzlHYnYvSEFBN01yTDQrZjFWbFh3clVxN1N2Q295R2NycldwR2h1dXIyZk5HWXdNOFlUNjdoVDNzMUxhWnZxbjVNTE0wYnptSE1tSUZTZ2RGTmovbUlCY3Q2M05oRlp3RXpEc0JGZ3BEUGVhbk5nQVRmQ3RHc1g5VElLd05yZzl0dVZraGxuZzdUSS9ZQXJYMVZrWEtyRWUxbDJTeW5OMVJDc0ZKc3FuUXYzVUlNeGh3SVJqVTVBR045UVV0ZVZ6M0JVQXZhaHVOZ2pDM0h4TEFORDduQnAvY2dPTlhGNXdDejh4VURHZ0NqS1BidmV2bHpjS1VISDJhZzZjbll6ZXBZQkI5WmkyRnhESmRqb1hKdjFXREZpTEo2TUtxS1pVem9RRlRmajJIbXdUS2NUcFZXdmN4SEttNmtLZ29PUkFFdlZjbFBENk5kekxYcE1UOElZTlBjTFY3eUpHQjJBVmhZckFDNFNOQTVBeEtNOXJ5RFBFNWZzNmVlVktXR1oyTTNTM01RZkV5SlVLVjhMMVpwSlhwVko5cExpbG1sQXhXa1ZKSEt3SWhqakQ5VHRWWFZtMUhkT3kvcEppYU1GUldNK2JvMHJXbDR5TTFON29QaFRKZWNDOHdSZ0F0dEJqUVdkQkJHRVN3Z1NpVjBQYjlEUmd1MFRZMTlOK00xbVJLaDhuaXFGeDNyUkRzTHFqZ2w5eWFHWFQ4MHZjTDF3bkUyNTJQQVpDekFIUUNvaXFvVzN5WVdGSXQ2NjRmVXBLYVJFcjFOUGFrSDZYa3VPUStZRHd5NEZNU3dnVThHU1JTejBVSngzVngvNXZGTmJycy9FaUxSWSt2NEFDSVR3dzZpSkVvZFFLd0JJeUJSdjl2d2hLelVXNno2NlRVR0V3aERTM2V6cXVzQXlOeG5Kbjh4YTFLUlBTRnRzOVlmRkIvUURaY0FtNzhDbkRCVDVVOHJDcWpmYzN5aDhHbi9oR2QvTXNLZjErUXpZSjQ4OTFKeWUxM2l5MWNBRTljREorNkZwWXJFa2lkeEROM090WFIrRndCR01lem9NbXhKTE91bUF1RDRKNHJ4SnJmZEgvWENvTEdGVktpVWJ3K0xBUFFxV1dhTU1McmQ2LytKeWNTSW04NXc5bE9wdDFqMU13QXdGVGlxQVdFVXhlWUg1RU5uL2pJblVWSGVNWFEvZi9qUmVQdkNhNERoVHdMSGZCYzRmckdxcWFOSnpMUHc2aVp4VitIVHBsRkd2WnJYWlQ0NU4zOStIVzNUdWpsWnY4RDZmcDhIUnE4RHRzOVhJT1I1WXRha2dCZ2RycnJ0NVFzcThTc2QwQmhRNEhNd21WaXRBV0hBWS9MYkxEUU5RRGFUVko4UTZXNHFWQjUxT09xRFpEUFZCM1RMT0JlcFc1am1xYUxiZWMzakdnQkdNU3h2dmVtRFlrUTlHb0tGMVNoVUNTS0NxQmVRcnZtZlZaUEMxa2VCalhjQ213OTExdFRKOHE1WGdPTGFRZ0EreC9PZFdBMkVHWjk4Z2JqbGVUSGRRSFFOKzJpd2xzM25LMy9aaGozVmVRaG92WXpkeG1BclN3UWdEUkEzUWlTQ0pVclRuamZsNEtvelJDU0NDZVltdDkwRW9KSmJWQ2svMStGaUN3Rlp4TGs0ZFJmTEZpYTZ4OExiWWtEOXY5Y1h0TEc2K080QVlRUmZyZ1B5Z1ZJY3F5aFRYY1dGT0pIOGZoM3J6N0VLd25VQXJxOG1jR3dLMk1DQzFpN1dZN1plbmg1NmZlSFQvakUzeWxpRTRUWm5jZDYzNmdQRkNLV2F2R2hjUngySitjdnM5TWxTdzBUeTNjQ20rYzduMEcwTUV4ZFc0Qk1JYlRYRTlVQ3ludnlDQ1grT3ZtNGdiQnlBL3hpc1ZnSlBwWHJ6TGo0RW9SSmpKSVpyV0hBclM5aXBySytLY2VmZ2l5QjBYVktHak9tQ21XOXhoUlZNVVN5UkZuTmVGR0VkSTJxKy9IRlhjbGtwOVdzQWJnVEc5d0dqMDhDSTY0V3hSay9PVERjVUF2QkhYU0xReGNWQ0RNUVNXYnp2KzFlN1dWYnorazV3MnRKdHNiY0NZVjZXSlk3aG1Bc0RBN3IxU3ozT2dPZ29NK0tUT0piY2pTSTV5R0lhTkUxdXV3bEFBVS9NRit0RjUvMHNJZ2hWTGRWZE0yUzBiU3pIeDJNaStGVHhYZjhYOTI1TkM0QnljSzhRd2ZtZ1ZYMUxsY0ZpeWtFTWNMMkJuZEpKN2FRZmlqS2Z4TEdEd0FoQnlNN2FDNVU0cXdQek53dWZObk51T0g0VlphQ1BsUG8yQWFocUZxb1BWRmMxNGdhMm0rV0VFTDBjQXo5a2RQck9tTXU4cjFvL3JUc1h6N2Y5b3N3RnMrak82TEFxa3ZDM0dnZzVGZzZtd1cwM0NVSTZYMTJoOGx5ZmN6M1FIcXIzRElsNjREYnFhUUtjOW1JODdRWEFDRDZ2cEpxWTBFVnh6MkNFeUNJNWVNU0dYMmU3VnRJNUo0eVRSeVpoc2NydnQxblF1aXZPQWFOTGxZRVN3Y3lTZ2lWYnIzN0JmZDAvdTMxeUVnZzJGVmFpUENlVk9ndXFBZkdvdjBpUjBSOUpBQkowYm53azluTXh3K2ZPaDU1RWJnUmh6b3pyQlVBMXBvbE45Q0x3b2s1SEVFVVFCakZNUUI3RCtqNjU2UFcrSXJKOE8vYkJDbzRzR0ZkR2VqcWl5WUN4M21LZTkvSnRUaUJ2bUk1T0ZpVGlzZzlMdEpGRjdnWkdEclViSEtzNzkraHl1NWhTYVV2aDFmb0ZyM3IvNnZaSkNpWGdDRHdWVkZKN01WbVJMc3JHbHR1RkNjNjh5RmRBQ01EQWZsd1I0UU0zSFBvS2dJRXh0NGd6NDJTdWFRYjhoQk9FMm9abWx1K0tGbEtSM1FTc3NNSnhEUFdiYmpwZkxvSnJ4RzhDWVQ4TUtHWlNWVEN4WUZUSWI4NG5rQ3hDSVBMRGlieTMwZ1hGZ2hhRjRjMlJlUjQ2NlV1MmZ2b0ZyM3IvZktBRUZ4dnBxTWNkOXlvbklya3VLNUxMVjdNVkNNKy91REpDeUlDMko4YTB6MWl3cXlFU2dNbDE1U2EzM1FLZ210UEVCbnAxMW13dVhnTzcwVWQ0REhXemZnRFlDM3pCRU9rN0hsQTZYS3lIUXpiOEhnR29DU1FMcXN4b3JJeTFCeGllN1d4MHJGYWYrd3I5WHYzMkMrNTYvN0hiSjVWSHRSWVQrR0pyc2VoSGN5YTU3UHlLQVFrNit2QmtCWlBwalBFRXhsd1U1OWF3ZzNDMjRXNktCc0M2dHFIUitNaWR5VkczaTNyZEFuQXNIMlQwOTNYVCt6THIxOTdNVEE4MGgzU2ZzWlAyVXFwQ3JQUTQ2b0YzMTdWcnBlaUtYVEo5TWhNTGtnR2RDYWNLRy9tdXBWOXcxL3Zud3lHZ0NEQ0tXekplM2xxc3l6TFdaV2U2L2tjL29LemdLSDRqQzdvb2xoZEM0aml1ek0wV1BvK2NQUTJBc1gxb2JGQ1RPNUp6bjU2NlB3YlJlaXduZlRXakk0S3ZEb2gxanVoK2FUK1dLU1lEM2k4QXFsMnJKaytWc1ZRbHk1a2tkZHYyRnZIVDYxaWNxTzdGcjcxL0lrTE5YT2kwRlFqVjAwNDZvQnk2d1o5MjJROTVJQ3FERWFMNFhXdzNDT2NmOU13NzNERkI5QXFFNndaQUFTOFh1ekdRSURLZitvVmtxeHQwMHR0QWMrWVQwUEo5cVJGU0I4eG95ZTVYdTFaVmVDU2dDTGJZTFZOc3dvbmNIeG9lTHdDekJHakJOa2kvNEJYM3o5bFhnVUN5SUlHbWhvdmE4M2NSZ081VGU5eUxnUDNNZm1zQlM4eHM4L1U2N2VQUU9xeTl1bUJVcnVEY2hxbzhzSFNkM1BNZlQ1aWZvK2FjazhlRkhJNlFFY25UNUd2ZE9uVmRYb2YrcHRKK0JWUFdjZWlhUkhBOFVzL25rQUNvOG16cWxxbVdyYkZEcHBUNUE1VUlabTdDUEEyVmdtM1Fmc0VkOTA5a0tJcUIxcUpBS0NCRzhac3RaejN4SE9BQWl3bXBESWRuZzFtYVpRQWtaenNIWjUzN1lmUXJ3Tnl4b1ErSGFrcm5TMGgxbVVBMUM5NlRkSlRtT1J5aEMzb2VxZHdST2krR0Roa0ZJNmJZTnJjTkRFRGVBa1h3UWl6UFJwbW5JczNPZHFaUFNhUkZVY2JjaEhsZ2llNmFncTJrWDdEZC8rZDhsVUpWWHVVems4RVJtUysydmZkNHV2TjJWT1Y1clN3YjB5M0poZ0loOXdKZU4zWU1RQ0lnUjc4UStuREVWWUJZWlVyVXBiWEZuTTdDT1NkZjdONElQdnREblQyQlkvaDhDaGgxME1YUWVZR1MrN0dHamFRaUFCcHVOSUZpRUNuemRXSk1JVUhjYXpMcHRDN1lpdnNGOC83RmdMRk1xcGlRTDVUdU5iS2ZBL0RDNDZycXFBYkF3SUtXSyt0aW1SVUJFaU5Hc09Rc3lRbStHcGpkNG4wNDZoYlQ4NEtQdVlqT21ISHlwOTJnY2dEUzJPb0l1VkllaC94eVVrYVZ3eUVXZExyZXdIRTN1QlVEY0tJd25xNDBIcERYTCtuM0N6YmFLZGd1ZWw1Vm5GSmwyYXdhZ2hMUUJUenRlWjBjakxxMkEybjBNNkVQaDJwQzU3V2c0MXBvTHpac0FaTnNvMEh3NmVWUi9KOGJGOVlqV0dtVkNwR0t3UUxCUkNjcmJpU3hOTGdWQXhDRjhYU2w4WURISEZQVzd4ZUZCUnd2L3JHcU9LVUJrT0R6cWdkV1BZQU01M3ZUQVNNUXU0Qng5Sis2OU9ISUYrTjcxRjFPMWdVQitBc0JmRnFLQys0V2k0QldYK0NZZ09UQVUzNndkTVZOVktrYTNNb0JXQmhQeHlpdWtvM3hrU1g5ZnZHTWtxc0RsenpIQzFONlNRNERvSU5PZTdLZWxXV1RoZXppT2JlS0NkQVJBcEQxQWRWblJIMDQ4Z0tVQW1BRVlpNk9oNERKVjRWb0dEV3FqcTRYTGJPNW8xakJvaW1FUGhQSm13dTlGdm5UTGdkZ1lUd2Qyd3lYYk15UktlbjNpMmVYWEIyNDVGbFZZVXBWeFVwR2lMdG1HQmxyVEVoVlV3VjhkRWtWS0FxM01ISjF1elJiUngrT09nRFdGWDZNc1hKVS8zNmxKb0VvQTJBS3Z3OCt1d1RFRElCYlN0ZE9zOGRkRHNEQ2VEb203WmRzekJJczZmY0w5cm9yMkM3NVVTOUl4SkpzRXNIZEdGQmlsNHlZdVV3a25vZkpnRjRYY0VVZmpyeitYN2ZLbzRFSkovL1BrTU9STzZGclZqUU1lTDVrSmhaTU1Yekx3TlpDdDFuekRGZ1lUOGNRd3BMdDRoRE9OMGkvWDd5czVPckFKVmUwUy9JU2dGWTdqOVp2blE3STMrbHlxcFlhTDk4Q1dwL04rbkRrWmRoaTZiVzhBbjFrUDNmUlRMS1ZXbHdGNlJaQ0gyTDR6RERSMGsxSXFlVE5iMk9RU1lOYk9RTVd4dE14ZXF0a1k2SStueTlWRXo2YnRmYjd4YytYWEIyNDlBb1h2ODUrdElCVmdKSjZuNGxmNm9WK21mamRESk5NSDB3QVZGWDkwR01rMWY1VHhsUzNGZ2doOTJEeU4wSU9SeTU2NjVLSWZDa3RzbCtLM1ZzR3RwVk9XT01pdURDZXJsU25qUTJyQituM0MrcElCZHVsejh3cW9uck5QTEtnd0thQzVCM3M1M3FoWFZxNm9ETmc2c09ocXZxaEVyM1YyVk5MQmptblNTTmRyT0xKMXprQXU2VlBSakZjRno0ZlhESjhpNDVoRzk0R3QzSUdqT0ZZQThUVGxRWi9xR0gxb1AxKzhadGxUMU1BdEhLOG1RZzI1ek9aVVNDTElsaVdjYnc4d2ZXNUxuMDRzc3FuSFgwNGV1aUNrNi8zZGU2Nk1QcHVBUVZaQUVGa3cyTUtGdzZhMXdFTDQrbFNCdm1BT01oRDh2a09rRlg3N2ZlTE53MTRZVC9zc21jNEE2b09kSEJFa3dYbGdqSDJrNE5hbDZ3QjRmSXVYOUx6WmpBbW9yTmVITW81VGMwT2V3SHdEVFVoOUhYeGZHSnNZa0FiQUFBZ0FFbEVRVlMvdXZDcG9BY2V3NnpCQnJkeUJsUXd3b0R4ZExaV1hMREZrSHlGOHhHRS9mYjd4UjhYWEJ5QUFWQzFvQjE4SFFZSVQrOHVHZlA3NVNDVXMxbzY0aGU4djRqNmNJUStJcWtQaHhyQkNIamRqQkg2QWJsUWtBZVkxb25kdWtTaUVMbXNVUHBqYnlwN1h1dkRnQVh4ZE5aVnZXQ0xJZm1LZzZCYmhyanVwOTh2M2xWd2NRTHc4Z3FBNXY5ekM5akVydXRsdGc4Z014RFdXTUJhTVZrbUFOV0Z5RVY2UjB1SDJJMUl6Vzd5cGJrUU9UUDVmMmNoOUtzRmt3cDBrUWxEQU9teHpIcHNjR3VHQVF2aTZWRDRSZ21BZy9iN3haVmxUNU1BVE5Yd3FRYzZLR3dmMlUydUdWMnV6ZzNENHVhN2ZEblB3WmNLZ0lkcTlHYUlCUFpiMFlkRDdoZ3lJRldNWGlIMGVRNXZYUzVIY01rYysrOWx6MnQ5R0xBZ25zN0t4eFpzQ2tnZHROOHZXRCt2WURNQVVwY2phN2xPUjllTFZjSVA0dGN1b2IvM0FPSENkVzAyVlRYNjJBcEI0TXYxdjI0Z25QeTlIaUgwM2ZKMzY2S1lIWVRIc2dCQmcxczVBeGJHMCtITFphT3A2NWkrbG42L1lNNUV3ZFlCd0dqMWNtVWtFNys4VEhMTmRBSGh3clVPWHRjck8vcHdoRjRjY3Qyb042OEJNRENmbXNKTS9uNlBFUG9ZUHA4Ykgza0NrYnRqamkydEpKQTk2MllBV0JCUFowV0JDcmJZc0ZvT2Y5cERBaUVOazE3OWZrdXZmOW5UWGV3S2NCU2pzbjdsZG9uV2JnUXB4KzI2b3RhTEl3QWxmaTJRUVNKWTNZank1aTlkbXNGTS9vRURNTS9aN1VmMFJpWVVBN0orVG9OYk9RQzNlMFdCQm05cUxhZDZISUNHMVpLMVhCNVBveG51T09JY3hTWGUvT2Y4eEhWL1ArRnB3TjQ3Z0tVcFlIbXVTdmUwcEtaZ0NLU3E1d3FuaVdFMVdaei94b3VCbTc0S1RNd0JJMTdsVkJYd3RXU3MrOC92TDQ1RmYzdmhwY0FudndvczhkNDhEWlgzTTJoeDlYSUFudTBJSU8wY2h1MzVBT2dMTDB5dUcvak9td2JnMDI4Ry9tTnoxWVdkRVRibTRJNUJyRmxvditFdEQyd0lvN2wrQXRnOEQyeFk3aXczVjVkaUVxTzU0bW5qNlhkTUFZY1UrNmdvbjdBM05TTzJxRmpseVpZRGtBWDZ1RDVJYW00NFlhVWZWTkROeGFKY0xJUFhjR0dwZmk2UG5aZFZEMXdQc3BRQlgvd2w0T2FOd042SnFnK3h3cnhzbGNWRnVZSmJsZWhrY1lZWkdQUzNMMjBCeHVlQmNTOG53ZzVINWtaa3g2VFFTYlhGWmNDUUthZHg1Q3o1bVB1ckFGeHJSYWExN3BBUjJQRkMrRWxTSEtRLzBRalFjZ0N5R3lNOXYzU25zREJSSmdMNm1zV0NmNklmV2VVSmFjOFVGbHBZODUwMERjQ2Z2Z2I0M2hpd1p3eVlWaGQyRC9WU3JLR0FtSURuQmtpYWZFY045Y3BySGdLTXpnTmpTMVY3clJqUmxjZXlycWlmNktBa01nWElNKzZ0QW5EbCt6U0wzNk85K1U4cDlqR0hRbzI4NS8yWEEvQW5YZU5uS0FvckRYSC9BSUx3YlN2TEV6NlFsMitjQWYvM1hjQ2R3OERrS0hCd3BPcEZiRTJ3YWR6SWR5aDNqak5RaXJZV0V3WXErL3pKd01oOHBmK3hLTlN3TTZEWk1tek5SUmJNMksrMklpNlRsRnJBV2ZkNVYzaS9GN0lnVDJMQkY1TGJJZGtxeExQV3Z0emxBR1EzUnBVM1k3QWlpeE14TE9VQjJ0N3BLUThNMHFDVG5wOEhrb2pKZ05xYU1FSmVzUXY0QVIzSXc4REI0UXFBcys2U1dSaXFnSmdZMEhWREFkQkE0QmE0eE43bmRsU0ZBQWpBWVg0SVBPNWRCRE1BZFMyaStKeDdYVGYxZUVkVERmZ0FRblIzNHAvd1FrUm1qTkFvQnlEVC91Z0ZwaFhBbWpBRW44cWFQUUFnWkNzMGxTY2tDTm1WaWdFYkZNc1BCQkUzRGNCWDdnTHVhd0g3aG9BRDdFTThETXc0OEFoQVRyanRRd2lYb3FrVEV3V2Q3TE9uZVhOQ2J6NlRpcS9USW5iMk04WnpJRnJUUWJHaXk5Mm9HejdwWGwvN2p2ZEFKbmIyNDcwSWJCM1Q3N1NhaStoeUFQNXZvVHFXNnNLd0ZBYy9UQWRjNSszZHZjc1RydlBWWVNLNFNRYjh4VjMrNklhQXFTSGcwRkRWaDNpT0lGVElGeHRpdDlvckw1Wi9MRDFRNHMrQjhPbkhWdVh3aGhkZDVEb0xHc2dDQ0owNHE2NlgvSnUvdlNhZUF4RFB2YmR0bWR0S0RWOTBnVkVQSWwveHlTa3ZpT2htQUVqcmx6U2t3ajQwU2xRWllaMzlJKzhKQk14OG1acnloT3NLd3FZQitLcGRWU0RGdmhZd1BWUjlCRDd1eVg0U3dSUzU5bk5JK2JSY2svRHpKMDV2MTJNMG5ZOGZBazhpV0w1QkI1cUFTUEdSQ2k4RVZqenYzbXFwa0M5QUNycndoS3VrQjY3R2hwcVJSb3dRTXFDaVliajhvT29IZVVXcGRZSUJBVWo4YzhXanJqeWhOSUoxdW56akRQanFYZFVqSkFBUDhUTUV6TFlxOXVPSElDUUFMZS9Fd1dlK1FnZGRBcUN6ekQ4K3ZnSWdnMHFwKzVuWWphRHpDZ2ptbkNZb25lMGtscVA0SlNndnZLKzZMb0ZQb0ZNbGtQR2grMHJQV3RhNFJIVE5KSlF6NE04RUFHb05UUFZVOG9wUzY0Q0M5em9BV1RGQ2hjcTdsQ2RjaDZzM0w0Si8yUUZJRUJLQTFQOW1ISUJtaFBoM0FpMzU0UnlBQW1Xc1IvUFJzNnZPUjhaOEZNUFM5N3l4dElsWWdWQi9JN2pDMHJJS1NmTFhGMUVFQitCRkZqUTNqQ0xBNDlPV3NSVFRFUHp2elFFd3J5N1ZyWjVLd3pBUUFQc3NUOWp3MWRjSGdDck9SUUNTL2JnbisxSHNDWVFTdmVhSGt6dkd2MXNjZ1UvNlI1NVkxWUl4aHZPbTFFWmVrUVdsOHdWRHhKZ3djODhRaUpjNkFLWC9tZUhEYXdYOXoxNk0vRW03Yk84UTA4R0JQL2pFa0FFVmpNQm9BRldYVWpSQTNLdE53T0JYVzNFa0FaaHJBTGt0cEM2bEt0VFY0T1U3UkhCKzNrSFdndi96cm5ZWmwya0NrRjR1RjhNR1FHYytNcUVZVUNBMG4xdGt3eGJ3NFNjSEFIcjcxUTdXNCsrYzhjendjQkFtSFZCL2M3QmNlazliM0Z1d2JkRC9rakdXZ3pKalEzdGhHbVZBM2poZk95VStSeEI2RmFtT0ZwOE5yaHNUZ0x5OENwem01UWxWcHRBVSs2Q2lOZ1hDYUlRMEJjRFlWOGIwUDRwaTMwdmZJeEQ1K3c3MkM5YWxpZWdXOE1IenFybWgvbWV1RmhZaTBwS2JzNkQ5ZnNoL24xWEZNcllNYlBnVUJ5Q1p6NkordUVrbkRBOUFvcm5XRlJiMDFXWkVzQUNvSGhPcXlDN3dkZXRUMFFBSzJLcU9iNU1DVXZQeWhMRTBvUXh6cWFZTlhMNXhCdnlWWGUxMnZCeUxBRGpYQXZneEJ2U1BHRkdNSWpDbUpiRVc4SGZudHh0UW14VDBjbXhwOVVQQWRLQVoxdXBBNkVCN3FnRG82b0NVeFhSdFBWU3BBd0pwblVodXhBcVdDQ1lLMU1CRXhabGpZNVM4U1lyK3B4QUZBdUJheWhORzI2anc4dXNDUUxYMFNBQWt3d2NBRW5neVFpemFYb3ppSWxpK09lNy85a0p2TmsxTG1CTWU5RUNPM1hSQjdhUGVGMEVZSE5WUGRUOGdqMDE2WUJjV3RCZkJWWUp1ejdtRjdWZ0dZL3BPOGY1V2RRMS83VTY3bklLTlM3ajB3SWJEUEZac3lOSEhZN29kL3hkbEVIajhDY0MzVGdDV0hnR0FQU3hpU2R0NDMxMnUvOFNQQWw4L0RsaDRwRGVaVzJQRDRKMWM5K3V5RGFJRGtnRUpRS25UZkcvTjhuVUFtdTVIVW5NVzVBUmJQZkV1SUh5L0FDalJLN0ZMNXBPUjRSYXhnVEhvZktsOHIvUzFaV0JuQUdES2VmYm4zQUZJUFJQWEI3c0ZpVlFpbUtWZ0dkbDVvb053TFExLzFVK0RRR1NYUTlyNUV2eTFxOXJaYlAxbEdRRFpzUHB6SThBUEhnWGdvZDdxVXgxMVl0QmJGekMrL0MrQkw3U0FXd2hnZG9Ma09OU0xxeTVvTG9nWWZ0M1pJMUY3RUFDK3Boc0FuZWtva2hQNEhJem1sL1B2dGhRV21QQjlMSjdqeGtjU3IxNGpXajQvMHdGbGdKRDVlb0R3NmZlNER6QVlQSG9rV2hISlozVEZTa240aDdZT1NPQndFdGlNVHYxYVkwdWt0RllUbUkyLzQzRU1RbUN1QUptVUUwZ21WRDhFRmRQcGRueGhWaHF6RHI4RjROTXRZTTlKZmc5OEVWVGVOdTlRMk9GWkJYN3ZyOXZ0Z20vbGNlemN6WjYxWk5OOERDdmlsWUNkUFhxTkRRcEFsZkdUS20wTTZBQTBQVEF5b01TeDY0Y1JmUFFIWHNuaU9USStmRVdERkdwK1FiOUJleVNSQlYya3BsMFF4eEdBbEhEbWtJNTZYNnorRVA3VURZU2RSZ2gvSW91d0laMzZsSGFiQkUwR0owcjEwUmdiL3hBL3R0L2ovNmFNQWYrN1I0Q3h6dUJYV1JHVUx3QmZJclk2VU5mcHZMYWU3bjBJK0xPL3Jlb0xNcWlWTWJXMzhvVWhrTmtRSXpaTzd0SXdlR2VQY21XbEFGVGpBWUhQVkd3WHhXb0xZYmxFRGtMdVRUOE1EUGhYTEo0akFMcGFKQitnZ1U2eGZnSmtuVDdJS1hJUVhoNFkwRlpDb2crd3hpVVR3U2tYVWJTTVYxckIvQTMxT1hXdUZwUFVkYS9tUkhLaTFlNlUraEE3WnE3bCtBK1VBZkR0SGcvTHJwdGtRcFo3MjdjUldPTDk1NDJQYTNyT3Z1T3FhZ1VsdGd0bUpNMDhqNC9QSUxiSURLejZ3NVBBSHNicmFUbk1HZFpXSXdJenhJZmVLMHJuNTc4SjNMQVZ1SDhDT0RSYWhWL0ZGUS8xSXVtSXZYUDFRdWROZnlOVDhvVnFjSHZpUGNCZDQ4QTBnMlJEdW9EcUhkYjJTYWxaQWRHOWRuZkRrQUUwZ1huSDVpaldDRGJLQ3E1L01SaVYwUUQ4SGdIUTYzakcwaGRzTEd4QTN4OUJ3MUFzbGk3aE8zQndBcGduZy9HanZxMDFJSHJYSjdxM0N6N0UrK1l6aUYycnMxWkxaKzhIOWpKc1NvRUNXWGo2aWdtUjg3YUxnZmJHcTRHdmJnTHUyZ2pzSHdkbUNFSVBTSTFoK1NrQ1JqcGZVQzNpTldjcG9ScmNucllidUdzVU9NQm83UUJDeFNURy9pZ3hWY0JJVkdQV00xaDFKWVFQbnlLTkV4R1pNRElKOWI2NmVFQkd4UERZMVk1bnYrR0NqZkdBeEQrRERwaWF3cGhBQldaUGp3TnpOTEFFSUg0WENIME03LzVjOTNiQmZJOFlrMmNnVkFkdmRUMTBpZkRrQldDL3I5bEdINTFOaElzbnNXSE9mUG1FVUtUOTRXZUFHOGVBTzhhQWZXUEF3VkVISVNOUWxLUVVnbEpqSkV4cUMrSDZOcTkza09wVWc5c3pid0x1SGE2NlF6RldrYUZpZVh4aTZoZ1ZIT01DWUdSdUorNVY0allKSURLSTlLbHNBdkZEcThRRHJuYjhOV1ZQaDlFd2RGa1E3OVRsU01Jc04wTWk1czlNb09Hbm80VTZmM1lBdmVmTDdZN3J2ZG9GTHhPQU5TQThmN3hTZ1dtZDBrQ1FibVo2bVRMRW5KMFVxV0xoVWt4bHJCbjZuM3dXdUdrWXVHdWtDc3VmR3EyaW9qblJGcGFmc1U3TUR4RXJKdVpoWUNzSm9zSHRXVGNCZTFvZXEraHhpZ0pnWEJyTW1UQlBuSktMcnIrVkVENTRpYkhZdlpvczhzTytETmNySHJEWDhZVlZ5Z2xBS3VkMEx0TWpGUHROTXo2UUxEWTdWb21MSmQ2NzFBRUg0WHUrM2c3bldxMjhJU3ZYNTgvaGd1T0JnOHZ0RlF2Vi9oRXp4ZnFPZXZ1VGZwanJpOHZBV3o4TDNOWUNmakJjNlpZSG1CY2l0bkZkMDZweHliOFc0Z1BsZ29uQnFmZlR0ZFRnOXB5YnFpVk5Cc3N5VXNkVUQ3ZUdPOWFtbmYzc1h0eFFpcGw3V2cvc0Q0QThBd0hJeVpNWWt5NTBUcC94Z04yT0w4eTA1MXF3MmhYendSQ0VkVDJubWNrMVJ4SEcrdzVqZU85TkZRQnBSNmxkTUlNWGxGV2dWbmRxRjJkVkZzSnp1T2dSd01FbEI2RGNJNnJ6bmVtRDBSbmJ3UWlTUlMzZzdaK3RWSWw3UEM5a2FoaVlabTZJaXp1TGlnbGlUL1ZvVW9nK3A4UDlsM3dKN3FHRWFuQjc3azNWY3pyb1VUb1dMQ3NBQnVkNHlwYUxDVW94ZjlpLzl3OUFEaUlDVUxyUVJXdUlCNnc3bnVacndhWndMQkd3Q2xTcVN5ejNBaEhiYVJHRUZHT21DNDRENzJVVmdqVzJDMlo0bElGNEFyam9kT0RRY3FVR3FBeGZjcEc0bUpWdVZxY0w1dGJzMnovdmVWMHRZSy9uaFRBcWVzWU5IZE81UENKWm9zK1d1enhISklWaXVYRnlKeHVwTkxnOTc2WksybGl6VUtvZGlsR1VnenlHaG9rRjh5dzVNZitxUmtqZGpmdUR0d2trbTdEVGtOYUJhUTJveDFxM2VNRDgrQjZPM0g2ZW04S3gxQ2N4OXB0V2w5aVlJVUFBV3JJM0kzbkhnUGRPdHNPNWVPdXhYWEJkajBWMXZPTC9zbzNDeGVmNjB0bFNwWXd2ZUtmMHBBdTZvaGZkSjhrNENVcWd2cjVqVjZWR1RCS0FMZUNBaCtWYlpMVG5oNWd1NkQ0NEE2SDhjVmxrTks5NU8xV2tCcmZuMzFSNUhTeStKQ3dQcGxBeFJlZ0UvMlQrQWxvR25jTm1iUXlvZ1VReC9Ld0I0Z0hqOFlXTlR3UkFPVzBGSUlJbmRvcU5rVEF4ei9iZDA5WERHTEJkTU02L3BMS2k1d2hBWDYwZ0NLMnVqeHpFQXFHTDJwUTFKaXM1QUpFQUZIdlR1allBS2pSZitTRXVnbTFkMkNPUUxVL0RBd1E0NGNhRXc4QXRaelNJUGdBdnVLa2RyV01NNk03eENNQm9pQm40WXBDRTJOQ2Z4V0FBNU1FdXd2Q0NFSUN3bG5oQUhWK1lPUmZEc1dKR2dQcE1Ld2cxYjlRcEZuekhiRDJCSzJKR3VsOXM4S2tZVzE3dkxBTFFSVENCcHpYWnBTNGd0Q1hYTUFrZHV1QXk4RTdQaWpQV3ByWEo1Q1IzOHlndzFmSkRvaGgyQmxSQWdxMk9lTjd1VFdjMUQwQUZOdG1MNTRFU0JzQ2FKY0xrRGFqeGo1WlhSaUNJR0Ewd2FEd2dqeThzazUrSFkrWDlwcFViSlNDcDZUbkZDTVh3bnkxV0FGUThyVUFjMndVclJMNm1YVEFlZlduRmZuejNGcGJhZ1FLTEFxQXpvWmpBS2trcFhrTk81R0NFdk9NTEZYT25uQzR4SUtPam5RR05kV1NNK0dxSFFHZDdKU3N4VWYrSnpRTHdoVGRWNGplMW5RdnIxTWtQR3RsZjl5UDJEeStnQXFaNnJReXRmdmRIU0R4Z0x3QkY4QW1BWWpIV2x1RURpS0dNaXFPVnZ0ZWpYVEJPdVJTWUp3REpBQVJnWkFHV0w5TmsrSU0zU3pnVHlkRTRlZWMxblpIYnREYU5BZjFEcGQvU014MkVORDZrRDBvWHRGaEJYbWNZK09ZNkFGQ2huS256bDdOZmRNUjNxQ0FhZTJCK1ZWTVlYQVN2RHMzL1gvekhKWmNCODR2dWlxQUJFbzBRUG5obndxUUx5UlVSbVpCUHl0bndIZGUwTTF2TjJsUjZwaWNvS1VMYXhIRElFZEhrVzJpV2c0LzdiNXpiN0RTUUFWZDAvZ3JpVjJKWW9qZnB3UkdFWXNHQnJPQm14L09nUDVzQUtBTmtjYkZ6TldUUm5YL0dTR0ltTVlIL0xZbGsrZ0d2ZFQrYlcrU1dIK0lnMUdxTDVRZVR0UjJFWWo1TFZIZmp3L1pEd0w4eUo2VEI3VVUzVlZvVGpUWXhZREsrSXZ2N2R6TkFaSXhwWlNpVThqaktnSVdUY3lrWmtCYXdEQkJuUWRNcjVRZVRLSTVpV0NCMDlBbUViNyt1Y25PUS9hVFBXbjZ3dXp5UzR1K1IwT2I2Q1VHcUpwSURBOTdBZHFJTmJnUmdCSjY5Q0c0SnA2cS9ja2pYcUIvUktsYTRXcGtPMk9EZ0hveW5pZ0EwSmlMd2FOaUV0OTVZUUtKNEZSQys3YnJLelJIOWpaYk42aUpZdVNIbTlJNWlPQU9oSE5KZlpraCtneHNCS1BiTHUzK0pnYVdEZG9qaE1PNWtrRFdTbE5UZzRCNk1weUlBamYzSWdnSmdNRDRNQ0FSakZNVTlRQ2dBeWtoU0tuVUNZSEI5SkIwd3k1YVRSVXhtdXA0aCtRMXVBbURzK2hwWGdGTG5CNlVMT05PbjV4QUNOSnF4Z2hzYzNJUHhWQkdBaVFHOWFMZWlsV1VKVzFGdlZYRU4wVEtwMUM2QXQxOVRNU0NCcHoxZEh0VC9KSDdOOXlheHA2UWtGNzNLQnhZSXIxMG5BTXByb0I0NHFRR1RqNnNqVXJ0T0ZQdExlRlFITEVTOUFkREZycTFFNk0xM01heFZDVE5BWE5GVGhJeWxMY29yNDB6eHRnREFQS3VWd0RNck9LdytTQlRidFIyTU5EN3Nad0M3UXZtNHdxSGE0VC91SXJoYis3bjBFZ2JRZFRpam95ZythZ1dYVDhsbERzQUZXci9COHFQMUs3YlQwcHZ0VndIaFc2K3QyQy9tOHN2dlpsYXdpMkNLZTM3bmhGdGFwa0RuSUxScUJRQSt2MDRBak15bjc5RUlrWE8vRG56eUNCd1Z3ZVg0d3hzOUI0clJaZ3lQVkZxeWtnRGQrNUpTcEJVNXIwdkh5SHoranNjM3ViMEtBQnNaTUN5UWdlRXhLeUZQVkl6M2xtY002T2ZQQUdDQURZUEU2N0pmczZoN0cwbyt4dmk3b3lLNGNMWmZPZ3BzWHdDMkxxOU13dXVWRVJvbktuNG5TSnJjWG5RS2NNN2R3TU1YZ1ljc1Z4a1NlYkpnek9XUHFkQjFhZDJmM2dwc253SzJMWFdlUjltM2RhblVJVjFsQlNDUEFyQnd0cCs3RFRodUJ0aTZVRFdEbVdBL0R2WGs4TFJwdGZQdE5VbGloWVpUT1BDaTA0R0gzd0ZzbndHT1c2aUFzNW4zR2VKSitLTG9FKzlWRENsUThSNnZPUUhZZWdEWXd1WTNTNkgvaUo4amIxMWNrMHE5UWhvYzlRTVdnUEJaSndGYnBvRk44OERHUldCaXFRSWdXeUpZM2xQb3phR0oxS1RFUGgzNnpwVGtKcmNYUFJFNDRTN2crQ25nMkRsZ3l5S3dhY2xmRm9Jd3ZDd3g5Wm4zUTFEbUlQeC8yL3NTYU11dXNzenZqZlhxMVpSVUVsSmtLc0JFR1F5WWhKQ0JTa1VxQVcxdHNCZHB1eEVWYUJ6b3dYWnFlMWc5MEcyTG90alFkbU1qS3F0QnhRRVJkQVdVQWtVbFpOQkdrUVJOeUlBRU1Ba3hwRktwcWpmVUczdDkvL20vYy8rNzM3bmpQcTl1VmVxY3RlNjZiN2pubm4zMi9zNi8vLzN2Ly8rK1R6MGRtRDBLekM0RE02dkFGcGQvMEwzR2g2eVREZ252THdLekFXREdpSC9UaGNDMk9XRHJFckIxcFJnUWlzSVFoQWErQUVEK0hFRVk2dU5MeXJSblpMU2w2dFNicmdMT2VCUTQ0eWl3OHppd2ZhVjRVR2JkZWdtQTVRTVRMRmxxc2ZuN1hlY0RXK2VBbWVQQWx0WGlYbmt1WlNCa1JjbTRVR1h0VTJ1bzN4c0FaZ3o2eTU0SnpNd0RXemtnQk9BcU1NVkJDU0FVT2JoOFF1Ti9DaVRnY1dBdXlXaEwxYW12dkJiWStWZ3hiVzQ3N3BhYTdnSUJxQ25VcmJVQmlRdWhBS0RVb3QxM0liQmxEdGl5QkV5dnRPNVZEeHZ2VmZ4Vy9Ka1dORnJDZUs4TkFHc1k3QnN2S1FDNGhRQ2tKTmFLeTJMUklzZzZTSjNJUVNlMW9uS0tDMkNzT1lNZU4rMER0ajBPYkRzR2JGc0VabVdwNVM3NGcySXIydUEyMkJTY0FKR0ErZEpGd1BROE1MMEVUQVVBa2dEVFBxOXpkSy8rc01XcFBGMTlOeFl3QTRnM1B0c0h4QUU0U1FDNkZkU2dtR1dSUklKTFpKbGw4RUdLakhpWDFqd2FOMTBIekQ0QmJEMEd6QzRXcnNLTVcycE5vYlpvQ3U2Q0xDRGZDVHF6Z2c2c3Ird0ZwaGFBS1FmZ1pIS3ZwUlNZZzdITjVYQ0wyQWJBWndQclpHYWo2aXBwWGhnbjBrcW1VMXdveG5IZWRnNUFBVHVXSGlnMkZFMXVWUndveG9YK1djYmc4OVMzQXFDS1BPTmNDaThvUHRWUCs5KytHM2orb1NLMnhSQkZERWxVeGJUUyszbnZjNEZwRHNqeGxsWFFvSmc4RmdkQ1FvR0pKVFRpY0xjUTZ2UEw2d2JnOWNETTRjSnYyN29BekZBNWt5OS9VT1N2bWc4b1A4Nm4wZElDQm4yNUp3akFSV0RTQVVnQkhONnZmZGJ2MTBBYkFSaDhYOTF2RE0yc3MrTnZBRUNLUFZMQ3NIb3lVZ1JxcmxiblJ3QjkzM09CYys0RFhySUMwSUVtaUxuRTc1ZGk4SHN5QWNqeldVVkdVaTZ1SUNNcFZ3d0pWTVhkZU9rM1hBeGMrSG5nK3ZWMmVzQVl3K3NXb1AzMXIzZUxjTHdRQmVRVXJFSGg0Sm8yaDR2RG1KUHVBeU1MR0FlRW43dXFiZ0IrSTdEbFNXQkdDd2UzMUdiOWFMMjBrR0RiL0VHUnhZNldUejhmMnd0TThsNHBnTDFTZ004ZXNIQ3ZzdXlsTUU0bm45Y2ZRTHRsZGc2VFowa1VLb3JBZmlqMjN2QVBDbXFwM2ZjQ2w2MFhGSU5pZDFQbFpyZjQxL2RuQXBCNndTUWp1dFVmSURKUjhDR0lRT3dXRUg3RHl3cEtyV2M4Q0Z6cVJMSGtWWXJCMmpTMkZRSDV2a3VCeWNYQ0FsSVVVQUFrQ00yaVJCQTYrQVJDZTdEalltUWR1TFlUbGVpUS9YVFRTNERwSSs2bkxoWlcybnpWQ0VCYU1MZCtzb0lHcWpEMWFtcGR1Z2lZV0NwZUJLQTliQkpDOUFjdEFrOExFUzI2U3FzZnRJbkxaNDRkUWlmNElnZGh5bTVXTHJQRHl1WUgvN0hUQ053RG5Qa284TFhyQmNjalFhaW9lNkJpS2FkMytRWS9NR1RINnJTM09CdkNuUUR1QUl5cWhpRGtROVJYKzI5eUUzb244SXdqeFFQSTh6a1RpQXBHVTNvVmtELzRmR0RpZUF1QWRNdzVNRlFqRWdnMURZc1VrdSthM3VJMFRHQmZWN1BvdHdId2FPRW1iSEVBVHZ1REl1dG5pNlVBUW9GUklGUlloZmUvZGhFdzd0YmU5T2YwU2kxZzhIa3J3UmNldkRhanowN2dJSjduMDVyWXlXSXBiNHlhLzd2djhQUmRGcGovTFhEbWtRTEFuQTRqQ0NPbFRCUk4vckZNQUpLZ2trVkhwR1VqeVNTQlNGZWc3L2F6cWs4RWdiU0VxOFVEUkFDTEtEWFN5YVE3QnIvL0RjQTRMU0N0d25LaFRFa1FjbUFJUWh0TStVYWFqbDB1UzlOYXRJVFhXenB6ZmNkTkI0RHBZKzZuQmdEYUN0YW5ZTE42ZkNqNHUxYXkwUUlxdE1ML0VZQzYxd1NBOXRBSmVQNmVXc0FvRHlzRnBnMWVCMEhJUVJDSUlrVmVDcVFmLzA1UDNXQ0IrVVBBK0NQQXp2bUNhRldES0V1WWNsMXlNTitZMmRja3FHVGVIUEV2dldEU05oT0FmYmVmWDBBNnJTOENVdzhYOTA2NmJGSWZkcU1ISklEKytESmdMQUNRdW15YzNneUFFWVJSS0ZDTEQxZXU1T0RMRjZRdlhlZHgwdzNBMUJ3d3hkQUpMVFhqZDhzZVFuR3JaOWJQRnhMeUE3V0lLT042M3RZdENRQk4vc3Y5UVBtNkJrTHAwdmw5dC9tNmlldFI2ZmJ5QkE0Z25YdE9Sd1JScE5uVHRQcFc2Z1dMSDgzbEtxY09GVEVuRGlLdG9Id3k4Uk5GaHJlZnllenRibnJCZmJXZmd0dHNQK2tJeU8zMkVMRDFjSEh2SW5ybHZXczZUc25CN3FBVWxnL3N1RnRBV2tFNTV6WVEwUXBxY0FMb05DWFRFdDdBM0tvYUR3R1FmcW9BT0VVQmE3ZlViS2N0bHR3Q2FqVmJ4dlNpeXZvYXNNMEJhQkt3d2RLYjlmTjdOZmNxQldHaVNXeWtXWEVSMHVtZWFjVUVvblFnQ0tSZklnREZqeWE1eXE4V2ZzZnM4ZFlnaXVNeGdwQWcvdm5NenU2bUYwejZaajVBUGR2UFFlYzBURW9zbnZRb3NHT2hhTHVJWXZud0VZU2l0aEU1MkYxWEZBQTBwNXlpZ0Q0b3RDcXlnRktucEhVcExZUDBPY0tVUll2Nk1qNE1OUjQzM1FoTTBnTDZRb25nYXdPZys2cmw5Q3N3S29Ta0VJeFB5VHN1QVBpZ0NZQm1BWFZmWWNWZituMFNSWXc2ZFAxWXdOZ0hzZ1NhamlKUDQyOVJycFdPTTZjeERpSkI2TklOTTR3N0xiVUdNUVV3Qi9NOW1aM2RTeStZVkcwRW9CaURCU1Q1ZGRaK1BrQ3NBaUlsUVpEYTNMVmF0SjBXWEcyUGJMOThBQis0b21CM29QL0hnVFVobUdnQmZScVdmMlRUclVTakV4RFNQL3FXelFEZ2ZBRkFXeXpSOHJrRnREQUtYNzVqbzZuVWd1WnhaOE5CeUhidnZxQlEzNlQxc3djc0JhQkFHR1JnNDBJcitydDlXVURoUTVaQVU3RXMyZTlMTHpnbHFIUnhOa2JldVcrb1FSUmxzNWphTWpuSzBhOWVjTmYyUjRMQXdPODI5a1FCM0xUdEVZUVBVd3pRQVdnVzBBR284QVFIMGxqcC9WMTdwbTBLUmNFaWZHdU5Pbm9jTzFyQUNRYktQWGhzOFR0TndWcjV1aCtuNlpmM3dEZ3UyOWcyRmRNdE9jOEI2UGRwRmowOFpGcnBsdytaQTVGVHZBUVEwL0JUMzZGUERrUnFCVDlKYWc3eFlsUUl0WTBmODhqNzhzWnpDY0tQWmxyQVFmU0NLOXV2QjRoNTc3U0NvdFVpRUo4b3BxOElRRmwvUFVCUEVvQkx4YlJFNjJMU3FHNGRGQjhyNWJIY090aU9RU3FUNVQ3Ukt6WURnSngrQlVDQ1R4WlFDd2hhUWM5b0tjRW5FQktrbmo1RnNKMUxBUG85eG9XV1BXRHkrNklJb3FiZWFPMFZBK3pIQjB6eElRREtrbjFHZ3RYaVJ4TUlBeDBWbjBEYitsa3VGakxSQ3Q1V0V3RDcxUXZ1Mkg1T2Zla0Q1RmFjaVFheS9HSWJGZ0JYcml3QXlHbUpBRFIxY2szRHdURTNUUTRCMExldHpCSkVyVFlBcjJCQlNJM0hUUzh0TEtCWlBvL2ZXUURacDE5N1ozc2NqR2I1QkRwL0wzK25qTXdlQjZCODNHajl3ajNhdE9zUFdpbjlXZ1hDRmxWTy8zY3RmNGlEOFhrQmtINVVTbEFabE5QWkFRcUFScjV2eHUxeWptSDBnaXZiWDBVUUtJNjNvMFd1bi94SHVSOEU0Vm5QSzVKUUxkNFZOdHRUQnZLMnVvaUtPVWYvZitHandNTkJoME5NVjZKMGMwTnBjUnY3bXJZdjNraDgvdUh4WXArYlZwd0xwM1I3c3RzMll6b3VTcTNLR2ErcTcreDdDbzRuYXpBZXJSS3NWbFYxUWl0RjU5ZHl5RlphWVkwSE11OW1XTDNndHZaWE1ieW1CSUZNWjFvdjJoMEIrTFRMaXN4Z1crRXE1dVU5MmlaNzJ1ZDl2dlIrNEpGcDROamtSaDJPTmkwT0IxL1VCQ2t2RVlSaGZ1TnM0T21oaGlQS25GUWx4NmFBak1uU1hKVUFBQ0FBU1VSQlZQam16MXc0MW5ud080Y0NJQnZCd1pnVEFPVUhScTNneURFeEQ0elJHVllFbnBtNUxxbVFjME01ZXNGdDdhY0ZsMFNsSGlCeHVUa1l4eGRhaWhVQzRRVlhGdTVGQ1VENVF0Smw4NXNqR0EwemlReHFldS9mZW0raHcwRjJmTExRR3hGbFlNUnZvN3YxV21JVnRwdDFERmtYdk9SN0x3SjJIU2t5b1ptRXlwb1ZWZThwN2I2cUVNbmlkR0cvVmwvTDJhUE9Jd3VBMXBBSVFFM0RBbUZhNGo5ZjdDUGFGcENIS3VqcjV4elplc0dkSHFBcUt6NVgrRkxSQWw1OGxlK2p1aStrVEJBTE1jZ1o3M0NEQmtwTjIvNytiZmNXT2h3VXlDRUFqUVRjQVZoS2Rqa1BjMlJhamV3S3l1L24xLy9xSmNBMnVoQk1SR1hRT2NuOVU2SklPalhIUXFTWU9zVm9RcDFITmdBdno4eW55ODBINVBWejlINlJxVmQ4NDlXdFhRL3pBME93MmF5R0xKNDc0TDBHNzl2dmJ1bHdrSmk4QkdDZzRTMDFTS3FvZm9OdlNJQys1emtoRlV1cFY4clVUcEpOMDZLcGFCa0ZRbTVNMUhsa0EzQXlNNS91OVpsMzh6cms2ZjBpVTYvNGhtc2NnSzVJU1V0Q1Rvd3lEcWI3VXh3c3FGSlczZm8vdmJ1SUJKRVoxWVJneUh3UUtOaTBLRWwxT0tUQ1pKZHh0UERuLy92OG9vYURhVmdxRnlpVEQySUtmY2paUzRGbys3ZytIWE9Qdjg0akc0REl6S2ZMelFmOEtWZkkvRk5LclE2aDk0dGZ6K3ZPQTljR0FBYnJweWxZMlNEbFZUVHQrdUNuVjMvVjNhN0RRUUF5c0pBd29iWkpnVVhpNzhRYXloZDgxMldlaU9BWnpFeVVpQWtITWV1NUJGNUZ3WlFBV0xQd2tua0xReTlDclBNeTgrbElIWkZ6dk4zVCtZYlYrOFg3YzY0T0hIaXg3NFY2ekl4QitSSjB3UStVVTk5MnRZb0Z5M2ZjWGNURHhRa29Qc0NVaEZJY3pLVkNlZ1NnNUI4QS9QSUxOOVp3eEJTeHRpS2lVQU9pN0pXMGRMVHVzdEY4QUdibTAvMW8zdmpqblNHZGorbFlsR3dkUk84WE4rYzF3QUJJb0hrNms2MXl1U0NKSVRxM2pEWTlWeDBCcUsrK3V3QWZYNkprSS9oTUUwU0MxRUdndWlRK2lzcWNRUkxyRjYvMGpPMncrNkZNblpoeVpZc1ExVzUwcU9IZ1BYMU5YbmR0T0RzZmdNd0h6TWluKzArWk4wUzlZT2xsTXpXZkx3S1FTUzM5NlAzaVkza05PTERQTTF5MDY1SDRnT1czcDR1VERrQjh6V2RiN0ZnYmREaEVnSmtDVURSdm9nVG1kL3ZQdjNCVkFVQnV2eWxOekFBWWk0aGlzVlFuRUhvSXFXYmxyeHFtNE14OHVqZmxqVCtZanNXQllnSU9jMG9KUHNxMXNsQ3BINzFmS3liSk9Fb0F1dVZUUlNDbllsbVU2UC9aNGlTSkVjYkx2K1l1OS8xRUFoN0pLRVhES3hxNENoVWlLeW1SYndqZ0hkY1VXVEFSZ0xZWEhTcjJMT1UrQlY3TVZ3enh3T2ZrT1d5YllBR1pENWlSVDBlZGpweEQ2VmhjT1E2ajk0dFA1MXdkT0hCZE1lWGE5T3FXUmNtV1hBMVhMVUlVSDZ6eUN3bEFzM3orWUJrZnMxdStWSWVqSkVGM2NrcmpJOVQweS9hTUEyKy90Z0FnMDhWVVJLVDh2YktNVWdBTUlHenpBY09pNUhrbkhRQXo4K2wrTVcvODI5S3hodEg3dFR6K2pJTUFKUENZTVVMQVdkNmZ2aStFWTlvdW9aQk0vS3gvNExVQmdGTGdOQzVvMTZGckU4SkpWSmdraUZoYVFRQnYzK2RWYk1yV1ZzQzhVeEZSa2pqYVZzVzJEdFJkT0ovdkF5b2hWWUs3QStiVHZUZGo4SGxxVE1jYVJ1L1h4SGt6amdOa0lPV3VEcjhqbllZREtEdXRncFVocmEwdUFsQXlDQ1VBSzhCWGNqQlhnTENrL2gwRC9oY0J5RHhGQWRBem9GVXFVQllSSlRVY01XZFBQN09OTDZpNWJMUWVBTEpSUStiVC9XN0c0QXVBT1hxL2xzR2RjUmdBWStnbExrWWNsSlZUc2E2cHRDWDN1UWpBS0lOUXN0RnJBWktJd1d4UUloSUp1b3ZCL054K3IyTHpGQ3dsajhZMGV2bC9NWWswa2llVnRjdnJ3R1VuSFFDVmpqVmtQbDNtSXRRc0lQdUVseDlHNzlkT3pEZ01nR2tBV2xOeUJKbjh4S3ByQlJDK3pnRW80TFdSZ2NkVmNPQ2pqbE52bXg4NERyek5BYWhhRlpXTHlnS1d4VU5pYkloVGNQRDlCTUxMYTY1YnpyZUFNU0dWb1h2Si9DZ2gxV1VmTytYVFpTNUNEWURzOUdIMWZuT3JJRGNBa0FCVFREQ0NMWUswQ3dpLzU4NldjS0pVaUVwQzhDQ0JZRHNpaVNwbHFVSVVtT2pmK28ydElpS1ZVSmJnVTV1U1dsNERXd1g0K1BjWG5yUUFUQk5TKzh5bnkxeUVvcGRjYXkrOTMweTVZaGdBZys5bjJPb1VlSTVUZFFlciszMmZkaG1Hb09CWmFuQm8rZzF5RUtVNGRZZ0ZTdnFCLy92WkJJQnQ5UnNoa1RiVzhaWloyaFVndkRMM2lVM3V1eDRMU0JNMFpEN2RQUm5USDA4VkFJZlYrMlhBT3VjUUFNdVZjS2ZGU0QvK0lBQUJzRW9Hd1lBb0haSUtFRVl4UklId0xTOHBVdWhqRlZzNi9aWmhJVld5eFZLQkJJUlhuYlFBVEJOUys4eW5JNHRCemtFQUN2K2NobFVWSUtFLzVjUkdzV21sS2ZJenVkYzNBUExRU2xnM0UyT0N5VlJjMWtwVTNEZ0JtS29Rc1d0bEJjc3dqUHUrbmZUWXRCTCtHUWRnT2YxNkdDWlc2cFhsQkNxV1NncUp5cG9PQUZmWFhEaWZid0ZKTHZpNUhBamxuVXNpSWU2QWpPcDRpUU5RSFJsVDJQbGdKQ1ViYmMycyt2L2hGd0ZiL3E3Z202SGxZcEJibVRWMnNzY1F5eS9xRkJqMnYwL2NBZHovSEdEN05EQTFBVXlPT1UrMUN3V09ld05qS2o2L08wM0YxL1d1dWdXNC9YSmdmQm9ZbXdER2RIN0l4QjVrTFBJQitJOEFmTndaZ2dhNWNrMmZKYkVtOFY5ek5XUGZyYXNiZ011UEFjdXNlSjhFeHNiOUZkQmhBKzdnYVFOS0I2VGZjZ0NZdWcrWUpUK2c4OWFvQkRNbUlNU2NQMTJ1VEtqMTN1RHY4enNLaWcvdUoxdVFPc25vam0zcUI1UDVBQ1JCSDNPaFB1enpSTjlEVjg4SHFRTEVXUEpudlR5NW5tL3QvMXM0QmN1U3BSWnRHQXU0Zmkrd3RCVllFeWNjcll3bjZoRjgvRmtKcDliS3hBS1ZGc24vZDh1cmdiSFBBOU5QT0VPV2w0KzJjZm9GSGhmVnJKVFpQS0hTajVkYU90dXA2SnlDcFB4OHJIV1JWUTdXT2xyWUNNeDhBSEl6bHhrQUxQRDljMFZCK3gvQTNFLytFMmZVWUhYZEY3S1RHd2R2VGQwQUhQOXI0UGdXWUcwS1dCZGZzQmRzTVBmUHJLS3NvTDlYQVZMQXZPMmZGeWxDRTRjS2xpeXJEVlpOY0dTMUNxRVloV0ZpQVpWK1hudGFVUmRUTG1wQ0VicGNoVFlMcWk2TnJrTUN6THp0NVhjNEh3eUptbWtKK1o3M2pRT2g0TldlRFVaaUsxSzA4ZjBFWHQ3Q01IVmF3SWs3Z2FWcFlKVUE5TEkxQW84YnpLWDFjeXRvRnRGZnBkQ0lXejdyZ3pIZ3RoOHUwb1BHRHdFVGM4Q0VNeVNVekZhaWtndGxwVzFUYThKcU5iYTdsVmxqU1JnVytRNlpQLzU3V1F2ajZmeWRCalhmQWpLYmdFdk1Md1dDdmhOb2lwZ05wblFzaGxTNElHRld6SWs2eWxXd0F6OTNFVEx4R1dCNUNsaWRMQUJvSU9TN3BtR2ZHKzMzWUFHNW1ORDBHOEY0Njc4dmtpUEpjek5PQUM0VXlRbTJOOHc5NGtpckZsZklBbDdpNDAyZDZkYlBXV0F0cnNqT0ZpdUN2QUpaT1FFMHBIVEZzY2tIWURlQ3ZoTmdpcFFOeG9BejgvOElQcjVuYnZIMmpkKzZBVGhKQUU0QXF3VGRaS0VCTERvRGdVNCtZVmtQSElCb1B3YXJlT3QvQmtEZXhzTUZBRm5iek5KWW0wSURuVndidDR1eXVyMWt3TDdUcCtpWk0vMDhXVDlSYzdESFVtdVlUci94KzZvNG92dnU5ZmpCYmdSOUp5QStvbXd3eHZaSTVVTGc2Wlc3eTlGUGY5UU53S20vQ2dDY0tBQm92aDhCeVZ5L1VDdEpxMmYrWDF5WUpQR1UyN2xJWkxidUVXRHNXQkhlc1plRHo0aVVSTFVXYTFURTQ3THFLMTJmWm1kM09YaWRGY3RxbTkyS2F0VnMxakFFc052NnNkeW1hYTJnOCt4VUw0SStQbjJiZUNnYkxHV0hJL2g4RzNvVHI0NWlLODZQT2xiQlU5eUtJL0FjZkxSK291UXdIOUJmbW1iTGxUSGJvT25aL1Q5KzV2YWY4RlVhQVRoWHNGT1E0NW1VY2daQ1dUQXhlMFVRK3VyWU1PMS8zN0d0eFFtb0xDQnRSU3AzMExyRHAyU0ZkellNZ2svUitWTnd2d1I5bXdRRHNhc3BHU2ZKZ1lEWU5UYnA4cHNDUUZKeEVJQmtRakRyeHQ4ZFhDVUlZK0NPSDVNVkZQaThTT24ybi9RWUxaOUdwMGN4QU5JUDVJdkFrelZ6eGl2UnlkbktOekJhOGZkZE04NGI2QUZ5QXJpTUYycGFqazlrWUllb0NsWG1BM0FRZ3I1TlFFSE1CcU1WRk1OYUlPYXlOUkwvdmhsSDNSWndtaGJRUVVjQWFzclZWR3o0RXRqQ3UvM2RmYi9JRDNQYlQ3dUtBWi9NaGNJQzB2cVJUbzRXMElCSUVBbUV0RndDWXFqVzAzYmNtZHdCWWVvV2dldFViclI4c25ybG9pUjJkcnBBQ2YrckQ0RDlFdlRWaklKdTdIQlYrNzgxWDc1MkN6ajlsd1Vaa1RFZ2NQb05QcDVOdjRvQlJoQ0c2ZGQrMURrTXoxSkloUjFCQUhKN3p3cU8zZklSUk01dG1ESzVDb1FLc1NnT2VCWUJLRlpVTFRxY0I5cjZOaTVLWW1kM1dLRFVBMEJsaE5MTThFYlQxUUJYQlU3MmFJNVpqVWNWT3h6N1dMa1E4ZDM3dnNhcnQvdUE2UmNQc3hOU0F0QVhIRFlOQzFBRXBmOXMwMWtLd3VCd0dVN0hnVnQvMWp0RDFlNjBmZ1FpZ1NlL2o1YlFwK0tZcEdCK0g2MmpUN1A4L1p5cEJJQzhEaGN4OGVZOXdGMDE1YWJobW5vQXlKNVdTcktlTmdLTzlTSHhuVC9MU2FzSkJpbTVsUmpXQkVJVmVST0luS0wxcXVueWJSYXdMZ0FTZEV5NzRxamFOTnpKQ2dxRUVZekJHdkswMjk3bUFGU0hFSUI2ZWJLRGdjOEoxa3NtVjh0MjlmMWVuNkw1djZjeElLNWlLNlhuZS81akNUaUZjVHFWbi9yL3RXRFBXd1huRVBUVmdJS1VIVTdsakFTYXdLZWZJd0RwTWRSeFJCK3dGZ0QrUlJFREpBQnB3U3p6MmMwTGZ4Y3pWamtWS3dhWWd0QkJlenUzU3ZYMDhkMzlQNXVPM1FLYWhYTVFjaW91clpSQUdLWldhci9ZWjF4WFJQZTh3UXIyQVVLN1R2Yk9WVFpCWHg0TUJFQ1JuQ29uVUJTRkVYVDZtZi9USysvcW16QUYvMFVCT1BxQlpZRjUySHJURkN3MkxINUc4VUN6SkVrbzVuWnFtUm5QaC91Q1htcG5WcERUc0lQUHdLQXBPYVNBMlFMRExTSGY5N2lQeDB0cElTTGZ6N2JsNGlGZnNVc25qK0haV0VlT1lEQ0RuRG1DdlprRWdlZGNDanhHc2VJaEJZdDN2eDA0OUh3TUxSaDhnQTlnaDJNb0g5QUJxS0p6eGYwTWNPN1hsU0FVNEh6aFlZRnErNUQ3aHdCdS85OE9RTGxJQkNLblczOVNsWE5ZK25xZWlxMmRrUWcrZ25HUGI5L1pwVDBscTZNVjVEOTZnTEN3Z0RtQ3diZG5DdlptQ2dZL2R4eTQ3eHhnNVNXdVVqaWdZUEhGYndBK2Z5R3dmcjJyWHJNdlBCK3ZwM0wzR0hDZ2k5Sk9IUUNrUlZQcHBlVUJpZ1hMRnlteWVqWVRCNFlzZ2ZBMjBvZlJBbFlCMEZmQWx2UXFQMC9Uc1g1UExPQjVETnU0NzFjbUl3aUJhUnd3L0YwMUorbXoycHFDaHhVTVp2cEpsbUJ2M2lUb2NzVzRkemV3ZmhrR0ZpeCsyZmViWERBZUpPL1lFSUxCQjdwVTFnOExRRm85OFFBU1ZHWU5RNkRaZkVHM2ZuRXFyZ0xoYmYvSFYxNWFuYmtGTkN2b2hXU2w5WFBRMlhUTS8yczNJNER3UElad0JFRGZnaXRIMEVrNk42eCt1L2lEN1Q0Zy9ZZEJCWVBwV0hFYUhscXdOdytBUWE0WWo1NEpySk8rYVFEQjRwdCtvQ0F5WXZPUEVJUURDZ1lmZUYvOVUzQWJBTVg3SXRBbFZ0QXNwS1pkejVTT2x2QTJwc3R4akVTM3dKKzkyTmdBR0syZ3dpNzhRb1ZmRWhCZVFBQ3FOTlAxUmRvQTE4a0tkZ0RoeGtVSS96S0lZRENucXl6QjNqd0FKbkxGT0VJVzdRRUVpMS8xWTIxeXdWZ2xDQWNRREQ1L0VmajdNNENWclo1QUtsa2h4ZVFVYXhCSTRudkZ6eGY4SWZDVkM0SFY3Y0M2WkVYNW5lbjNWWDF2QUdMWnE4eXNydkhZK1FCd2JHZkkyRTZKcEx2ZFgra3N0aHBVdlFybVgvc1ZER1pWVUpaZ2IxN3ZKSExGZUdRY21DZFZiNStDeGQvNXhqWjZRenpNTE9RQkJJT2ZUVjJQczRIRkhRN0NMUVVRbVVyVjByZ0tKTXNDanN4R0FxVG4vaHp3MEVYQTR0bkF5ZzVnYlRZQm9yS2tVeUxua0I5WVZoVHh1K2tUMTNpY2N3dHdkQmV3UEF1cytiMmFyOXhKQWFmcWZnTVFPNGRoK0o5K0JIZTVncVpaWnpZb2sxSkpVY3BhUjZicDkzUCtXL042cDBLdUdJZW1nRVdLZ1BRaFdQeGRQN05CTGhpSEtZSFVwMkR3cFo4ckxPRDh0bUpRVnBsT0x4QXFtYlJLQzZFRFlDNy9DZUNSUGNDeDNjRFNyc0lTcnMwNENQbTlBclprNTVVdktBc3BZTHFQYVBkUjQvSDBnOERSSGNEeVZyL1g2VmFiTEhrMlBoanBQVlpZN2Q1eHdGNkN3Uzl5LzRMYmJWeVFzRUtJdWZHaUtlMHAySnZYT3gza2luRjBHamhPUVkrb05SdGxqamk5VFFQZi9mT1Y5SVpZNEdxNEQ4SGd5LzRXK09vMllHNWJVVXkwNHZVY0xDcVNKVlJXc3pKYk5neFNtTWF1K3EvQW8yY0JSODhFanRPcWJnTldXYVRrSUZ6M1lpV3JGNG5BanROMG5CWnJKblUrLzhQQTNDeHdmTVlCNkxVcmEzb2dsTDB0cHM2d2xWaGE1ckxpcWQ5QWREZkI0SmU2VTBzLzBCWFREWWg4MFNyMkZPek5BMkFYdVdJc3pBQkwxSmFLV3ExUitud0dlTTE3T3NvRlk1WFRWdy9CNEN2K0RqZzBDOHh2TFlxSkNFQ3pnc3htWmxxOVQ4ZTBYR1V5YVVpemF2UHR4b0ZyL3p2dzJCbkEwWjNBOGUyRlZWM3g2YzRzcXdPYmNrZXloaVhBb3dVU0FEaEQxWGhjZURNd3gzN2x2VTRYeFZOMm4zckpJb2N5Z2tyL1ZiczdmZStFZEJMY2ZhWFhRM0lQV0lycEJCNlhsbndwUjc2allHOWU3L1NRS3phcnhNN3FKRmo4bWc4VWFyTVY5SVo0Z3ZOREQ4SGdLeDhIRHM4QTh6TUZBRm5QWVFQRGwwQ28yZzRmcERaTHFLQ3hUMC83ZmhKNGZDZHdiRnZoUml3UmdKcnVDT3dVZ0NwZUN2VWpabUVGeGhmazlXOTY5a1cvQjh4dktRcW5WZ2crQjZDQjBNc0k3UDcwQUhnbWQybjFOUTBydjdGdkFMSWxWWUs3M01uUUNETFRoU0dab0RwdVA3dUNldVg1bjh6cm9CNXl4VGhHblEwQ2d5Qk14WTYzQXEvNWFCSEc2RUJ2aURsT0xWMEVnMSswQUJ5WkxnYmwrSFJ4blpYSm9xcXR0QTRPRG92bEpaVnVTalRRRnRxK053TlBiSE1BenJhbWRWcFZzNndFb1B0ZE5nMzd3SmZ2c1lpSlA5TkZxdkhZKzd2QXdqU3d4QWVOeFZPOFQ2YU5WUlJSbFQ2aEhySjBPdmF3MFdESkNLbmc3Zzg2QVB2TkI5d2cySnZYTzMzSUZXT0JnbjhFSWYyblJMRDR0YmUxK0FVN3lBV2JaZXNrR0h3VmRkMm1nQVVDY05LbkpnTFFyWi9WOS9Kbm41SlVZbW5BRTNoQ212Myt0OEFXUWZTenlQSy9QT09nSmdEZHNncUE1bmZKQXZMZExWK2J6MGtLNFJxUFozd1FXSnh5QVBxRFZoWlF5UXI3Z3lhWEk5YXhXQ0ZWQUdMdlJVaFY0NlBnTG5VV0JzMEhiQlBzemV1ZFB1V0tzVFJaQUpEVG84bDh1aS80Mmp1TDV2ZVFDN1pwc0VvdytPclpRbHFWVnVINEZMQThXVnlEQU9UQW1IVVFDQVdRa09sc1FBd0R0LzkvQUU4U2dQUXBOYTA3K0FoQUE2SExYYmI1WHI0SWFBTWZ2L2VHdlA1Tnp5WUE3VUdqQldUV2poNDB2OWZTeXNjSEx0YXhoSld4RlZzTk5BWEgxa2h3OTgzK0RZUG1BNWFDdlhrZE5JQmNjZW1mY2Vvb0FmaEFBY0ErNkEyeEx1QUd1Y3hyemdLT01leERmVjlPd2JTMkJCL0JFb3FMU3JCb1lHZ0ozRThxTGNJRXNQL25nQ1B1VXk3UzEzTDN3YjZQVTU2L20vWGo0UHMwVEtDWFFBNkFYdU5lWlkzSE16NVFBTkFlTkQxa3djS1hsajZ3T1pRK2I3UitQaTBQRDBEZUZBZms1OTBDS2c4cW5jZm9GeklSVldWcWZGZkJoZ24yNXZYT0FITEZXQ0RidlBzdEJzSlo0TFVQdCtqZGVzZ0ZnK3FWcHRXcTExYmcyZ3RnZnVMaVJBQWdRZWcrb0Vtc091anNYYjVTc0FvQ0lOLzN2eDA0T2xOTTZZdjB0ZHgxTUt2SzcvVEZqVm1lQ0Q0SFFRUWhmMTU5ZVY3L3BtYy9rd0NjS0FCb2VZdlIwb2VwdDdTRW9aUTBUcjFsUHVQUUZsQXRPMG55QWNXaHB6dy9GU2pGekdqTHgrUkd2eHpvU2VDMWh3c0E5a2x2YUZONUZBeSs5bUpnbmhhUTBxcWFnZ2xBRG80YzlBaENEcEpQbDVab21tUTg3MzhIY0d3NkFKQlcxVmVjWnYwY2VQd09ZMC93bDFsQUQvV1VDeDBtTWxETHI4YmptYitEd3AzeDRua0RZYkQwdGhJTzVhTnRmbURpL3hHRWVSYXd4aHM3VmIvcTJodUFCUUp3QWxoeXkyY0MweG9nZ2pBQVVDV1dBa2tzT2lJWTk3OFRtT09xZXFxd3FBeDNXR2hISzA2bjdURHdPY0FWL2lpcFBBS2p3Z3JabTJvOG5rVUEwZ0ttQUhUcnArbzlNVHJFWXZxNDRvOXBaSU90Z211OG1hZkNWNzJZQUtUL1J3QXk1T1BPdVZsQUFrOU91bGU2eFFSVFdVS2xXdGtVL0l2QUhBSHRpNW9Jd0RLODQxWlBGdENtZHIwVThQYUM5aFZ1bHRkNENJQzhQMlp0dC9tNS9xQzExVEpYbEpER0dwZkdBbVlPRGdGb0N4QUNrTHB1V2gzS0NncUU4Z05WWks0S3R4Z2pKQUIvMlgxS3JhbzFyZk43Q1daZjNMU0JUNHVBRUl5V0JWcGlwTDdHZ3dBMEFXMjVHYkdFTkJUUngzcm0xTTJ3MzltbXJGVndqVGQxS24rVkFaQUxFRTVMdElEeU1XVUJ2YkxOTEdIZ2Q1SC9WMDdCRHA3cjN1VStKYWRnbjNwdHhla0E1TUJyaTAvV3A0d3pCakRiQ25rTVdNcVZwRThHSndMUXF2ZmMwcHFia1ZqNWFOazdnYkN4Z0pubzMwY0FqbnRvd3RYTmFaMXN1dlNLTmhzWVRjVkttdzlGNXhHRSs5NGRmRW9QK0pZaEQvOE9DOGVJUFVzVUhva1ZWS0I3OFhzemJ6QUY0UHZkLy9QQ0tWR0lwT0FyNzhtbjREWk9tOFlDMWpjbyt3NkVGVEREUEpxZUNFQlpCYTVHZmZWYmhtUThEdFpXNVRZT3ZQaFhpcDBHVHV1MjJsVE1MU3crYUFWbDlRaEVXanVySS9hUWlMSmtUTUxzWDlSM3IveW1aNzNmcDErMzdPVTlodW5YU2tkbDdUM1FyaEtDdGxDTTU5azJpNUNNTVNJQUdkcXhFSXdybXB0elRzQ0V1dDV5aWxLb0pMQWN4Q3EzZmU4dExDREJGd08rdEtqeXV4U0NNZFlFWG9lRHJIY0h2dTB0VHdMem13SEE0Ti9HaDZ6TkNxcWVPU3hDMmxiOHRRU2lNd2J1cVhJcUFjakZoMkpqQktHSnlTaFFHNnlnVmJmSmVnVUxXQlljTVIzcnZiNm9DUmFRd0ZQZ2wxTTVyUjcvSnRCWk9JWld4LzArczRRZVk1ei8xL1gydEZuQXhQcEZFTGFWa2RMTjhNV0dWcjRwQ0JzZk1ITjhibVRLZkNqWjBOY3A0NTYveDU4ekx6Znc2UWYzQUJkOHBVZ0VZbXFrNWJHeWVrMDZJUWwxYmtYU2NubE4vdThMMjRHZHgxcVZxOTFLUXZycGd3YUFBdzlwK3duWFB3MVlqeVdNR3REbzJBU09GR01VN1NJRVV6ZFlEMzR2TVBtWHdMYkhnZGtGWUF0bEdpaW02RHB4SnR2cTlMdGxWci9hV0tFQjhwVVhBT09QQUZQendCVFo5cjA0dmRROVRzNHBBWjNjZCt5SHhnZk1BT0grdmNBNjkvOVV4aWptei9BZXJZcGRhcjFsTlNNWXpWK3ZXWS8zNEk4RFk1OEdwaDhCcG84QTA0dkFGRUZJa25JSG9oR1ZSNjJRaEZSU1lqUUU2cUZyaTJ6M2lhUEFoSE5ObHhLd0FySTBRMUlBeHdmUmVhY2JDNWdCUHA2Ni81SUNnTEtDdHFuc3JLS2xyRlpVRlBLT3I3b3NNVHRkc3h6cVFSWjkzUTFNUEFSTVBsbG9oVXhScWtFSzZnU2hPUDBTK2RZMmhsUnY5OXkrb3ZSaTdJaVRuVHZMcW1nNnhEUFlwcUFVZ1Jnc29SN014Z0ptZ0hEL2M0RTFGWHU3RlJSYnZFZ2Q3ZXZYV2xiUHBwOUVnVWppSnB3ZTZ6d09NbHZwQVdDTVZ1c0pZUElZTU9sU0RaUnBvR2lOeEt6YmRJUWxYT05NV0piR3R3NHN2ZGd6M0VsNDduelRSdlBycktwdEFKVDZacnpmaW50dkFKZ3g0dnN2ZFF2SVhLNVZZRjNzVVp4bUpVdmdBMUZPdndGOHNwS3lCdE0xeTZFZXBJNExxVk1lZGJFYVRwMEVJS2RQS2g1RnFZWXFTeGdvMmpnRnIxM2o2WFhIbk9pU1pPZUJWU3Z5QzhxQzJyMDVGVnZWdzljQU1BT0ExNzhBV1BNcDJMSmFhZWtpQ1BYRXh3SHc2NjBuMW9CL25pR1FhendPa2tTZXBiSi83MkkxeDRDSitjSjZsWUkxcmljY3JWaWNVdVZTbUlXODJwa3duSEhWT0tiRnNPb3pRR2tGa3dld25CRVMzN0FCWU1hQVgzOVpBVUNDYjgybklsbys0MHAyZ05udnNvS3VueEgxeEd3QS9MT3pkUU9RSlBJdUh6VjJHQmc3Q293N0FJMGwzM1hmak9zdjZvVm9kZXM2SVNiQnNBWk1YK2tKeFU1NktZN3BrbUZWaE9jaXV2VHpTdDA1djArcnl1VC85Z0RyWk5lNHdQTXNJN1ZKUDNHY1A3Z1VPT2R2Z0wxclJZSjBaSTVJVjNoVjQvd3JHWVBQVTMvQWlSaFl1c3kySzdtVTk5OVArejkwT2JEN0x1QlpLMFhka2VxOU5TWDIrbzRITHdmV2xvcEZDQzBmZ2NpQk10QUZDOENHcllYVm9Wam5VMkc3clRYcnpoNGtmUnpMWTFreUd3Qm9laUdjUGlYYjVlQXpkWFduYXpQQ1NTY2I0ajN4Zm1hdjhDeDJwNTBsQU1XMFZYSU5pdENvZ2wycjlIMmRjY3RXd1F4UXNuNlpUQmJNTnRjZ2RLSWJpWmo1MVZjQmszOENYUHhvUWNmQ1VnOHBqY1lnWlNjdy9tb21BQ25YeXI0bGVCaHM1UWFCVEhwZjdYOGRNUFlKWU84WGdBdjllOFFKbEFaWnE4RDR4U3VBTllLUEpRbjBBUjJBSEt5MU1BQ0tlOW5mRkk2SUVxZHVFV29ISUo5d2xzVktMZWtvTUNhOUVBZWdTVFlRZU00VFhjbzJTRU1rQUhFYkJab2o0YmJZdGR5Q1ZyRnFHWGdUU3hnWFlUWmVITGk5QU1qRVFSQ1ZVWFAvbjRLVWFhVDh2VlRpK1J0ZzdHUEF1WWNBV2xNQ2dVVmtRZkoyUTEyeUJ2UFhNd0hJbWhEV3dmODFpbXNUaUxTRXZIWmtyK2pZL3A5Q1FSRDRwOERPQnd0ZUl0YWkwNXFuMzFGRmRmTGxGeFlXZ0NEVUlrUmtqL1R4YkNFaS84OWpmUFozWDJWcVlTSlFibVVOUVkzSFFUN2hidjJzTG9lclZ3S1FITkVFb0NzbThSNE1oUFJqWFVHelZFSUtJb1k3eWFFWXVZNGRnR2I1UlhydW9TZ3RTQ0xMYXJrSUNROWY2UU55a0dqRmRqc0lCYUk0a0dsdDhXK1JnNWcwSEo4cUFwNDduaWhBekZwdVd0UElNQlpKbEFTSUx2UjZmUTBEQ1ZiSkNrSk9KQ3FuazRwR3BiOTl0WjhNb3B5aUtEWDdXV0Rpd1lLWGlFUU9laENyZ0toK2VKUStFUUhvMUxieS96Umx5ZjhUSWJmOVhTNWZ0SWI4STkyWXVnSDRheTJwTHVzb3JsN2RBb29uV3RNd1FTVGRPRnVRU0xUR0h5SUM4a3hTSVF1QTRod1UyV1VBb080L2dyQmNEYnNmV0VsU3pnK0pDb1lEb0VHTTFpeFNrSHpnRi93Rzd5OHNJYTNKN0pQQUdXdUZKU1FJYVUwMWlKSFVpWVA0ZTMzQnJQT0htRy9KTWFPZlRaVllSaHdHYXY4N3ZXS1BKOS9yU0g0SU9HTzVzSVRxZy9nZ3hYczRUT2FCQUVDYmVvT3NnZmwrRHJRU2hGcWNFSWh5eXQwTWJNdXNFa3g3NmlBWlhLTThCdlhpWkFHbEYrS2FJYmFhZFlwZW00YURncEpaUXo2WUpBQlY1VmNIQUpaMHY0RnhYNktHNVVwWXMwS25xamhSdWFnRVZnUGdsWUFsOWNpSGY4bWRVckpoMFF4OXZrREJ6Qnl3ZmJrWVFJR3dhaEEva2dsQVRzSHNEektBMEJBVGlQeVo0TkVEd0llb2EvdUZZS0tYTDJmMjRuUW9JZ2Q5UjN5UUNNVEZxd0lBZmRCV0k3K3lCNVpMRUNZTEVUZDg1WUpsKzJZQVVOb3NMSWVsL3hZbHU0SnNsNmJoTmhENml0NFdKQ3ZBMlpjNEd4bzczUmNnSmVPcUZtR1I2cmNDaExZQUN5R29qbUVZZGo1OUtuWit0SVFSaEg5SXZXQTJoaVJFakRlUkk5Q2x5N2ZNRjNFdFdSRmF3aFFJZjVJSndFNTZ3ZFRJWWR0N3RwOXlzMUs4Sm5vSnZvZDlXbjY4MlBOa1A0aFV5MW5kV2dzdEF0QkRNTFlONS82UEFjNURHTm9GNFNyWmZOKzQrSWhUOGpxd2cyQ3A4VGhJSjV2ZlNXQlhBVkNyV045U014REsrc2thT3Zob0FjOG1lNjU0cG1VQjNmMHd5dCtFOEZ5UkFHbVBsT0VvaVNEMnFndm1BS29PbTUyZkF1aVRESFN5SVJ4eCtsSTBReHhBRHViZkY1dmZmTW1TYWpyV2xQN25tWjNkU3krNHIvWnpBVUVIblE4UjcwSHNYbEsrUGdKc1c2OEc0WFlHWmowRVkyRVlBVENBVDZ0QWhtRTBEWGNDNGZhYXBjd01nQUlmTGIwa3V6VDlRbXc1dXdBQUlBQkpSRUZVU2krRWZlQUxrU3JwQm92YnJRRG5rbTh3QW84L0UzaStDQ3NaOThOQ3BBcDhjVWVrWnlCYXZJNEVUL1RuYUFrL1JRQ3lBWHk2dU5TUEEwaSt3TWVCNmVQQTVIRmdacTJ3cE5HSzNGVURBSG12M2ZTQ2U3YWZYOENCNFVORUVPb2xWaS8zb2Jhc3ROd0o5Y081Qk9CS0VRTXNBY2lmSFd6UkFpZ1dXQWxDbjVLMmJRWUFPZTFLTWpUSVIya1JVaEtWUzdJckxpYTB2KzN4d0hNWk1DYllOUDBLZkc3OXpBcUs1RHhPdnlFdVd1NlZENUtTSHkyWUFFUUFmcGFSZGw1VWt1VWN0SXBCbkNJSWw0cHNEMDNGdElJUDFBREFsQnVKTTQ3RXFxVVgzTFg5a1NCUWN1dXlmdEs3OHhVa0h5UStSTHFIWjNGdjFLY2dMajVrQVExczBRbzZJQTFuSGhOTFF6QThaeHZCWHVOeDhEY1M1VVlwTm5vWXhzQ25VSXF2Wm8wRjN3UFRNYTdIdjUzSE9KVmJTL2wrNWJ1bVg3ZCs1V0xFNDRoeElSSkIyTk1DcWo5aXh3dUU5MHN2V0NhSUE2YkFwOTU5RUtlV0NoQXlBMFBUT1YydW5HTVF2ZUNPN2JmcUhiY1M0ckpSN0V3cW53NUFXaEx1SW1nMnVGUUFYQVZzOFJHbW50VzQrZzJoQjNQNzlML0VKOXpHdnFyeE9QaWJpVmloQU9ncldRT2YvRUJmQmNzUE5CQnFXOUh2Nnp6R3FGem1vWHozQjlBZVBnWGlxNmJnaXY0WU9COVFIUzhBZnBrQUZNTWpyV0FjUUEwaU85WEppUXlBbm9zMnZWN0VTSE9PUWZXQ083WmY3RjQwbVpGUVNjUktBWUJhU1U2dkFWY1RnTjd4WEhpVUZwRFRNSzJkRmg1NjkxMkJUaURjdnBrQVRJWHpDTDRnM1dYVFo0anBHZmpvRi9vaWhMK2Z4KzB5V1VBQkx3SXd0WUtLSWFiZ0N6SFF2aTJnZ0JLbjBNY0VRRGFLVDVjR2tJT282U3V5WXpFZmpRQjBFTTVuWmdBUG94ZThvZjNzZ1NxQ1FNM2prZEZMdnBSdlIxMys3VVZSdWhVRlNhdk5PNm90d3A4OFpaMyt0NE02SEx0Y2g2T1Q5QUcvcTljbXRmLy9nVjFKRFljblEyelk2L1lha2ZTclUrUGcxTTQ1TnFQdDNJRXRvTTdXRkhva3lyV0trb29nbENNV0xZamlVWE10SzNnOFV6ZDFXTDNnRGUzdlJSQ29VRVlDd0d0WUZ4eHFnQTJFL2pJMjBGNWhobVFvZDk4QkhObmx4T1RpZzFhR2lEYW5PMjF5VjREeWdXdUI4WWVCNmZuQzlXRXRpS1ZWS2VFMFpHaVhXY3plSm9XTUlpZzVhOVY1REExQU5vS0RlRHlsWjlOU1h4eUFzaUthd3JRcW1DdjJIVmY1ZThhUm94ZmMxbjd4cytraEl0QVV2b2p2eVdyeXhWY1dKWmtzVlN5Wm9RUkEzZGNBb0h6YXg0R2oyd3R1NkZWS003Z01ndGkwMmpiVjQ3Nm9VSkpzMWovQWJBMW1RM1BtOGVUUnNvWkR0Uit4WktDaUVLbU1YVEllWEhQR2RoWUFyWDhGd0c0REdNRW5BSElLNHl2VDU4bldDMmI3M2NleGFaZ1dXYUVLZ1UxZ2pOYlBQN1B2T1lHc1VTQmt2M2hCdG1SV056eGpUazlSV2t0dnhwNlBPajB2QVJqWTlzV2tGZWw4Uld4ZWdqSUY0Ump3QU9uWldNUEJUR2pxdkhtc3p4Sk9CVUQzeHl6bkwyYnFST3ZvUDNOM3E4NGpHNEM3TS9QcGN2TUJlZjBjdlY5azZoWHYrMllubzVRZkdBclJiYUNDMG1XdjJZdEYzZWNlck5EaGtOWklJc1hRUnY1ZGxUdEdBREpTejJnRUUxRUpRTS8vMDI2SGRJRVpMQzhCNkEwdGswZzFKYThEdXpKZHBoUzgyUUJFWmo1ZGJqN2d4Wk41ZXIvSVpJKzY3cHNjZ0U3UWFET1VNeUMwV2I4K2dYanVSNEY1SjZZc2FYbkZoQm9BR0VWdlVoYjYwaklTZ0NRbm9oL09MQmd2SXJMOHY3RGRGa0VZTTVkdE5nOTd0dno1ekpxemRmSUJtSmxQbDVzUCtESlA1eHRXN3hmZm56ZWg3SCtaKzMrUnBreVdUMVl4dVVSSllWdHg2VDBmQ1RvY291UVY4NVZrSFJJR2VnRXVFdi9ZS3BrQS9KY2VWbUw4a3Y2dDUvOXB1NjJ0ZmlQV2NGUVZFYTBEWjlXY0xKRVB3TXg4dXZmbmpUOUlnWnlqOTR0L2xkZUEvUzl0TWFHYTlTTmRtc0l4YnZWc2NWSjFHU2NvTXQ0VVB3aEFzbU1aMGFYelFCc3ZkR1JCalF6MEZVcEVKUkFKUU9xNEtBbkJkeitzZmlQSjNiT1luOGZzeWt5VldNZmlOM0JPemNrUytRRE16S2U3T1cvODhhcVF6c2ZFNWtIMWZ2R2plUTB3QURvZG1WR3dPZWlNc1VxSHJHT25TNFVGeTlQL3dBRW9qa0VuSStJcU9JSlFOTGdwQ1hoY21MQXREL0Qra2dRRTIzNUw5M3RqK1lCcWdUWDlCaUNlVy9OZWRUNEFtUStZa1UvM3NienhCeW1RdVpobThnMVQrUWJWK3dXRmRqS08vVGUybUVGTmxDYjZnUEY3MDhWSjFUWEhnS2Q5MUduWnBEZmkxay9nTTJ2cVUzRFVuQ3VCbU5RZTNQOXZ3NnBlMjI5S092QjBLMWsrWlMrcm5yZk0yQWxBM0pNWnRhaC9FWktaVDNkcnh1RHoxTy95eEF3dTlKZ0p4cjNsUWZSKzhhYThCdXkvd2RXUVpBVmwrWnpDckczcTljL1lya21IeTNJUllyeUFBcUFrRUJJbG9wSnhOTlViRVIrZkEvSCsvK0FBZFA5UG1TOWRhemljSnlibTdtbEI4blIyZEkxSHZnVmtPbFpHUHQybk0yOUdDYW1jR1pqQXdsUSt2dnJWKzhYL3pHc0FBVWlMVlBwL3dkK3phVE1GV3crL2tBQTBHUVFucEN3NW1Ec0FNSXJjUkI1bUMvK01BZmZUd2dmd0tZMktmbUNaNlpJa1VTaHJ4WHhCWDR5WWFWOEh6bWNuMTNqVUE4Q01mRHFXWWVRY1NraFZPbDhVNnV4SDd4ZWtyc2c0OWg4b2lDRU5nQzVUVUc1dkt4eFQ4ZjJhUnRPdGNBS1Exczhzb1B1T1ZVSXdwY2hObEVFSU95TlNJcnJ2djNod25ja1dJWlBac25iY0R5elRwdmczbFU4bXBaUXFvenlmSzc0YWozd0FLaDFMZ3JzRDV0TXhpei9ua0dEMXNIcS9ZTkZPeGtFQWN1VzdvcW1YbGlzdVFPVDdWVjJqd2kva1RnajFSa29aaEJqZThaODNTQ0FFRUpaVzBDM2dmZjh0QURDdDRWQVNhV0lCSzBISTlxOEJGNXlVQU16SXA4dE54NUpnOWJCNnYvamREUFNSbnMwQldJWmVVaXRJbzlJaEhtaFhUdnpDUFFkZGNjblo3NlUxVi9JdkM0U0JDRnlnMjZERk5nN2MrK01oaGI2cWlDaWtUN1dWVW1yNmxZbjJuUkt5cmRaNTFHTUJsWkljMDdHVUJkTWpueTZYQ2lVbXBBNmo5NHZNWmJnQk1GbzU1MnB1MjdQWEFxWFR5QVVRY2l0T1FqQW05eFgwTjlwSXdJUG1TQ21INVF1UHFFUjBMNGtEWWdwOXpPVUw2Zll4a2JaY0ZjZXlBcmVBRjNHbFYrTlJEd0F6OHVrc25UM2ppSUxWU21wV05saE16ZStrOTR2TVpmZ0dBUEplSERqcENyZ00wMVRkcnk5T3p2bVlBekFxTFZXSXdFU2h3emJSd3dTRW4rTXFQNmJRSzV0WmxXeWhqQ0NDc0MxOVh2N2dPbkJSYmdwN2N1LzVBT3lWanFWTW1BNzVkSlo5bkhGMHlvaFdObGhNeEtuUyswWG1NdHdBbUZxNGltbllickVxTkpQYys5a2ZkNjJSS2gwT244cVY5aFhaOWFza0VQZ0FmSTU2emlvY1VnVmJ6R1QyOGxFdFJNb0t0ZzdsQkh0em5mWk5BK0NRK1hRV004azR1Z2xXSy9OTFlLelMrOFU5R1JlWEQwZy9UeXZoNE5lMTdZYjRaYnI2ZzZ5Ny9hTldjb1BwaktSVHNKSWFnczVJSndrRUF2NmVuMDVTNkdVQmZSV3NVRXhaeVZaVlFDUXdyZ043V2ZkZDQxR1BCY3pJcDhPRGVYZlRTYkJhNllZeGxZOC9wM3EvdWRjM0MralRidHZxdDJvYWRuQjJtNG9OZ01uMFcwcCtoWVdIV2J3Zzl5VS8wS2I5RUl5KzV5MmhpQ2l0NFVnS3lUZUFrTjhWYWxrNExlL2xkbE9OUno0QVdXQlJNNmZkSVBmSHN0dy9HK1NFNXJNblZRL2tBNUFrTEhTMGFrN1Y3cmVYZmhnQUNhQnFEdEQzZS9ubWM1azlrQS9BODBKUmVxK1UzOHpHVnAzT2JKby9CdkFPRDNkdHdpV2FyOXpFSHNnSElHbEZ1YnFTeDcrSmphMzZhbkxMY0R2dmd3QStORHBEZklMditxbHp1WHdBWHVTanJrS2VtbE8yZTNVMXVXVVluTDhkd0IvNWUyYXBjYTlMTnYrdnNRZnlBVWhlWDRWZ3VCK216SXNhRzludHF4aEY0WGJlM1FEK243L3VITEFXOXdRMXRibE1SUS9VQTBDYUhDN3BsWEVoK3E0VDBPV2NmaGxlWVRTSEJLMEVIL21pK2ZjUnVLUW40STZmV3Blb0I0QWV2Q3ozSE9PbTl5YjNGNW1CbFpCTmNsWUNqMWFSZnlmcmJnUENUUjZBeksrdkQ0Q3lnbFg3anBtTjdIWTY2ZDFFMGN0ZElyRUVFNHdFSU1sYW0rUGs3WUY2QU1qN0V3QVZiVTgydlRlckN3aEFYb3BKTjl6VkkrQVlyT2VVTExaZ0VyWTJ4OG5aQS9rQUpHV3IwbmFVV2RGcHkyY1Qrb0NXanBkakxGeEU1VXpZSUJCcEVVWDVuTG5sdkFrdGI3NlNQVkFmQU9VSHBpQU1tOTZic1Z0Q0FNYUtBTElDTXl4RHE2Y1hmeWNBK2IvbU9MbDZvRjRBaXFCUklFekJwNy9YMkFmMCtmaTFYSWlvTUlsQUkrQUlQSUdQbWVST1dWM2oxWnV2eXUyQitnSG9GZlppRFMybEMwTGlZNTJXVUFEa1FvVFRNSDFCRlNZUmRIb1JmS1N1NXY5cXJpek1IWVBUK3Z4NkFSaFN1RGNBenptRG81WkdIVDFQQUtZTXdReE1FMmppU28vZ0V3QnJycSt1NDFaT3krK29ENEJhQ2NzWFRQaVNJM2V5OHM0S0dvRzhRd0NNRk0rMGdnUWhMUjBCRjE5U1h1RC9heWFrejd1UjAvVHNNY3hnM1NqZnFXTkEwaHNyZ2Evb2phcS84V1BjQytZSWs0S2U0Q01TdUIyWFZodDFPajh6SWZYbFU4QnRVOERobVlSWFdkZnJkRjFmZ3IzK1M4QXQ0OENEMDREVmpYUVNETzcwUFRVbmFKNXVPQ3dzSUlGSFNTRnkxcEtQV0NEc1p4Q3B3OFVWZ0tTUHhMWE05MzdPenh4QWxqemNQQWJjc3dVNFFoNFYzVU44bUtvZUttL2J1NzhJZktKUWE4VkQ0OEN5bEhRaUwzTzMvcWc1UmYzMEJLQUNNdEpYalhLUWNmQlNLOERmcWMzS1ZDd3VOMlZGR1JubS95S1p0cTRSZTVpZnlRUWdNMkErQmVCM0dIYVpCbzVNQUl1ZTBsN0t0M2NDNHhodys1ZUw3VHVDa0prMWpCdHllcmJVZllHNUV4alovcHFyeEU1ZkFPck9xNVNtb3dWSXJScDFJeVQyUjYrZmcwYmdWWUc0Q3N5WmUyVXNhaU9HS1hyNFNmcDlrOEN4Q1lBRlNLeXZYZVkxbzFCeFF1eDkxeU10ZnNIUHV0Z25ueVV1VXZoYzBac2dVWGliK25Wa3E2K1pLYUFCSUhzZ1ZabnV3RDlzVm82NnJyUjRJbWRoTEdTUTh6UEwvSmdCUXhlVTFvdVdrTzlQVGdEemJnbVh4cnpNa2F0bDNrZWl2Zkc1eDRyNElSY3o1QmZrTzV2RVowa2dwSWZCWjh5S2psTDE3c3l5MHRNTmNPbjlkbDRGeTZkTEZhYmoxTXB2b3c5SWZ5K0k0TmxvOVh0K1pxVTlWZEpwcVpoNFFERHl4VXlZT1lKd0hEZytEaGdJL1dVVlpsN2FTRXQ5MytHTzlJYTJpdVpLT2ZBN2xocDlKcHZBVnk2MXcybU93TzVobUNnTUhDMUg5TzI0Z3U2VUQ5alArWm1idExSYVNzZWk5U0w0WERQYkFFaC9rR1EvcFNVY2MwbGJBcEZXYjY3bFFVaHBWbkxCc29LcXFaY2xGTW1VdHJ4UGN3eGwzWDd2T0NBdFlMU0NjdWdGUW1xaGRzc0g3SFUrUnpuamlPbFlYQTh3cWtPZmtJdFRBb20rb0t5Z2NhNEVTOGpZK04zejdmU0c0aGZVdHAzaWhVSHJ1VlNzRnkxaVJ2TlArMU43QTVCZEpBQ21WcEFnWlBoR095Q2lnRWpsUEx1ZG43a3ZGdE94dUI0ZzZPakQ4VVdMUmtDWkZSd3JMQ0VYSlFRaHAySyszN2xRZUJDUlgxQTdLUFF0bzFwckZFbVNZbjJtQjlFQXNPK2tZZms4S1FoWkY4eWpWejVncC9NenR5T1VqaVc5YkNVaEVCaEtSQ0NnU2lzNDV1US9QaFgveGZGV01nT25XdTJneEIwVEYvbzBrRVova0NETTFUcyszUkhZbndWVUw2WGhERnJBc3dmSUI2dzZQMU1yVHVsWTBzdW0xVklDZ2xLd0NFQUNxdlFGQ1VLM2dIY3NGUUNNL0lMYXlxUDFrOUpzaFZxcm5jTWFsT1lZdmdjR0F5Q3ZJd3VvZDhZQkpRbVpwbUdKZXlSd2tHdzRuOGpKT0pRTnczaWRMRmhNUk5CMFNnQVNUSnlLb3kvNGllWENlRmZKQlVlVjJTb0FjbEZ5UjBiYm0xT0hUVWlOMC9EVEF3RDd6UWVNNTJkcWo4VnNHRWtWRTJqS2V0RzdBRWhRMGZySkF2NlJDMHRyQzFza2wrSVdsTmluR0xiU2FaZzdNYzB4ZkE4TWJnRjFMUVYxejA4QTJHOCtvTTdQVkY5TXMyR1VFMGdReXArTHd1MnlhZ0xnUjlaYVlwa1N5cFE2YTZRMkRDcXpwa3ZpZXRYSUZkb1pmdWllR21jT0QwRGVQMEhFYkJoTndZUG1BL0w4ekpRc0FUQUtuZ3VFcVMrWFRxa0U0WWZXV3dDVUZaVGtzWUFZd1pmSUJlTjlUdzBjak93dThnRElacXNvU1N2aEVlUURpaUdZRm95V2lTRFJ5cFdnaTY5VVA1c2M1ZkljcXVTQ05lWHFlMlg5WkFIZk03S2hlMnBjT0IrQVQ0MSthTzVpUkQzUUFIQkVIZDljdHVpQkJvQU5Fa2JhQXcwQVI5cjl6Y1ViQURZWUdHa1BOQUFjYWZjM0YyOEEyR0JncEQzUUFIQ2szZDljdkFGZ2c0R1I5a0FEd0pGMmYzUHhCb0FOQmtiYUF3MEFSOXI5emNVYkFEWVlHR2tQTkFBY2FmYzNGMjhBMkdCZ3BEM1FBSENrM2Q5Y2ZPeHFZSjJhdTlSZFB0ZHAva2hvRU9sZ2xEWVQzOVYxUHpRRlhMc01YQWxndDlQQ3hKS1BidWZ5ZjgvS0hJUGZCUEFaQUJmNzlYYzVYUTBaUTFRNzM2ME5ieG9IcmxzRHZzNVpSc2dvMHVuZTA2Ynk2WDFtWnZ0UDk5UE5BcDRGNExzQlhBNWdqdzhFR1RlcWFHRjRRaHpRRjgwQ1g3Y0F2R0lkZURZQWZoZFoyc1RLVWNWcnBFN25kMzFONWdqOGUyZElvMm9zazdOWnBNZEswWjE5dHYrYko0RjlLOEQxQUNqOHlmTlNpa0hlZys1Wjk2OW01N1kvOC9aUCtkUExLWmhQL3JjQStBWUFGN2cxb1JVaEVNVXpGTXQ2ZVNKZlg3OGIyRGtQZk0waThHSUFYK3VXbEFNcHByZVVVRXJuOHAyZ3pUbCsyZmxnL3NEYlRrdklPaWsrQ1AyMC8vbXp3QVh6d0RjQ3VOVFBKZUZYcEVwTTZRRWpJSG0velRGOEQ3VDVnQVRZTlFDZTY5YUFsb1JUR3VsZkJFU0JTWU55eFI1Zy9CaHc3aEt3WndsNHZrOUxuTTVKbXNCelV5REdBWDNCOEcyM016L2c5QnVVYS8wSWl1dGZNa2o3endLbW5nQXVYU3ZPcFV2QVdZQnRGNEJUbnNwSWovTzh6UGFmN3FkdldJVHc2ZVpBMEpMUUVoS0VHZ3haaFVqL2R6M056U0t3YlI0NGV4bll2VktjeSttTTVLbTBKaHhJblV0ckdrbXpDUGljZzNXNUxNR2tRaVpaVG05eFM5WjMrNG0ybzhDNWM0WDE1cFRLVzJMYitmQ3g3V0x0all4enFpcWwyOUljdy9kQTVTcVlmNlJUVGlsZytsWUNJWG1JQ0tRNElLOXd4ZlNKWThBWks4Q3VGV0RuYW5FdWE5WlRBTXNhQ29nM0R0OTJPL012blJHQnRHd2txS1JtTUVrcUNhYSsyayswTFFEVGg0clA4OFVIajc0a0YxV2FBVG85UUhRN21tUDRIdWdZaHRFS2o0UEI2WlErRlMwaFFhaHBsZFB5YTFrWFRPcU5ZOERzY2dHK0hhdkF0dFVDdkJ4SW5pdHJrZ0w0bGNPMzNjN3NwQmRNM2tBdVNucTJueDlnUWZBaDRKeVZ3dnJ4d2VsMnozcDRhTWx6SDZETTJ6L2xUKzhhQitRL09UNEVFcWNrV1FTQmtHRDZFUUtRbkRDTHdCU25ZZ2NmMzJmWGlvR1VGYXdDNGVzeXU3Q1hYbkRQOXRPQ3N5RDRLTEIxcm1ndlg3emZidTJXRy9KdG1lMC8zVS92S3hCTkFNb2kwS2Nqa0FUQ04zSE9FcjNVQWpEcndPUDcxclhpeFlFa2VLTUZsU1g4b2N3UjZLVVhUSjdBYU5FMnRGOFdmQTRZZTdLdzFtd3ZYL3labitlS252Y3JmekM2SUsvT2JQL3BmbnBmQUdRbnlTb0lTQnFVWHlBQVNTMUFLMEpmYWdXWWNSRE9yQUY2NlR4WlFVN2pCT0ViTTBlZ0g3MWdjZ1hTRlpBVjU0TlF0ajlZY05JcGJPTkN5aDhZZ2k4Q1Zvc3BBcER1QjYzZzkyVzIvM1Evdlc4QXNxTTRnTElLQkJJSDhiY0p3TUNOTVg2OEJUcUJiOHM2c0dXdHNJQTZqd0RrNjYyWkk5Q3ZYakE1QTZOVmEydC9JQWljbkMvYUdWKzhUNzRJUVBtL0FtR3VCYys4L1ZQKzlJRUF5THNsQUtNVi9MZ0F5SVVJbmZuandQUXFNT09nSS9Ec3RRNU1yN1VBcU1GOFYyWVhEcW9YWE5sK0VRUTZOOXYyOWFLZGVzVXBXSlpiQVB5UG1lMC8zVThmR0lEc3NEaWQvcFVBU0N2Q2FYZ0ptRmd1QUVmZ0VYVDI3Z0RrdXdhVWcvbmJtU013akY3d2h2YkxoU0RMNVR3d3ZkUnFvOW9xSHpBQ2tDQjhVMmI3VC9mVGh3SWdPMDFUMUlNQ29BWnhHUmhiS29BWFFVY1FUamtJK2E0QjVlNUZ6akdzWHZDRzlnZHFyTEdGWXJwVkcvVXVIekJPdzIvTGFYeHpiaDQzREtlb0p3bEFIcUxuZFNzNHVkb0NvSUJIUUU0NUVQazNEdWl0bVlPUW94ZGN0cDgrckZ3SVdzR0ZZaUZGb0xHTmNoY0VRQzZlK09KQzVKMlo3VC9kVHgvYUFwWWRKMzdBeUpLL0RJd3ZGeFl2V3IwSXdFbi9IMU9wY281c3ZlRFVoU0FBRjRISnBRSmtXaXhwNmsybjRJWWZNR2YwYW1ESGV2Mkk4K2w0L1Vidk53OEVvenc3MndKZVBPSjh1bmQ3RWtLajl6dEtHQTEvN1d3QVRvNDRuNDVwV0kzZTcvQUFHUFdaMlFCa1lIQ1UrWFRNZkdHUW1ZSXhqZDd2cU9FMCtQWHpBVGppZkRyS3RUWjZ2NE1QL01seVJqNEFSNXhQRitWYXFaTEpGMVV6S2RQVjZQMmVMRERyM0k1OEFJNDRuMDdaTUFSYm8vZDc4Z011YldFK0FFZWNUOGU5WU9uMlVoZXUwZnM5dFVDWUQ4QVI1OU1wRzZiUit6MjFnS2ZXMWdOQXo0Z2VSVDVkVEVabzlINVBQUkRtQXpCbVJNOEJKenFmTGlZalNLS3IwZnM5ZFlCWUR3QkhtRTlYdFJmTXNJejA0YVFaMStqOW5weWdyQStBa3FzOHdmbDBCQ0NUV1JxOTM1TVRZTDFhVlE4QW8xemxBbkFpOCtrRVFHWlROWHEvdlliNzVQdC9mUUFjVVQ1ZEJHQ2o5M3Z5QWF4WGkrb0RvRkx5VDNBKzNSY2F2ZDllWTN4Uy96OGZnQ1FYL0xQUjNTT3prb241NWpnMWV5QWZnRDhNNE5jQVBENmFEbUJ0QjFlNE5NRE5jZXIxUUQ0QWJ3Ynd4d0RlNFV2UkU5d0haRzFnTlNYRExsd0xOY2VwMVFQNUFQeHp6d2o5SUlBUG5YaFQ1T1JjNUVZQ0E5SE5jV3IxUUQ0QW1SSDZGUUJNVFNaWkg5OFptRDVCaDVnMUZvcGlObnMxeDZuVEEva0F2QWZBRXdEdWRuSStFdlF4UGZrRXpZZmFDWFJTQmx1UU1CN1lIS2RHRCtRRHNCTkJILzkrQWtBb2JxVEFER0s3SW53MXg4bmZBL2tBN0VYUXQ4a2dyR0FHTWZCeFo1Q3Y1amk1ZXlBZmdMMEkrcjY4dVIwUW1VRm9CUVU4dmZOdnpYSHk5a0E5QU9Sb013N0NkR1FDam9VWkR3TDRrdi8rOE9aMWdKaEJJakdEZ01oM3ZUYXZCYzAzNS9SQVBnRDdKZWdqT0RmaGlNd2dvcWVKd05QUFRhQjZFenEvaHErc0I0QWNYZVhFUCtaaEdWbzl2UmltSVFENXY1b1BBWkN1cGdESTl3ZzgvcXovMVh6NTV1c3lleUFmZ01NUTlHVTJPcDRlQWNocE9JSlFRRXovVnVQbG02L0s3SUg2QU1qZ0d6ZGw2UXR5WDVqV2pwUUZldkYzbHEzeGY2eWhyT2xJQVVnUUNvalI4Z21FK2w5TmwyKytKck1INmdFZ1I1VUE1S1lzYytBWm1DYlFDRGkrSXZnRVFNb2IxWEJFQUhJYWpnQk1MViswa0Nkd3M2YUd1M3pxZmtWOUFHVHdqZnRnM0pSVlZSQXRIUUVYWC93YkFjb1hQNWQ1Q0lEOEdvSkt2cURBbG9LT29Jei95N3g4YzNwbUQ0emhhcXdqUnpDWXlRZzVncjJaZ3NGVEx3ZVdyOFhRZ3NYamJ3TFdybk50TWxLZ05vTEJtWkFhN1BUQ0F1WUlCbE12bFdRc3d3cjJVbFV3NDVqZERTeDhIYkQrQ3RkK0hWQ3dlUEtiZ0pWOWFBU0RNOFlnNTlUV0ZEeXNZUEJ0bVlLOTFJYk5PSGFQQS9NN2dVWEtYQTRoV0R6NzljQTgrVzBhd2VDTVVSaisxSFlmY0JqQllPNTRNTVkzdEdEdjhJM25tV1NIT3pZT0xKMExMUEdYQVFXTHozb0I4TVFVc0VhMTZrWXdPRzh3aGpoNzR5SmtVTUZnYnNObENmWU8wZXB3aXNzVlkzNGJzSHcyc0VJUmtBRUVpL2RjVTBTUDVxaEYxZ2dHNXczR0VHZFhyNEw1MTM0Rmc0a0FqdURRZ3IxRHREcWNVbVpFVHdBclp3QXJ1NEJWcXN2MEtWaDgvbzNGNHYwUVhaQkdNRGh2TUlZNHUzTVlodjk1WmgrQ3UxeEJjeHVPVS9IZmVESXE1Y3Y3RnV3ZG90WGhsQ0JYak9YWkFueXJPNEJWNmluMElWaDh3U3RMdVdDc1VBeXZFUXpPRzVBQnorNGVCK1IvZXdudS9rT1AvM0cvbDRrSlRFUmxsalF0SW90MmU1My9Jd08yT1BsNEZMdGNuQ3FBcDljYWhUNTZDQlpmK0xwU0xoaHoxTjVxQklQekJtVEFzL3NMUkhjVERLYmlOSGRCR0d5bU9DLzNoZ2xFdmdqQW5vSzlBN1k0K1hnaVY0elZXWURBcy9ldHhhdWJZUEZGUDFRa0x0Q0lQOG5lYUFTRDh3Wmt3TFA3QXlDL3RKTmc4TC94TE5CdStZQmRCWHNIYkhFRkFJTmNNVmFtZ2RXWkFvUnJmUGRYbThLaXRMZG1nWXZlV0FxKzJ5N2lNcWZ1UmpBNGIxQUdPTHQvQVBKTHF3U0QzK3k1VDF5STBBb1NiQXhNTXpHVjFvOC9NeTJybzJEdkFLMnQrR2dpVjR6ajQrM0FJd0RYdHdCclZKZXVFQ3plKzlhVzREdXQ0UHhrSWhZc2RldEdNRGh2b0RxY1BSZ0ErU1dwNE80dmVRNVV2L21BR3dSNzgrNnJRcTRZcTlQQU9pMmZBNC92QmtLdWRLVlU3Vlp3Nzd1S3ZXRnVaYnRjTU5iNXYwWXdPRzlnK2p4N2NBRHlpNlBnN2djY2dJeGxjQTVUS2hhRDAxeVlLQm1WRnBCWk1meC9tMkJ2bnkzdDhMR3FvcVRsaVpiVkkrZ01nSHduTUFuQ0lGaTg5N2NMQUFaNlF5ekZ6elNDd1hrRDFPUHM0UURJTDVYZ0xtazVKSGsvU0Q1Z0tkaWJkMzhWY3NWWUdtdUJUYUF6RUhMSGd5Q2Nhb2tCNy8xSWtVRVQ1SUt4d0Y1cEJJUHpCcWJQczRjSElDL0FhZXF2UEw5cG1IeEFFK3p0czZWZExDRC9sY2dWWTNVeVdEMEJqMVp3cWdDZ2dYQTdzUGZXQW9BSnZhRXRaQnJCNEx5eDZlZnNQQUR5Q3RtQ3ZmMDBzL05uT3NnVlkzbThCVFJaUFp1R0JVQUNkQXJZKzVsV0RxR21ZYklyTEhFeDBnZ0c1dzFPSDJmbkE3Q1BpelFmYVhxZ1V3ODBBR3l3TWRJZWFBQTQwdTV2THQ0QXNNSEFTSHVnQWVCSXU3KzVlQVBBQmdNajdZRUdnQ1B0L3ViaURRQWJESXkwQnhvQWpyVDdtNHMzQUd3d01OSWVhQUE0MHU1dkx0NEFzTUhBU0h1Z0FlQkl1Nys1ZUFQQUJnTWo3WUVHZ0NQdC91YmlEUUFiREl5MEI4WllOTWJrWCtaZWtwdUlpT1FyUGFyK3hzODg5SEpnNmpaZzVqQXd2Vlo4QitsbDlQbE81L0ZjL28rRUNqbkhmaTh6WWZrdk01dWxtcDRxSlhWcXg1ZGVENHpmQWt3L0NHeGRBWmdvSGZ1aDEzMVFrYUk1aHU4QnM0RHM4QjBBV0xuSVJHQ0JzRmZuODdKZmZETXdkak93NVI1ZzhnaXdaYTM0am5RUVV3RG85OXdCZko0VE03Q09pTmRsYWoyckEvamVWL3ZmRGVBVEFQNFVHSDhJMkxyYzZnYytTSHFZNG9NWjc0VlNLTTB4ZkErVVV6Qi9vQlVVQ0tNbDZ6U1EvUHNYcVpENUtRQy9BMHcvREV3Y0FjWVhnWW5Wd3Bwd0FEdUJrZWZuQ2ltOTBGbUJXWHduSzg3VWVuNTNCSThzYnV3cWF6OXA1VWduUWhCUytaTjF6RThBazB1dHZpQ3dxOERJOC9ueDVoaStCemI0Z0p6S1pFMVNFRlpaZ1M5LzJwV1IvZ1RBSjRISlE4REVNV0I4QVJoZkJzYVdDd0RxdXdRS3Z2TmdIWHZPY1lWYlBGSlBrdytkRHhDL1cxWTR0V0Rwdy9SbGdvNGxvMVQ0L0t4VGloRE5wSndqMy9VaU1MWGVtcHJqZmZDN2VXcHpETjhEbFlzUURpS3RWeHpFcW9Ia3lYOUhSaXpXK25JZ2FRbnZBaWFlQkNibUMwczR0Z1NNdTJyTWVQQVI5WDI1MmpYa2xhVEZVMTA4SzBNSGF2L252SjZaeFZWazlPSTdHUjJJWm9HUU5jL0hnYkhnSXdxSUxJVnVqdUY3b09NcVdGYXdDb1J4a2ZFSUI1Q1dna1JFQkNOZjl3TVRjOEE0UWNpQld5b0d6MTZyd05nYU1MNWVXS3BjdFlaTDNOK1RXTFgwZ3Z0dVAwSEhrMm4xNkpEeXhYbVZoZlUwcXl3YkpicjVHU3VYS3hBL3NWNVk5VVlXZG5qd3lTM3FLS2dhcldBNjlXZzZmalFPSUswSGFkbklqUFZGQitBaU1FNEF1aVVrQ0ZuRVN5Q1NrbUF1VTdDam0xNXdYKzJYMmlmQlJuOUE4bUtjVzJVRmpVTFZRY2dWRGw4MHU0MFNZaDc2M0ZmdnF1aExDeGl0b0JZVXNvSmZqWEt0dEJ5TXE5Q0tjSG40c1B1Q2JnWE5Kd3lXa0VDY3o1UTM3NlVYM0xObmNaeVFBQUFERWtsRVFWVDlmRmdJSnM2bEJCd3RuM1R0NkZwSXo0UldudVF4UGgyWElHem00Q3dROWhXSUZnQlRLMGdRSGlJQUpkZEtxMEVMUWgrS0wxcVVSNE12U0Vzb0VOSUtyZ0FMSE5pTW94Kzk0Szd0bDlxbm5NaW84TVNmNlNOd0dwWVZqQ0RrL0p1N2lzcTQ5NmZDcVgwQmtEZXFsV3dLd2ljMWdBUVNwekdSRW5GZ1JFejAxZUFMTHZ2cTJLZmk0NW02Y2YzcUJYZHNmeFJiSk1obzhkaW1xT2hFSzhjWFFScjlRVnB2UG9ETk1YUVA5QTNBQ0VMRnhQaCtqQUNrUDBmTElLRkNDUlJxS3VQVWRxamxDOW8wN0pad0tWTkhlQkM5NERRY1pPMFhBQWttZ290QWs5UVlyUjlmL0J2QnlZZk1TQVREVk16d1RYTU0zUU1EQVZBZ1ZIQ1o3L01hUUs0UVpVSGlOQ2JCUWxxVXc3NFlDYjdnY21Za2VsQzlZRmx3dlZ2N1JSQW9yVHVCa0VDVTlhc0NJRDkveDlCOTM1ell6eUtrcXBmaU5IeGNBMGdMUWd2QkFhUFZrQ3FtM2gyQXRDNW0vUnlFcXp3LzR4aEdMM2hEKytNbXNsZ3FDYmdVZkxLQWNScm1UbEJ6RE4wREExdEFYVWxXY0RtMUlPSUlKQWpsVC9GZDA1bGJGUUZ3amR0Z0djZXdlc0Z0N1JjL0d4OGlXalVDakdDVDFZdldUMU13Z1VxcmYzTkc0NXRUYmN1MGF4aW1XeDl4RU5jRVFIR2JjWUFFd3RTWFNxWTBnbkNkZ2V1TUkwY3Z1R3gvRlVHZ0Zod0VZclI4MFFja1dOK1gwZmptMUR3QVd2OFJnSkZpbEpaQnpuejBwUWcrQVpBQWxWV2gxR3ZHa2EwWHpCMGNDUWkzMGFTR1ZhOUFGNjJmTE9CN01ocmZuSm9Qd1BFUjU5UHgrbzNlNzZtTDVLd3AyRzU3eFBsMGt4YzNlcituTHZ5S3RMbWhmVUM3OFJIbjA4MU9ObnEvcHpjQVI1eFBSOW1SUnUvMzFJVmd2Z1VjY1Q0ZE5hb2J2ZC9UR1lBanpxZWp1bXFqOTNzNkEzREUrWFJVZzJWU0NqZGFHcjNmVXcrSStWUHdpUFBwcUpqTzhKMU53NDNlN3ltSHdIb0FLTUZkN1FFckFlRUU1Tk5KTWIzUit6M2xzR2NOemdmZ2lQUHBvbUo2by9kNzZvR3dQZ0NPS0o4dUtxWTNlcituS3dCSG1FK25vcVJHNy9mVUExOTlVL0FJOCtrRXdFYnY5M1FIb0VoWlRuQStuWXFTR3IzZkJvQXRhaXFCVUltZG01aFBKd0EyZXIrbkt3QkhuRStYMWdVelNiblIrejExd1BqL0FlQ3BQREQzdDdydkFBQUFBRWxGVGtTdVFtQ0NcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zbWFhLmZyYWdcbnZhciBzbWFhX2RlZmF1bHQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodE1hcDt2YXJ5aW5nIHZlYzIgdk9mZnNldDA7dmFyeWluZyB2ZWMyIHZPZmZzZXQxO3ZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzIgYyxpbm91dCB2ZWMyIHZhcmlhYmxlLGNvbnN0IGluIHZlYzIgdmFsdWUpe2lmKGMueCl7dmFyaWFibGUueD12YWx1ZS54O31pZihjLnkpe3ZhcmlhYmxlLnk9dmFsdWUueTt9fXZvaWQgbW92ZWMoY29uc3QgaW4gYnZlYzQgYyxpbm91dCB2ZWM0IHZhcmlhYmxlLGNvbnN0IGluIHZlYzQgdmFsdWUpe21vdmVjKGMueHksdmFyaWFibGUueHksdmFsdWUueHkpO21vdmVjKGMuencsdmFyaWFibGUuencsdmFsdWUuencpO312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjNCBhO2EueD10ZXh0dXJlMkQod2VpZ2h0TWFwLHZPZmZzZXQwKS5hO2EueT10ZXh0dXJlMkQod2VpZ2h0TWFwLHZPZmZzZXQxKS5nO2Eud3o9dGV4dHVyZTJEKHdlaWdodE1hcCx1dikucmI7dmVjNCBjb2xvcj1pbnB1dENvbG9yO2lmKGRvdChhLHZlYzQoMS4wKSk+PTFlLTUpe2Jvb2wgaD1tYXgoYS54LGEueik+bWF4KGEueSxhLncpO3ZlYzQgYmxlbmRpbmdPZmZzZXQ9dmVjNCgwLjAsYS55LDAuMCxhLncpO3ZlYzIgYmxlbmRpbmdXZWlnaHQ9YS55dzttb3ZlYyhidmVjNChoKSxibGVuZGluZ09mZnNldCx2ZWM0KGEueCwwLjAsYS56LDAuMCkpO21vdmVjKGJ2ZWMyKGgpLGJsZW5kaW5nV2VpZ2h0LGEueHopO2JsZW5kaW5nV2VpZ2h0Lz1kb3QoYmxlbmRpbmdXZWlnaHQsdmVjMigxLjApKTt2ZWM0IGJsZW5kaW5nQ29vcmQ9YmxlbmRpbmdPZmZzZXQqdmVjNCh0ZXhlbFNpemUsLXRleGVsU2l6ZSkrdXYueHl4eTtjb2xvcj1ibGVuZGluZ1dlaWdodC54KnRleHR1cmUyRChpbnB1dEJ1ZmZlcixibGVuZGluZ0Nvb3JkLnh5KTtjb2xvcis9YmxlbmRpbmdXZWlnaHQueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsYmxlbmRpbmdDb29yZC56dyk7fW91dHB1dENvbG9yPWNvbG9yO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zbWFhLnZlcnRcbnZhciBzbWFhX2RlZmF1bHQyID0gXCJ2YXJ5aW5nIHZlYzIgdk9mZnNldDA7dmFyeWluZyB2ZWMyIHZPZmZzZXQxO3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7dk9mZnNldDA9dXYrdGV4ZWxTaXplKnZlYzIoMS4wLDAuMCk7dk9mZnNldDE9dXYrdGV4ZWxTaXplKnZlYzIoMC4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9TTUFBRWZmZWN0LmpzXG52YXIgU01BQUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU01BQSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtTTUFBUHJlc2V0fSBbb3B0aW9ucy5wcmVzZXQ9U01BQVByZXNldC5NRURJVU1dIC0gVGhlIHF1YWxpdHkgcHJlc2V0LlxuICAgKiBAcGFyYW0ge0VkZ2VEZXRlY3Rpb25Nb2RlfSBbb3B0aW9ucy5lZGdlRGV0ZWN0aW9uTW9kZT1FZGdlRGV0ZWN0aW9uTW9kZS5DT0xPUl0gLSBUaGUgZWRnZSBkZXRlY3Rpb24gbW9kZS5cbiAgICogQHBhcmFtIHtQcmVkaWNhdGlvbk1vZGV9IFtvcHRpb25zLnByZWRpY2F0aW9uTW9kZT1QcmVkaWNhdGlvbk1vZGUuRElTQUJMRURdIC0gVGhlIHByZWRpY2F0aW9uIG1vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDLFxuICAgIHByZXNldCA9IFNNQUFQcmVzZXQuTUVESVVNLFxuICAgIGVkZ2VEZXRlY3Rpb25Nb2RlID0gRWRnZURldGVjdGlvbk1vZGUuQ09MT1IsXG4gICAgcHJlZGljYXRpb25Nb2RlID0gUHJlZGljYXRpb25Nb2RlLkRJU0FCTEVEXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU01BQUVmZmVjdFwiLCBzbWFhX2RlZmF1bHQsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogc21hYV9kZWZhdWx0MixcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04gfCBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJ3ZWlnaHRNYXBcIiwgbmV3IFVuaWZvcm00NShudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgbGV0IHNlYXJjaEltYWdlLCBhcmVhSW1hZ2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBzZWFyY2hJbWFnZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGFyZWFJbWFnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICBwcmVzZXQgPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgZWRnZURldGVjdGlvbk1vZGUgPSBhcmd1bWVudHNbM107XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQyMCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEVkZ2VzLnRleHR1cmUubmFtZSA9IFwiU01BQS5FZGdlc1wiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cyA9IHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldFdlaWdodHMudGV4dHVyZS5uYW1lID0gXCJTTUFBLldlaWdodHNcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIndlaWdodE1hcFwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyh0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjgoMCk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25QYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCgpKTtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uTW9kZSA9IGVkZ2VEZXRlY3Rpb25Nb2RlO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLnByZWRpY2F0aW9uTW9kZSA9IHByZWRpY2F0aW9uTW9kZTtcbiAgICB0aGlzLndlaWdodHNQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IFNNQUFXZWlnaHRzTWF0ZXJpYWwoKSk7XG4gICAgY29uc3QgbG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIyKCk7XG4gICAgbG9hZGluZ01hbmFnZXIub25Mb2FkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoVGV4dHVyZSA9IG5ldyBUZXh0dXJlMyhzZWFyY2hJbWFnZSk7XG4gICAgICBzZWFyY2hUZXh0dXJlLm5hbWUgPSBcIlNNQUEuU2VhcmNoXCI7XG4gICAgICBzZWFyY2hUZXh0dXJlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI4O1xuICAgICAgc2VhcmNoVGV4dHVyZS5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyODtcbiAgICAgIHNlYXJjaFRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICBzZWFyY2hUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHNlYXJjaFRleHR1cmUuZmxpcFkgPSB0cnVlO1xuICAgICAgdGhpcy53ZWlnaHRzTWF0ZXJpYWwuc2VhcmNoVGV4dHVyZSA9IHNlYXJjaFRleHR1cmU7XG4gICAgICBjb25zdCBhcmVhVGV4dHVyZSA9IG5ldyBUZXh0dXJlMyhhcmVhSW1hZ2UpO1xuICAgICAgYXJlYVRleHR1cmUubmFtZSA9IFwiU01BQS5BcmVhXCI7XG4gICAgICBhcmVhVGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI1O1xuICAgICAgYXJlYVRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyNTtcbiAgICAgIGFyZWFUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgYXJlYVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgYXJlYVRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRoaXMud2VpZ2h0c01hdGVyaWFsLmFyZWFUZXh0dXJlID0gYXJlYVRleHR1cmU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImxvYWRcIiB9KTtcbiAgICB9O1xuICAgIGxvYWRpbmdNYW5hZ2VyLml0ZW1TdGFydChcInNlYXJjaFwiKTtcbiAgICBsb2FkaW5nTWFuYWdlci5pdGVtU3RhcnQoXCJhcmVhXCIpO1xuICAgIGlmIChzZWFyY2hJbWFnZSAhPT0gdm9pZCAwICYmIGFyZWFJbWFnZSAhPT0gdm9pZCAwKSB7XG4gICAgICBsb2FkaW5nTWFuYWdlci5pdGVtRW5kKFwic2VhcmNoXCIpO1xuICAgICAgbG9hZGluZ01hbmFnZXIuaXRlbUVuZChcImFyZWFcIik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSW1hZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHNlYXJjaEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBhcmVhSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIHNlYXJjaEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IGxvYWRpbmdNYW5hZ2VyLml0ZW1FbmQoXCJzZWFyY2hcIikpO1xuICAgICAgYXJlYUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IGxvYWRpbmdNYW5hZ2VyLml0ZW1FbmQoXCJhcmVhXCIpKTtcbiAgICAgIHNlYXJjaEltYWdlLnNyYyA9IHNlYXJjaEltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICAgICAgYXJlYUltYWdlLnNyYyA9IGFyZWFJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgICB9XG4gICAgdGhpcy5hcHBseVByZXNldChwcmVzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZXMgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgZWRnZXNUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldEVkZ2VzLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkZ2VzIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlc1RleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRFZGdlc1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXNUZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZSB3ZWlnaHRzIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHdlaWdodHNUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldFdlaWdodHMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZSB3ZWlnaHRzIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB3ZWlnaHRzVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFdlaWdodHNUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLndlaWdodHNUZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZSBkZXRlY3Rpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtFZGdlRGV0ZWN0aW9uTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgZWRnZURldGVjdGlvbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VEZXRlY3Rpb25QYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2UgZGV0ZWN0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7RWRnZURldGVjdGlvbk1hdGVyaWFsfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvbk1hdGVyaWFsIGluc3RlYWQuXG4gICAqL1xuICBnZXQgY29sb3JFZGdlc01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZSBkZXRlY3Rpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RWRnZURldGVjdGlvbk1hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRFZGdlRGV0ZWN0aW9uTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZSB3ZWlnaHRzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7U01BQVdlaWdodHNNYXRlcmlhbH1cbiAgICovXG4gIGdldCB3ZWlnaHRzTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0c1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIHdlaWdodHMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB3ZWlnaHRzTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7U01BQVdlaWdodHNNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0V2VpZ2h0c01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLndlaWdodHNNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRnZSBkZXRlY3Rpb24gc2Vuc2l0aXZpdHkuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgRWRnZURldGVjdGlvbk1hdGVyaWFsI3NldEVkZ2VEZXRlY3Rpb25UaHJlc2hvbGR9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZCAtIFRoZSBlZGdlIGRldGVjdGlvbiBzZW5zaXRpdml0eS4gUmFuZ2U6IFswLjA1LCAwLjVdLlxuICAgKi9cbiAgc2V0RWRnZURldGVjdGlvblRocmVzaG9sZCh0aHJlc2hvbGQpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBob3Jpem9udGFsL3ZlcnRpY2FsIHNlYXJjaCBzdGVwcy5cbiAgICpcbiAgICogU2VlIHtAbGluayBTTUFBV2VpZ2h0c01hdGVyaWFsI3NldE9ydGhvZ29uYWxTZWFyY2hTdGVwc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodHNNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcHMgLSBUaGUgc2VhcmNoIHN0ZXBzLiBSYW5nZTogWzAsIDExMl0uXG4gICAqL1xuICBzZXRPcnRob2dvbmFsU2VhcmNoU3RlcHMoc3RlcHMpIHtcbiAgICB0aGlzLndlaWdodHNNYXRlcmlhbC5vcnRob2dvbmFsU2VhcmNoU3RlcHMgPSBzdGVwcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gcXVhbGl0eSBwcmVzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U01BQVByZXNldH0gcHJlc2V0IC0gVGhlIHByZXNldC5cbiAgICovXG4gIGFwcGx5UHJlc2V0KHByZXNldCkge1xuICAgIGNvbnN0IGVkZ2VEZXRlY3Rpb25NYXRlcmlhbCA9IHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsO1xuICAgIGNvbnN0IHdlaWdodHNNYXRlcmlhbCA9IHRoaXMud2VpZ2h0c01hdGVyaWFsO1xuICAgIHN3aXRjaCAocHJlc2V0KSB7XG4gICAgICBjYXNlIFNNQUFQcmVzZXQuTE9XOlxuICAgICAgICBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZWRnZURldGVjdGlvblRocmVzaG9sZCA9IDAuMTU7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5vcnRob2dvbmFsU2VhcmNoU3RlcHMgPSA0O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxEZXRlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lckRldGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU01BQVByZXNldC5NRURJVU06XG4gICAgICAgIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gMC4xO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwub3J0aG9nb25hbFNlYXJjaFN0ZXBzID0gODtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmRpYWdvbmFsRGV0ZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5jb3JuZXJEZXRlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNNQUFQcmVzZXQuSElHSDpcbiAgICAgICAgZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSAwLjE7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5vcnRob2dvbmFsU2VhcmNoU3RlcHMgPSAxNjtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmRpYWdvbmFsU2VhcmNoU3RlcHMgPSA4O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyUm91bmRpbmcgPSAyNTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmRpYWdvbmFsRGV0ZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lckRldGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTTUFBUHJlc2V0LlVMVFJBOlxuICAgICAgICBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZWRnZURldGVjdGlvblRocmVzaG9sZCA9IDAuMDU7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5vcnRob2dvbmFsU2VhcmNoU3RlcHMgPSAzMjtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmRpYWdvbmFsU2VhcmNoU3RlcHMgPSAxNjtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lclJvdW5kaW5nID0gMjU7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5kaWFnb25hbERldGVjdGlvbiA9IHRydWU7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5jb3JuZXJEZXRlY3Rpb24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzE3KSB7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMpO1xuICAgIHRoaXMuZWRnZURldGVjdGlvblBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcyk7XG4gICAgdGhpcy53ZWlnaHRzUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMsIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMud2VpZ2h0c01hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGludGVybmFsIHJlbmRlciB0YXJnZXRzIGFuZCB0ZXh0dXJlcy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3QgeyBzZWFyY2hUZXh0dXJlLCBhcmVhVGV4dHVyZSB9ID0gdGhpcy53ZWlnaHRzTWF0ZXJpYWw7XG4gICAgaWYgKHNlYXJjaFRleHR1cmUgIT09IG51bGwgJiYgYXJlYVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHNlYXJjaFRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgYXJlYVRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBTTUFBIHNlYXJjaCBpbWFnZSwgZW5jb2RlZCBhcyBhIGJhc2U2NCBkYXRhIFVSTC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHN0YXRpYyBnZXQgc2VhcmNoSW1hZ2VEYXRhVVJMKCkge1xuICAgIHJldHVybiBzZWFyY2hJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgfVxuICAvKipcbiAgICogVGhlIFNNQUEgYXJlYSBpbWFnZSwgZW5jb2RlZCBhcyBhIGJhc2U2NCBkYXRhIFVSTC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHN0YXRpYyBnZXQgYXJlYUltYWdlRGF0YVVSTCgpIHtcbiAgICByZXR1cm4gYXJlYUltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9TU0FPRWZmZWN0LmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE4LCBDb2xvciBhcyBDb2xvcjksIFJlcGVhdFdyYXBwaW5nIGFzIFJlcGVhdFdyYXBwaW5nMywgUkdCQUZvcm1hdCBhcyBSR0JBRm9ybWF0NCwgVW5pZm9ybSBhcyBVbmlmb3JtNDYsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MjEgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zc2FvLmZyYWdcbnZhciBzc2FvX2RlZmF1bHQzID0gXCJ1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGFvQnVmZmVyO3VuaWZvcm0gZmxvYXQgbHVtaW5hbmNlSW5mbHVlbmNlO3VuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xcbiNpZiBUSFJFRV9SRVZJU0lPTiA8IDE0M1xcbiNkZWZpbmUgbHVtaW5hbmNlKHYpIGxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UodilcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZChERVBUSF9BV0FSRV9VUFNBTVBMSU5HKSAmJiBkZWZpbmVkKE5PUk1BTF9ERVBUSClcXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbm9ybWFsRGVwdGhCdWZmZXI7XFxuI2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIENPTE9SSVpFXFxudW5pZm9ybSB2ZWMzIGNvbG9yO1xcbiNlbmRpZlxcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXtmbG9hdCBhb0xpbmVhcj10ZXh0dXJlMkQoYW9CdWZmZXIsdXYpLnI7XFxuI2lmIGRlZmluZWQoREVQVEhfQVdBUkVfVVBTQU1QTElORykgJiYgZGVmaW5lZChOT1JNQUxfREVQVEgpICYmIF9fVkVSU0lPTl9fID09IDMwMFxcbnZlYzQgbm9ybWFsRGVwdGhbNF07bm9ybWFsRGVwdGhbMF09dGV4dHVyZU9mZnNldChub3JtYWxEZXB0aEJ1ZmZlcix1dixpdmVjMigwLDApKTtub3JtYWxEZXB0aFsxXT10ZXh0dXJlT2Zmc2V0KG5vcm1hbERlcHRoQnVmZmVyLHV2LGl2ZWMyKDAsMSkpO25vcm1hbERlcHRoWzJdPXRleHR1cmVPZmZzZXQobm9ybWFsRGVwdGhCdWZmZXIsdXYsaXZlYzIoMSwwKSk7bm9ybWFsRGVwdGhbM109dGV4dHVyZU9mZnNldChub3JtYWxEZXB0aEJ1ZmZlcix1dixpdmVjMigxLDEpKTtmbG9hdCBkb3QwMT1kb3Qobm9ybWFsRGVwdGhbMF0ucmdiLG5vcm1hbERlcHRoWzFdLnJnYik7ZmxvYXQgZG90MDI9ZG90KG5vcm1hbERlcHRoWzBdLnJnYixub3JtYWxEZXB0aFsyXS5yZ2IpO2Zsb2F0IGRvdDAzPWRvdChub3JtYWxEZXB0aFswXS5yZ2Isbm9ybWFsRGVwdGhbM10ucmdiKTtmbG9hdCBtaW5Eb3Q9bWluKGRvdDAxLG1pbihkb3QwMixkb3QwMykpO2Zsb2F0IHM9c3RlcChUSFJFU0hPTEQsbWluRG90KTtmbG9hdCBzbWFsbGVzdERpc3RhbmNlPTEuMDtpbnQgaW5kZXg7Zm9yKGludCBpPTA7aTw0OysraSl7ZmxvYXQgZGlzdGFuY2U9YWJzKGRlcHRoLW5vcm1hbERlcHRoW2ldLmEpO2lmKGRpc3RhbmNlPHNtYWxsZXN0RGlzdGFuY2Upe3NtYWxsZXN0RGlzdGFuY2U9ZGlzdGFuY2U7aW5kZXg9aTt9fWl2ZWMyIG9mZnNldHNbNF07b2Zmc2V0c1swXT1pdmVjMigwLDApO29mZnNldHNbMV09aXZlYzIoMCwxKTtvZmZzZXRzWzJdPWl2ZWMyKDEsMCk7b2Zmc2V0c1szXT1pdmVjMigxLDEpO2l2ZWMyIGNvb3JkPWl2ZWMyKHV2KnZlYzIodGV4dHVyZVNpemUoYW9CdWZmZXIsMCkpKStvZmZzZXRzW2luZGV4XTtmbG9hdCBhb05lYXJlc3Q9dGV4ZWxGZXRjaChhb0J1ZmZlcixjb29yZCwwKS5yO2Zsb2F0IGFvPW1peChhb05lYXJlc3QsYW9MaW5lYXIscyk7XFxuI2Vsc2VcXG5mbG9hdCBhbz1hb0xpbmVhcjtcXG4jZW5kaWZcXG5mbG9hdCBsPWx1bWluYW5jZShpbnB1dENvbG9yLnJnYik7YW89bWl4KGFvLDAuMCxsKmx1bWluYW5jZUluZmx1ZW5jZSk7YW89Y2xhbXAoYW8qaW50ZW5zaXR5LDAuMCwxLjApO1xcbiNpZmRlZiBDT0xPUklaRVxcbm91dHB1dENvbG9yPXZlYzQoMS4wLWFvKigxLjAtY29sb3IpLGlucHV0Q29sb3IuYSk7XFxuI2Vsc2VcXG5vdXRwdXRDb2xvcj12ZWM0KHZlYzMoMS4wLWFvKSxpbnB1dENvbG9yLmEpO1xcbiNlbmRpZlxcbn1cIjtcblxuLy8gc3JjL2VmZmVjdHMvU1NBT0VmZmVjdC5qc1xudmFyIE5PSVNFX1RFWFRVUkVfU0laRSA9IDY0O1xudmFyIFNTQU9FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNTQU8gZWZmZWN0LlxuICAgKlxuICAgKiBAdG9kbyBNb3ZlIG5vcm1hbEJ1ZmZlciB0byBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gW2NhbWVyYV0gLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW25vcm1hbEJ1ZmZlcl0gLSBBIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgc2NlbmUgbm9ybWFscy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5NVUxUSVBMWV0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzdGFuY2VTY2FsaW5nPXRydWVdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZXB0aEF3YXJlVXBzYW1wbGluZz10cnVlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGVwdGgtYXdhcmUgdXBzYW1wbGluZy4gSGFzIG5vIGVmZmVjdCBpZiBXZWJHTCAyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMubm9ybWFsRGVwdGhCdWZmZXI9bnVsbF0gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2FtcGxlcz05XSAtIFRoZSBhbW91bnQgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuIFNob3VsZCBub3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgcmluZyBjb3VudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJpbmdzPTddIC0gVGhlIGFtb3VudCBvZiBzcGlyYWwgdHVybnMgaW4gdGhlIG9jY2x1c2lvbiBzYW1wbGluZyBwYXR0ZXJuLiBTaG91bGQgYmUgYSBwcmltZSBudW1iZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZERpc3RhbmNlVGhyZXNob2xkXSAtIFRoZSB3b3JsZCBkaXN0YW5jZSB0aHJlc2hvbGQgYXQgd2hpY2ggdGhlIG9jY2x1c2lvbiBlZmZlY3Qgc3RhcnRzIHRvIGZhZGUgb3V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGREaXN0YW5jZUZhbGxvZmZdIC0gVGhlIHdvcmxkIGRpc3RhbmNlIGZhbGxvZmYuIEluZmx1ZW5jZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIG9jY2x1c2lvbiBjdXRvZmYuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZFByb3hpbWl0eVRocmVzaG9sZF0gLSBUaGUgd29ybGQgcHJveGltaXR5IHRocmVzaG9sZCBhdCB3aGljaCB0aGUgb2NjbHVzaW9uIHN0YXJ0cyB0byBmYWRlIG91dC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndvcmxkUHJveGltaXR5RmFsbG9mZl0gLSBUaGUgd29ybGQgcHJveGltaXR5IGZhbGxvZmYuIEluZmx1ZW5jZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIHByb3hpbWl0eSBjdXRvZmYuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZVRocmVzaG9sZD0wLjk3XSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZUZhbGxvZmY9MC4wM10gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFuZ2VUaHJlc2hvbGQ9MC4wMDA1XSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYW5nZUZhbGxvZmY9MC4wMDFdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblJhZGl1c1NjYWxlPTAuMV0gLSBUaGUgbWluaW11bSByYWRpdXMgc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sdW1pbmFuY2VJbmZsdWVuY2U9MC43XSAtIERldGVybWluZXMgaG93IG11Y2ggdGhlIGx1bWluYW5jZSBvZiB0aGUgc2NlbmUgaW5mbHVlbmNlcyB0aGUgYW1iaWVudCBvY2NsdXNpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MC4xODI1XSAtIFRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLCBleHByZXNzZWQgYXMgYSBzY2FsZSByZWxhdGl2ZSB0byB0aGUgcmVzb2x1dGlvbi4gUmFuZ2UgWzFlLTYsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIFRoZSBpbnRlbnNpdHkgb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmlhcz0wLjAyNV0gLSBBbiBvY2NsdXNpb24gYmlhcy4gRWxpbWluYXRlcyBhcnRpZmFjdHMgY2F1c2VkIGJ5IGRlcHRoIGRpc2NvbnRpbnVpdGllcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhZGU9MC4wMV0gLSBJbmZsdWVuY2VzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBzaGFkb3dzLiBBIGxvd2VyIHZhbHVlIHJlc3VsdHMgaW4gaGlnaGVyIGNvbnRyYXN0LlxuICAgKiBAcGFyYW0ge0NvbG9yfSBbb3B0aW9ucy5jb2xvcj1udWxsXSAtIFRoZSBjb2xvciBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIG5vcm1hbEJ1ZmZlciwge1xuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLk1VTFRJUExZLFxuICAgIHNhbXBsZXMgPSA5LFxuICAgIHJpbmdzID0gNyxcbiAgICBub3JtYWxEZXB0aEJ1ZmZlciA9IG51bGwsXG4gICAgZGVwdGhBd2FyZVVwc2FtcGxpbmcgPSB0cnVlLFxuICAgIHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQsXG4gICAgd29ybGREaXN0YW5jZUZhbGxvZmYsXG4gICAgd29ybGRQcm94aW1pdHlUaHJlc2hvbGQsXG4gICAgd29ybGRQcm94aW1pdHlGYWxsb2ZmLFxuICAgIGRpc3RhbmNlVGhyZXNob2xkID0gMC45NyxcbiAgICBkaXN0YW5jZUZhbGxvZmYgPSAwLjAzLFxuICAgIHJhbmdlVGhyZXNob2xkID0gNWUtNCxcbiAgICByYW5nZUZhbGxvZmYgPSAxZS0zLFxuICAgIG1pblJhZGl1c1NjYWxlID0gMC4xLFxuICAgIGx1bWluYW5jZUluZmx1ZW5jZSA9IDAuNyxcbiAgICByYWRpdXMgPSAwLjE4MjUsXG4gICAgaW50ZW5zaXR5ID0gMSxcbiAgICBiaWFzID0gMC4wMjUsXG4gICAgZmFkZSA9IDAuMDEsXG4gICAgY29sb3I6IGNvbG9yMiA9IG51bGwsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJTU0FPRWZmZWN0XCIsIHNzYW9fZGVmYXVsdDMsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIlRIUkVTSE9MRFwiLCBcIjAuOTk3XCJdXG4gICAgICBdKSxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImFvQnVmZmVyXCIsIG5ldyBVbmlmb3JtNDYobnVsbCldLFxuICAgICAgICBbXCJub3JtYWxEZXB0aEJ1ZmZlclwiLCBuZXcgVW5pZm9ybTQ2KG5vcm1hbERlcHRoQnVmZmVyKV0sXG4gICAgICAgIFtcImx1bWluYW5jZUluZmx1ZW5jZVwiLCBuZXcgVW5pZm9ybTQ2KGx1bWluYW5jZUluZmx1ZW5jZSldLFxuICAgICAgICBbXCJjb2xvclwiLCBuZXcgVW5pZm9ybTQ2KG51bGwpXSxcbiAgICAgICAgW1wiaW50ZW5zaXR5XCIsIG5ldyBVbmlmb3JtNDYoaW50ZW5zaXR5KV0sXG4gICAgICAgIFtcInNjYWxlXCIsIG5ldyBVbmlmb3JtNDYoMCldXG4gICAgICAgIC8vIFVudXNlZC5cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQyMSgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkFPLlRhcmdldFwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW9CdWZmZXJcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzID0gbmV3IERlcHRoRG93bnNhbXBsaW5nUGFzcyh7IG5vcm1hbEJ1ZmZlciwgcmVzb2x1dGlvblNjYWxlIH0pO1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLmVuYWJsZWQgPSBub3JtYWxEZXB0aEJ1ZmZlciA9PT0gbnVsbDtcbiAgICB0aGlzLnNzYW9QYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IFNTQU9NYXRlcmlhbChjYW1lcmEpKTtcbiAgICBjb25zdCBub2lzZVRleHR1cmUgPSBuZXcgTm9pc2VUZXh0dXJlKE5PSVNFX1RFWFRVUkVfU0laRSwgTk9JU0VfVEVYVFVSRV9TSVpFLCBSR0JBRm9ybWF0NCk7XG4gICAgbm9pc2VUZXh0dXJlLndyYXBTID0gbm9pc2VUZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmczO1xuICAgIGNvbnN0IHNzYW9NYXRlcmlhbCA9IHRoaXMuc3Nhb01hdGVyaWFsO1xuICAgIHNzYW9NYXRlcmlhbC5ub3JtYWxCdWZmZXIgPSBub3JtYWxCdWZmZXI7XG4gICAgc3Nhb01hdGVyaWFsLm5vaXNlVGV4dHVyZSA9IG5vaXNlVGV4dHVyZTtcbiAgICBzc2FvTWF0ZXJpYWwubWluUmFkaXVzU2NhbGUgPSBtaW5SYWRpdXNTY2FsZTtcbiAgICBzc2FvTWF0ZXJpYWwuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgc3Nhb01hdGVyaWFsLnJhZGl1cyA9IHJhZGl1cztcbiAgICBzc2FvTWF0ZXJpYWwucmluZ3MgPSByaW5ncztcbiAgICBzc2FvTWF0ZXJpYWwuZmFkZSA9IGZhZGU7XG4gICAgc3Nhb01hdGVyaWFsLmJpYXMgPSBiaWFzO1xuICAgIHNzYW9NYXRlcmlhbC5kaXN0YW5jZVRocmVzaG9sZCA9IGRpc3RhbmNlVGhyZXNob2xkO1xuICAgIHNzYW9NYXRlcmlhbC5kaXN0YW5jZUZhbGxvZmYgPSBkaXN0YW5jZUZhbGxvZmY7XG4gICAgc3Nhb01hdGVyaWFsLnByb3hpbWl0eVRocmVzaG9sZCA9IHJhbmdlVGhyZXNob2xkO1xuICAgIHNzYW9NYXRlcmlhbC5wcm94aW1pdHlGYWxsb2ZmID0gcmFuZ2VGYWxsb2ZmO1xuICAgIGlmICh3b3JsZERpc3RhbmNlVGhyZXNob2xkICE9PSB2b2lkIDApIHtcbiAgICAgIHNzYW9NYXRlcmlhbC53b3JsZERpc3RhbmNlVGhyZXNob2xkID0gd29ybGREaXN0YW5jZVRocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKHdvcmxkRGlzdGFuY2VGYWxsb2ZmICE9PSB2b2lkIDApIHtcbiAgICAgIHNzYW9NYXRlcmlhbC53b3JsZERpc3RhbmNlRmFsbG9mZiA9IHdvcmxkRGlzdGFuY2VGYWxsb2ZmO1xuICAgIH1cbiAgICBpZiAod29ybGRQcm94aW1pdHlUaHJlc2hvbGQgIT09IHZvaWQgMCkge1xuICAgICAgc3Nhb01hdGVyaWFsLndvcmxkUHJveGltaXR5VGhyZXNob2xkID0gd29ybGRQcm94aW1pdHlUaHJlc2hvbGQ7XG4gICAgfVxuICAgIGlmICh3b3JsZFByb3hpbWl0eUZhbGxvZmYgIT09IHZvaWQgMCkge1xuICAgICAgc3Nhb01hdGVyaWFsLndvcmxkUHJveGltaXR5RmFsbG9mZiA9IHdvcmxkUHJveGltaXR5RmFsbG9mZjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbERlcHRoQnVmZmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNzYW9NYXRlcmlhbC5ub3JtYWxEZXB0aEJ1ZmZlciA9IG5vcm1hbERlcHRoQnVmZmVyO1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIk5PUk1BTF9ERVBUSFwiLCBcIjFcIik7XG4gICAgfVxuICAgIHRoaXMuZGVwdGhBd2FyZVVwc2FtcGxpbmcgPSBkZXB0aEF3YXJlVXBzYW1wbGluZztcbiAgICB0aGlzLmNvbG9yID0gY29sb3IyO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBub3JtYWxCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Nhb01hdGVyaWFsLm5vcm1hbEJ1ZmZlcjtcbiAgfVxuICBzZXQgbm9ybWFsQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwubm9ybWFsQnVmZmVyID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLm5vcm1hbEJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIFNTQU8gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtTU0FPTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgc3Nhb01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9QYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgU1NBTyBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTU0FPTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldFNTQU9NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygb2NjbHVzaW9uIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3Nhb01hdGVyaWFsLnNhbXBsZXMgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzYW1wbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9NYXRlcmlhbC5zYW1wbGVzO1xuICB9XG4gIHNldCBzYW1wbGVzKHZhbHVlKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuc2FtcGxlcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIHNwaXJhbCB0dXJucyBpbiB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHBhdHRlcm4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwucmluZ3MgaW5zdGVhZC5cbiAgICovXG4gIGdldCByaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvTWF0ZXJpYWwucmluZ3M7XG4gIH1cbiAgc2V0IHJpbmdzKHZhbHVlKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwucmluZ3MgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBzYW1wbGluZyByYWRpdXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwucmFkaXVzIGluc3RlYWQuXG4gICAqL1xuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9NYXRlcmlhbC5yYWRpdXM7XG4gIH1cbiAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGRlcHRoQXdhcmVVcHNhbXBsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiREVQVEhfQVdBUkVfVVBTQU1QTElOR1wiKTtcbiAgfVxuICBzZXQgZGVwdGhBd2FyZVVwc2FtcGxpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZXB0aEF3YXJlVXBzYW1wbGluZyAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiREVQVEhfQVdBUkVfVVBTQU1QTElOR1wiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiREVQVEhfQVdBUkVfVVBTQU1QTElOR1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGVwdGgtYXdhcmUgdXBzYW1wbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhBd2FyZVVwc2FtcGxpbmcgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc0RlcHRoQXdhcmVVcHNhbXBsaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aEF3YXJlVXBzYW1wbGluZztcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhBd2FyZVVwc2FtcGxpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgZGVwdGgtYXdhcmUgdXBzYW1wbGluZyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldERlcHRoQXdhcmVVcHNhbXBsaW5nRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZGVwdGhBd2FyZVVwc2FtcGxpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGlzdGFuY2VTY2FsaW5nKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldCBkaXN0YW5jZVNjYWxpbmcodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbi4gU2V0IHRvIGBudWxsYCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiY29sb3JcIikudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IGRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoZGVmaW5lcy5oYXMoXCJDT0xPUklaRVwiKSkge1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJjb2xvclwiKS52YWx1ZS5zZXQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lcy5zZXQoXCJDT0xPUklaRVwiLCBcIjFcIik7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlID0gbmV3IENvbG9yOSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVmaW5lcy5oYXMoXCJDT0xPUklaRVwiKSkge1xuICAgICAgZGVmaW5lcy5kZWxldGUoXCJDT0xPUklaRVwiKTtcbiAgICAgIHVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlID0gbnVsbDtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBpbmZsdWVuY2UgZmFjdG9yLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbHVtaW5hbmNlSW5mbHVlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImx1bWluYW5jZUluZmx1ZW5jZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbHVtaW5hbmNlSW5mbHVlbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJsdW1pbmFuY2VJbmZsdWVuY2VcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGludGVuc2l0eS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBpbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiaW50ZW5zaXR5XCIpLnZhbHVlO1xuICB9XG4gIHNldCBpbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImludGVuc2l0eVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2xvciBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvciBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtDb2xvcn0gVGhlIGNvbG9yLlxuICAgKi9cbiAgZ2V0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbi4gU2V0IHRvIGBudWxsYCB0byBkaXNhYmxlIGNvbG9yaXphdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbG9yIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q29sb3J9IHZhbHVlIC0gVGhlIGNvbG9yLlxuICAgKi9cbiAgc2V0Q29sb3IodmFsdWUpIHtcbiAgICB0aGlzLmNvbG9yID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBjdXRvZmYuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZCAtIFRoZSBkaXN0YW5jZSB0aHJlc2hvbGQuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmYWxsb2ZmIC0gVGhlIGZhbGxvZmYuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqL1xuICBzZXREaXN0YW5jZUN1dG9mZih0aHJlc2hvbGQsIGZhbGxvZmYpIHtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5kaXN0YW5jZVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5kaXN0YW5jZUZhbGxvZmYgPSBmYWxsb2ZmO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gcHJveGltaXR5IGN1dG9mZi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIHByb3hpbWl0eSB0aHJlc2hvbGQuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmYWxsb2ZmIC0gVGhlIGZhbGxvZmYuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqL1xuICBzZXRQcm94aW1pdHlDdXRvZmYodGhyZXNob2xkLCBmYWxsb2ZmKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwucHJveGltaXR5VGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnByb3hpbWl0eUZhbGxvZmYgPSBmYWxsb2ZmO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxOCkge1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLnNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyk7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICBpZiAodGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MuZW5hYmxlZCkge1xuICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgdGhpcy5zc2FvUGFzcy5yZW5kZXIocmVuZGVyZXIsIG51bGwsIHJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModGhpcy5jYW1lcmEpO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5yZXNvbHV0aW9uLnNjYWxlID0gcmVzb2x1dGlvbi5zY2FsZTtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG5vcm1hbERlcHRoQnVmZmVyID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJub3JtYWxEZXB0aEJ1ZmZlclwiKS52YWx1ZTtcbiAgICAgIGlmIChub3JtYWxEZXB0aEJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICAgICAgbm9ybWFsRGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy50ZXh0dXJlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmdldChcIm5vcm1hbERlcHRoQnVmZmVyXCIpLnZhbHVlID0gbm9ybWFsRGVwdGhCdWZmZXI7XG4gICAgICAgIHRoaXMuc3Nhb01hdGVyaWFsLm5vcm1hbERlcHRoQnVmZmVyID0gbm9ybWFsRGVwdGhCdWZmZXI7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJOT1JNQUxfREVQVEhcIiwgXCIxXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1RleHR1cmVFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTQ3LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3RleHR1cmUuZnJhZ1xudmFyIHRleHR1cmVfZGVmYXVsdCA9IFwiI2lmZGVmIFRFWFRVUkVfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG1hcDtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMiB2VXYyO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtcXG4jaWZkZWYgVVZfVFJBTlNGT1JNXFxudmVjNCB0ZXhlbD10ZXh0dXJlMkQobWFwLHZVdjIpO1xcbiNlbHNlXFxudmVjNCB0ZXhlbD10ZXh0dXJlMkQobWFwLHV2KTtcXG4jZW5kaWZcXG5vdXRwdXRDb2xvcj1URVhFTDt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdGV4dHVyZS52ZXJ0XG52YXIgdGV4dHVyZV9kZWZhdWx0MiA9IFwiI2lmZGVmIEFTUEVDVF9DT1JSRUNUSU9OXFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcXG4jZWxzZVxcbnVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXG4jZW5kaWZcXG52YXJ5aW5nIHZlYzIgdlV2Mjt2b2lkIG1haW5TdXBwb3J0KGNvbnN0IGluIHZlYzIgdXYpe1xcbiNpZmRlZiBBU1BFQ1RfQ09SUkVDVElPTlxcbnZVdjI9dXYqdmVjMihhc3BlY3QsMS4wKSpzY2FsZTtcXG4jZWxzZVxcbnZVdjI9KHV2VHJhbnNmb3JtKnZlYzModXYsMS4wKSkueHk7XFxuI2VuZGlmXFxufVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9UZXh0dXJlRWZmZWN0LmpzXG52YXIgVGV4dHVyZUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdGV4dHVyZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbb3B0aW9ucy50ZXh0dXJlXSAtIEEgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3BlY3RDb3JyZWN0aW9uPWZhbHNlXSAtIERlcHJlY2F0ZWQuIEFkanVzdCB0aGUgdGV4dHVyZSdzIG9mZnNldCwgcmVwZWF0IGFuZCBjZW50ZXIgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgdGV4dHVyZSA9IG51bGwsIGFzcGVjdENvcnJlY3Rpb24gPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcihcIlRleHR1cmVFZmZlY3RcIiwgdGV4dHVyZV9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgZGVmaW5lczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJURVhFTFwiLCBcInRleGVsXCJdXG4gICAgICBdKSxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTQ3KG51bGwpXSxcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm00NygxKV0sXG4gICAgICAgIFtcInV2VHJhbnNmb3JtXCIsIG5ldyBVbmlmb3JtNDcobnVsbCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5hc3BlY3RDb3JyZWN0aW9uID0gYXNwZWN0Q29ycmVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgY29uc3QgcHJldlRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IGRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG4gICAgaWYgKHByZXZUZXh0dXJlICE9PSB2YWx1ZSkge1xuICAgICAgdW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gdmFsdWU7XG4gICAgICB1bmlmb3Jtcy5nZXQoXCJ1dlRyYW5zZm9ybVwiKS52YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgICAgIGRlZmluZXMuZGVsZXRlKFwiVEVYVFVSRV9QUkVDSVNJT05fSElHSFwiKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsdWUubWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICAgIGRlZmluZXMuc2V0KFwiVVZfVFJBTlNGT1JNXCIsIFwiMVwiKTtcbiAgICAgICAgICB0aGlzLnNldFZlcnRleFNoYWRlcih0ZXh0dXJlX2RlZmF1bHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZpbmVzLmRlbGV0ZShcIlVWX1RSQU5TRk9STVwiKTtcbiAgICAgICAgICB0aGlzLnNldFZlcnRleFNoYWRlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTE2KSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJURVhUVVJFX1BSRUNJU0lPTl9ISUdIXCIsIFwiMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlRleHR1cmUgPT09IG51bGwgfHwgcHJldlRleHR1cmUudHlwZSAhPT0gdmFsdWUudHlwZSB8fCBwcmV2VGV4dHVyZS5lbmNvZGluZyAhPT0gdmFsdWUuZW5jb2RpbmcpIHtcbiAgICAgICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIHNldFRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnRleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgYXNwZWN0IGNvcnJlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgQWRqdXN0IHRoZSB0ZXh0dXJlJ3Mgb2Zmc2V0LCByZXBlYXQsIHJvdGF0aW9uIGFuZCBjZW50ZXIgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhc3BlY3RDb3JyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiQVNQRUNUX0NPUlJFQ1RJT05cIik7XG4gIH1cbiAgc2V0IGFzcGVjdENvcnJlY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5hc3BlY3RDb3JyZWN0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJBU1BFQ1RfQ09SUkVDVElPTlwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiQVNQRUNUX0NPUlJFQ1RJT05cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIFVWIGNvb3JkaW5hdGVzIHdpbGwgYmUgdHJhbnNmb3JtZWQgdXNpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCB1dlRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIHJldHVybiB0ZXh0dXJlICE9PSBudWxsICYmIHRleHR1cmUubWF0cml4QXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgdXZUcmFuc2Zvcm0odmFsdWUpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIGlmICh0ZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB0ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN3aXp6bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnRzIG9mIGEgdGV4ZWwgYmVmb3JlIGl0IGlzIHdyaXR0ZW4gdG8gdGhlIG91dHB1dCBjb2xvci5cbiAgICpcbiAgICogQHBhcmFtIHtDb2xvckNoYW5uZWx9IHIgLSBUaGUgc3dpenpsZSBmb3IgdGhlIGByYCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7Q29sb3JDaGFubmVsfSBbZz1yXSAtIFRoZSBzd2l6emxlIGZvciB0aGUgYGdgIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtDb2xvckNoYW5uZWx9IFtiPXJdIC0gVGhlIHN3aXp6bGUgZm9yIHRoZSBgYmAgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0NvbG9yQ2hhbm5lbH0gW2E9cl0gLSBUaGUgc3dpenpsZSBmb3IgdGhlIGBhYCBjb21wb25lbnQuXG4gICAqL1xuICBzZXRUZXh0dXJlU3dpenpsZVJHQkEociwgZyA9IHIsIGIgPSByLCBhID0gcikge1xuICAgIGNvbnN0IHJnYmEgPSBcInJnYmFcIjtcbiAgICBsZXQgc3dpenpsZSA9IFwiXCI7XG4gICAgaWYgKHIgIT09IENvbG9yQ2hhbm5lbC5SRUQgfHwgZyAhPT0gQ29sb3JDaGFubmVsLkdSRUVOIHx8IGIgIT09IENvbG9yQ2hhbm5lbC5CTFVFIHx8IGEgIT09IENvbG9yQ2hhbm5lbC5BTFBIQSkge1xuICAgICAgc3dpenpsZSA9IFtcIi5cIiwgcmdiYVtyXSwgcmdiYVtnXSwgcmdiYVtiXSwgcmdiYVthXV0uam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlRFWEVMXCIsIFwidGV4ZWxcIiArIHN3aXp6bGUpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMudGV4dHVyZS51cGRhdGVNYXRyaXgoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1RpbHRTaGlmdEVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtNDgsIFZlY3RvcjIgYXMgVmVjdG9yMjI3LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDIyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdGlsdC1zaGlmdC5mcmFnXG52YXIgdGlsdF9zaGlmdF9kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG1hcDtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMiBtYXNrUGFyYW1zO3ZhcnlpbmcgdmVjMiB2VXYyO2Zsb2F0IGxpbmVhckdyYWRpZW50TWFzayhjb25zdCBpbiBmbG9hdCB4KXtyZXR1cm4gc3RlcChtYXNrUGFyYW1zLngseCktc3RlcChtYXNrUGFyYW1zLnkseCk7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtmbG9hdCBtYXNrPWxpbmVhckdyYWRpZW50TWFzayh2VXYyLnkpO3ZlYzQgdGV4ZWw9dGV4dHVyZTJEKG1hcCx1dik7b3V0cHV0Q29sb3I9bWl4KHRleGVsLGlucHV0Q29sb3IsbWFzayk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3RpbHQtc2hpZnQudmVydFxudmFyIHRpbHRfc2hpZnRfZGVmYXVsdDIgPSBcInVuaWZvcm0gdmVjMiByb3RhdGlvbjt2YXJ5aW5nIHZlYzIgdlV2Mjt2b2lkIG1haW5TdXBwb3J0KGNvbnN0IGluIHZlYzIgdXYpe3ZVdjI9KHV2LTAuNSkqMi4wKnZlYzIoYXNwZWN0LDEuMCk7dlV2Mj12ZWMyKGRvdChyb3RhdGlvbix2VXYyKSxkb3Qocm90YXRpb24sdmVjMih2VXYyLnksLXZVdjIueCkpKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL1RpbHRTaGlmdEVmZmVjdC5qc1xudmFyIFRpbHRTaGlmdEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdGlsdCBzaGlmdCBFZmZlY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTAuMF0gLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MC4wXSAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZm9jdXMgYXJlYSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNBcmVhPTAuNF0gLSBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZlYXRoZXI9MC4zXSAtIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpYXM9MC4wNl0gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5NRURJVU1dIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgb2Zmc2V0ID0gMCxcbiAgICByb3RhdGlvbiA9IDAsXG4gICAgZm9jdXNBcmVhID0gMC40LFxuICAgIGZlYXRoZXIgPSAwLjMsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTUVESVVNLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDAuNSxcbiAgICByZXNvbHV0aW9uWCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25ZID0gUmVzb2x1dGlvbi5BVVRPX1NJWkVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJUaWx0U2hpZnRFZmZlY3RcIiwgdGlsdF9zaGlmdF9kZWZhdWx0LCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHRpbHRfc2hpZnRfZGVmYXVsdDIsXG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wicm90YXRpb25cIiwgbmV3IFVuaWZvcm00OChuZXcgVmVjdG9yMjI3KCkpXSxcbiAgICAgICAgW1wibWFza1BhcmFtc1wiLCBuZXcgVW5pZm9ybTQ4KG5ldyBWZWN0b3IyMjcoKSldLFxuICAgICAgICBbXCJtYXBcIiwgbmV3IFVuaWZvcm00OChudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuX2ZvY3VzQXJlYSA9IGZvY3VzQXJlYTtcbiAgICB0aGlzLl9mZWF0aGVyID0gZmVhdGhlcjtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIyKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiVGlsdFNoaWZ0LlRhcmdldFwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICB0aGlzLmJsdXJQYXNzID0gbmV3IFRpbHRTaGlmdEJsdXJQYXNzKHtcbiAgICAgIGtlcm5lbFNpemUsXG4gICAgICByZXNvbHV0aW9uU2NhbGUsXG4gICAgICByZXNvbHV0aW9uWCxcbiAgICAgIHJlc29sdXRpb25ZLFxuICAgICAgb2Zmc2V0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBmb2N1c0FyZWEsXG4gICAgICBmZWF0aGVyXG4gICAgfSk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG1hc2sgcGFyYW1zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUGFyYW1zKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMudW5pZm9ybXMuZ2V0KFwibWFza1BhcmFtc1wiKS52YWx1ZTtcbiAgICBjb25zdCB4ID0gTWF0aC5tYXgodGhpcy5mb2N1c0FyZWEgLSB0aGlzLmZlYXRoZXIsIDApO1xuICAgIHBhcmFtcy5zZXQodGhpcy5vZmZzZXQgLSB4LCB0aGlzLm9mZnNldCArIHgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKHRoaXMudW5pZm9ybXMuZ2V0KFwicm90YXRpb25cIikudmFsdWUueCk7XG4gIH1cbiAgc2V0IHJvdGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJyb3RhdGlvblwiKS52YWx1ZS5zZXQoTWF0aC5jb3ModmFsdWUpLCBNYXRoLnNpbih2YWx1ZSkpO1xuICAgIHRoaXMuYmx1clBhc3MuYmx1ck1hdGVyaWFsLnJvdGF0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH1cbiAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMuX29mZnNldCA9IHZhbHVlO1xuICAgIHRoaXMuYmx1clBhc3MuYmx1ck1hdGVyaWFsLm9mZnNldCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBzaXplIG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZvY3VzQXJlYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNBcmVhO1xuICB9XG4gIHNldCBmb2N1c0FyZWEodmFsdWUpIHtcbiAgICB0aGlzLl9mb2N1c0FyZWEgPSB2YWx1ZTtcbiAgICB0aGlzLmJsdXJQYXNzLmJsdXJNYXRlcmlhbC5mb2N1c0FyZWEgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc29mdG5lc3Mgb2YgdGhlIGZvY3VzIGFyZWEgZWRnZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZmVhdGhlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmVhdGhlcjtcbiAgfVxuICBzZXQgZmVhdGhlcih2YWx1ZSkge1xuICAgIHRoaXMuX2ZlYXRoZXIgPSB2YWx1ZTtcbiAgICB0aGlzLmJsdXJQYXNzLmJsdXJNYXRlcmlhbC5mZWF0aGVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogQSBibGVuZCBiaWFzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGJpYXMoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc2V0IGJpYXModmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCB0aGlzLnJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gICAgdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uLmNvcHkocmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAoZ2V0T3V0cHV0Q29sb3JTcGFjZShyZW5kZXJlcikgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1RvbmVNYXBwaW5nRWZmZWN0LmpzXG5pbXBvcnQgeyBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFVuaWZvcm0gYXMgVW5pZm9ybTQ5LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDIzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdG9uZS1tYXBwaW5nLmZyYWdcbnZhciB0b25lX21hcHBpbmdfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2lmIFRIUkVFX1JFVklTSU9OIDwgMTQzXFxuI2RlZmluZSBsdW1pbmFuY2UodikgbGluZWFyVG9SZWxhdGl2ZUx1bWluYW5jZSh2KVxcbiNlbmRpZlxcbnVuaWZvcm0gZmxvYXQgd2hpdGVQb2ludDtcXG4jaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gMSB8fCBUT05FX01BUFBJTkdfTU9ERSA9PSAyXFxudW5pZm9ybSBmbG9hdCBtaWRkbGVHcmV5O1xcbiNpZiBUT05FX01BUFBJTkdfTU9ERSA9PSAyXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBsdW1pbmFuY2VCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGZsb2F0IGF2ZXJhZ2VMdW1pbmFuY2U7XFxuI2VuZGlmXFxudmVjMyBSZWluaGFyZDJUb25lTWFwcGluZyh2ZWMzIGNvbG9yKXtjb2xvcio9dG9uZU1hcHBpbmdFeHBvc3VyZTtmbG9hdCBsPWx1bWluYW5jZShjb2xvcik7XFxuI2lmIFRPTkVfTUFQUElOR19NT0RFID09IDJcXG5mbG9hdCBsdW1Bdmc9dW5wYWNrUkdCQVRvRmxvYXQodGV4dHVyZTJEKGx1bWluYW5jZUJ1ZmZlcix2ZWMyKDAuNSkpKTtcXG4jZWxzZVxcbmZsb2F0IGx1bUF2Zz1hdmVyYWdlTHVtaW5hbmNlO1xcbiNlbmRpZlxcbmZsb2F0IGx1bVNjYWxlZD0obCptaWRkbGVHcmV5KS9tYXgobHVtQXZnLDFlLTYpO2Zsb2F0IGx1bUNvbXByZXNzZWQ9bHVtU2NhbGVkKigxLjArbHVtU2NhbGVkLyh3aGl0ZVBvaW50KndoaXRlUG9pbnQpKTtsdW1Db21wcmVzc2VkLz0oMS4wK2x1bVNjYWxlZCk7cmV0dXJuIGNsYW1wKGx1bUNvbXByZXNzZWQqY29sb3IsMC4wLDEuMCk7fVxcbiNlbGlmIFRPTkVfTUFQUElOR19NT0RFID09IDVcXG4jZGVmaW5lIEEgMC4xNVxcbiNkZWZpbmUgQiAwLjUwXFxuI2RlZmluZSBDIDAuMTBcXG4jZGVmaW5lIEQgMC4yMFxcbiNkZWZpbmUgRSAwLjAyXFxuI2RlZmluZSBGIDAuMzBcXG52ZWMzIFVuY2hhcnRlZDJIZWxwZXIoY29uc3QgaW4gdmVjMyB4KXtyZXR1cm4oKHgqKEEqeCtDKkIpK0QqRSkvKHgqKEEqeCtCKStEKkYpKS1FL0Y7fXZlYzMgVW5jaGFydGVkMlRvbmVNYXBwaW5nKHZlYzMgY29sb3Ipe2NvbG9yKj10b25lTWFwcGluZ0V4cG9zdXJlO3JldHVybiBjbGFtcChVbmNoYXJ0ZWQySGVscGVyKGNvbG9yKS9VbmNoYXJ0ZWQySGVscGVyKHZlYzMod2hpdGVQb2ludCkpLDAuMCwxLjApO31cXG4jZW5kaWZcXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7XFxuI2lmIFRPTkVfTUFQUElOR19NT0RFID09IDEgfHwgVE9ORV9NQVBQSU5HX01PREUgPT0gMlxcbm91dHB1dENvbG9yPXZlYzQoUmVpbmhhcmQyVG9uZU1hcHBpbmcoaW5wdXRDb2xvci5yZ2IpLGlucHV0Q29sb3IuYSk7XFxuI2VsaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gNVxcbm91dHB1dENvbG9yPXZlYzQoVW5jaGFydGVkMlRvbmVNYXBwaW5nKGlucHV0Q29sb3IucmdiKSxpbnB1dENvbG9yLmEpO1xcbiNlbHNlXFxub3V0cHV0Q29sb3I9dmVjNCh0b25lTWFwcGluZyhpbnB1dENvbG9yLnJnYiksaW5wdXRDb2xvci5hKTtcXG4jZW5kaWZcXG59XCI7XG5cbi8vIHNyYy9lZmZlY3RzL1RvbmVNYXBwaW5nRWZmZWN0LmpzXG52YXIgVG9uZU1hcHBpbmdFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHRvbmUgbWFwcGluZyBlZmZlY3QuXG4gICAqXG4gICAqIFRoZSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgb25seSBhZmZlY3QgdGhlIFJlaW5oYXJkMiBvcGVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFkYXB0aXZlPWZhbHNlXSAtIERlcHJlY2F0ZWQuIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VG9uZU1hcHBpbmdNb2RlfSBbb3B0aW9ucy5tb2RlPVRvbmVNYXBwaW5nTW9kZS5BQ0VTX0ZJTE1JQ10gLSBUaGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTI1Nl0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgbHVtaW5hbmNlIHRleHR1cmUuIE11c3QgYmUgYSBwb3dlciBvZiB0d28uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhMdW1pbmFuY2U9NC4wXSAtIERlcHJlY2F0ZWQuIFNhbWUgYXMgd2hpdGVQb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndoaXRlUG9pbnQ9NC4wXSAtIFRoZSB3aGl0ZSBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pZGRsZUdyZXk9MC42XSAtIFRoZSBtaWRkbGUgZ3JleSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5MdW1pbmFuY2U9MC4wMV0gLSBUaGUgbWluaW11bSBsdW1pbmFuY2UuIFByZXZlbnRzIHZlcnkgaGlnaCBleHBvc3VyZSBpbiBkYXJrIHNjZW5lcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF2ZXJhZ2VMdW1pbmFuY2U9MS4wXSAtIFRoZSBhdmVyYWdlIGx1bWluYW5jZS4gVXNlZCBmb3IgdGhlIG5vbi1hZGFwdGl2ZSBSZWluaGFyZCBvcGVyYXRvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFkYXB0YXRpb25SYXRlPTEuMF0gLSBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsXG4gICAgYWRhcHRpdmUgPSBmYWxzZSxcbiAgICBtb2RlID0gYWRhcHRpdmUgPyBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyX0FEQVBUSVZFIDogVG9uZU1hcHBpbmdNb2RlLkFDRVNfRklMTUlDLFxuICAgIHJlc29sdXRpb24gPSAyNTYsXG4gICAgbWF4THVtaW5hbmNlID0gNCxcbiAgICB3aGl0ZVBvaW50ID0gbWF4THVtaW5hbmNlLFxuICAgIG1pZGRsZUdyZXkgPSAwLjYsXG4gICAgbWluTHVtaW5hbmNlID0gMC4wMSxcbiAgICBhdmVyYWdlTHVtaW5hbmNlID0gMSxcbiAgICBhZGFwdGF0aW9uUmF0ZSA9IDFcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJUb25lTWFwcGluZ0VmZmVjdFwiLCB0b25lX21hcHBpbmdfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImx1bWluYW5jZUJ1ZmZlclwiLCBuZXcgVW5pZm9ybTQ5KG51bGwpXSxcbiAgICAgICAgW1wibWF4THVtaW5hbmNlXCIsIG5ldyBVbmlmb3JtNDkobWF4THVtaW5hbmNlKV0sXG4gICAgICAgIC8vIFVudXNlZFxuICAgICAgICBbXCJ3aGl0ZVBvaW50XCIsIG5ldyBVbmlmb3JtNDkod2hpdGVQb2ludCldLFxuICAgICAgICBbXCJtaWRkbGVHcmV5XCIsIG5ldyBVbmlmb3JtNDkobWlkZGxlR3JleSldLFxuICAgICAgICBbXCJhdmVyYWdlTHVtaW5hbmNlXCIsIG5ldyBVbmlmb3JtNDkoYXZlcmFnZUx1bWluYW5jZSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0THVtaW5hbmNlID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MjMoMSwgMSwge1xuICAgICAgbWluRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEx1bWluYW5jZS50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMdW1pbmFuY2UudGV4dHVyZS5uYW1lID0gXCJMdW1pbmFuY2VcIjtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3MgPSBuZXcgTHVtaW5hbmNlUGFzcyh7XG4gICAgICByZW5kZXJUYXJnZXQ6IHRoaXMucmVuZGVyVGFyZ2V0THVtaW5hbmNlXG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MgPSBuZXcgQWRhcHRpdmVMdW1pbmFuY2VQYXNzKHRoaXMubHVtaW5hbmNlUGFzcy50ZXh0dXJlLCB7XG4gICAgICBtaW5MdW1pbmFuY2UsXG4gICAgICBhZGFwdGF0aW9uUmF0ZVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibHVtaW5hbmNlQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MudGV4dHVyZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICpcbiAgICogQHR5cGUge1RvbmVNYXBwaW5nTW9kZX1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLmdldChcIlRPTkVfTUFQUElOR19NT0RFXCIpKTtcbiAgfVxuICBzZXQgbW9kZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1vZGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJUT05FX01BUFBJTkdfTU9ERVwiLCB2YWx1ZS50b0ZpeGVkKDApKTtcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQ6XG4gICAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcIlJlaW5oYXJkVG9uZU1hcHBpbmcodGV4ZWwpXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRvbmVNYXBwaW5nTW9kZS5PUFRJTUlaRURfQ0lORU9OOlxuICAgICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgXCJPcHRpbWl6ZWRDaW5lb25Ub25lTWFwcGluZyh0ZXhlbClcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLkFDRVNfRklMTUlDOlxuICAgICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgXCJBQ0VTRmlsbWljVG9uZU1hcHBpbmcodGV4ZWwpXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgXCJ0ZXhlbFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLmVuYWJsZWQgPSB2YWx1ZSA9PT0gVG9uZU1hcHBpbmdNb2RlLlJFSU5IQVJEMl9BREFQVElWRTtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VG9uZU1hcHBpbmdNb2RlfSBUaGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqL1xuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRvbmUgbWFwcGluZyBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RvbmVNYXBwaW5nTW9kZX0gdmFsdWUgLSBUaGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqL1xuICBzZXRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5tb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3aGl0ZSBwb2ludC4gRGVmYXVsdCBpcyBgNC4wYC5cbiAgICpcbiAgICogT25seSBhcHBsaWVzIHRvIFJlaW5oYXJkMiAoTW9kaWZpZWQgJiBBZGFwdGl2ZSkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd2hpdGVQb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ3aGl0ZVBvaW50XCIpLnZhbHVlO1xuICB9XG4gIHNldCB3aGl0ZVBvaW50KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJ3aGl0ZVBvaW50XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtaWRkbGUgZ3JleSBmYWN0b3IuIERlZmF1bHQgaXMgYDAuNmAuXG4gICAqXG4gICAqIE9ubHkgYXBwbGllcyB0byBSZWluaGFyZDIgKE1vZGlmaWVkICYgQWRhcHRpdmUpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pZGRsZUdyZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwibWlkZGxlR3JleVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbWlkZGxlR3JleSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWlkZGxlR3JleVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYXZlcmFnZSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIE9ubHkgYXBwbGllcyB0byBSZWluaGFyZDIgKE1vZGlmaWVkKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBhdmVyYWdlTHVtaW5hbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImF2ZXJhZ2VMdW1pbmFuY2VcIikudmFsdWU7XG4gIH1cbiAgc2V0IGF2ZXJhZ2VMdW1pbmFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImF2ZXJhZ2VMdW1pbmFuY2VcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFkYXB0aXZlIGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0FkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhZGFwdGl2ZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0FkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldEFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIGx1bWluYW5jZSB0ZXh0dXJlLiBNdXN0IGJlIGEgcG93ZXIgb2YgdHdvLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlUGFzcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgZXhwb25lbnQgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHZhbHVlKSkpO1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgdGhpcy5sdW1pbmFuY2VQYXNzLnJlc29sdXRpb24uc2V0UHJlZmVycmVkU2l6ZShzaXplLCBzaXplKTtcbiAgICB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwubWlwTGV2ZWwxeDEgPSBleHBvbmVudDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgbHVtaW5hbmNlIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24gb2YgdGhlIGx1bWluYW5jZSB0ZXh0dXJlLiBNdXN0IGJlIGEgcG93ZXIgb2YgdHdvLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIHNldFJlc29sdXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBwYXNzIHVzZXMgYWRhcHRpdmUgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhZGFwdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlID09PSBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyX0FEQVBUSVZFO1xuICB9XG4gIHNldCBhZGFwdGl2ZSh2YWx1ZSkge1xuICAgIHRoaXMubW9kZSA9IHZhbHVlID8gVG9uZU1hcHBpbmdNb2RlLlJFSU5IQVJEMl9BREFQVElWRSA6IFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFkYXB0YXRpb25SYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGU7XG4gIH1cbiAgc2V0IGFkYXB0YXRpb25SYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmFkYXB0YXRpb25SYXRlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGlzdGluY3Rpb24oKSB7XG4gICAgY29uc29sZS53YXJuKHRoaXMubmFtZSwgXCJkaXN0aW5jdGlvbiB3YXMgcmVtb3ZlZC5cIik7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgc2V0IGRpc3RpbmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKHRoaXMubmFtZSwgXCJkaXN0aW5jdGlvbiB3YXMgcmVtb3ZlZC5cIik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGlmICh0aGlzLmFkYXB0aXZlTHVtaW5hbmNlUGFzcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmx1bWluYW5jZVBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlcik7XG4gICAgICB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlUGFzcy5yZW5kZXIocmVuZGVyZXIsIG51bGwsIG51bGwsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvVmlnbmV0dGVFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTUwIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdmlnbmV0dGUuZnJhZ1xudmFyIHZpZ25ldHRlX2RlZmF1bHQgPSBcInVuaWZvcm0gZmxvYXQgb2Zmc2V0O3VuaWZvcm0gZmxvYXQgZGFya25lc3M7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2NvbnN0IHZlYzIgY2VudGVyPXZlYzIoMC41KTt2ZWMzIGNvbG9yPWlucHV0Q29sb3IucmdiO1xcbiNpZiBWSUdORVRURV9URUNITklRVUUgPT0gMFxcbmZsb2F0IGQ9ZGlzdGFuY2UodXYsY2VudGVyKTtjb2xvcio9c21vb3Roc3RlcCgwLjgsb2Zmc2V0KjAuNzk5LGQqKGRhcmtuZXNzK29mZnNldCkpO1xcbiNlbHNlXFxudmVjMiBjb29yZD0odXYtY2VudGVyKSp2ZWMyKG9mZnNldCk7Y29sb3I9bWl4KGNvbG9yLHZlYzMoMS4wLWRhcmtuZXNzKSxkb3QoY29vcmQsY29vcmQpKTtcXG4jZW5kaWZcXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9WaWduZXR0ZUVmZmVjdC5qc1xudmFyIFZpZ25ldHRlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBWaWduZXR0ZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtWaWduZXR0ZVRlY2huaXF1ZX0gW29wdGlvbnMudGVjaG5pcXVlPVZpZ25ldHRlVGVjaG5pcXVlLkRFRkFVTFRdIC0gVGhlIFZpZ25ldHRlIHRlY2huaXF1ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lc2tpbD1mYWxzZV0gLSBEZXByZWNhdGVkLiBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXQ9MC41XSAtIFRoZSBWaWduZXR0ZSBvZmZzZXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kYXJrbmVzcz0wLjVdIC0gVGhlIFZpZ25ldHRlIGRhcmtuZXNzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgdGVjaG5pcXVlID0gVmlnbmV0dGVUZWNobmlxdWUuREVGQVVMVCxcbiAgICBlc2tpbCA9IGZhbHNlLFxuICAgIG9mZnNldCA9IDAuNSxcbiAgICBkYXJrbmVzcyA9IDAuNVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIlZpZ25ldHRlRWZmZWN0XCIsIHZpZ25ldHRlX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIlZJR05FVFRFX1RFQ0hOSVFVRVwiLCB0ZWNobmlxdWUudG9GaXhlZCgwKV1cbiAgICAgIF0pLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wib2Zmc2V0XCIsIG5ldyBVbmlmb3JtNTAob2Zmc2V0KV0sXG4gICAgICAgIFtcImRhcmtuZXNzXCIsIG5ldyBVbmlmb3JtNTAoZGFya25lc3MpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIFZpZ25ldHRlIHRlY2huaXF1ZS5cbiAgICpcbiAgICogQHR5cGUge1ZpZ25ldHRlVGVjaG5pcXVlfVxuICAgKi9cbiAgZ2V0IHRlY2huaXF1ZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJWSUdORVRURV9URUNITklRVUVcIikpO1xuICB9XG4gIHNldCB0ZWNobmlxdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy50ZWNobmlxdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiVklHTkVUVEVfVEVDSE5JUVVFXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBFc2tpbCdzIFZpZ25ldHRlIHRlY2huaXF1ZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRlY2huaXF1ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGVza2lsKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2huaXF1ZSA9PT0gVmlnbmV0dGVUZWNobmlxdWUuRVNLSUw7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIEVza2lsJ3MgVmlnbmV0dGUgdGVjaG5pcXVlIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqL1xuICBzZXQgZXNraWwodmFsdWUpIHtcbiAgICB0aGlzLnRlY2huaXF1ZSA9IHZhbHVlID8gVmlnbmV0dGVUZWNobmlxdWUuRVNLSUwgOiBWaWduZXR0ZVRlY2huaXF1ZS5ERUZBVUxUO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWaWduZXR0ZSB0ZWNobmlxdWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZWNobmlxdWUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmlnbmV0dGVUZWNobmlxdWV9IFRoZSB0ZWNobmlxdWUuXG4gICAqL1xuICBnZXRUZWNobmlxdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaG5pcXVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBWaWduZXR0ZSB0ZWNobmlxdWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZWNobmlxdWUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWaWduZXR0ZVRlY2huaXF1ZX0gdmFsdWUgLSBUaGUgdGVjaG5pcXVlLlxuICAgKi9cbiAgc2V0VGVjaG5pcXVlKHZhbHVlKSB7XG4gICAgdGhpcy50ZWNobmlxdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIFZpZ25ldHRlIG9mZnNldC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwib2Zmc2V0XCIpLnZhbHVlO1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm9mZnNldFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWaWduZXR0ZSBvZmZzZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvZmZzZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgVmlnbmV0dGUgb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb2Zmc2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBvZmZzZXQuXG4gICAqL1xuICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgVmlnbmV0dGUgZGFya25lc3MuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGFya25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiZGFya25lc3NcIikudmFsdWU7XG4gIH1cbiAgc2V0IGRhcmtuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJkYXJrbmVzc1wiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWaWduZXR0ZSBkYXJrbmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRhcmtuZXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRhcmtuZXNzLlxuICAgKi9cbiAgZ2V0RGFya25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGFya25lc3M7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIFZpZ25ldHRlIGRhcmtuZXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGFya25lc3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGRhcmtuZXNzLlxuICAgKi9cbiAgc2V0RGFya25lc3ModmFsdWUpIHtcbiAgICB0aGlzLmRhcmtuZXNzID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2FkZXJzL0xVVDNkbExvYWRlci5qc1xuaW1wb3J0IHsgRmlsZUxvYWRlciwgTG9hZGVyLCBMb2FkaW5nTWFuYWdlciBhcyBMb2FkaW5nTWFuYWdlcjMgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBMVVQzZGxMb2FkZXIgPSBjbGFzcyBleHRlbmRzIExvYWRlciB7XG4gIC8qKlxuICAgKiBMb2FkcyBhIExVVC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIDNkbC1maWxlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Mb2FkXSAtIEEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgbG9hZGVkIGxvb2t1cCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Qcm9ncmVzc10gLSBBIHByb2dyZXNzIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIFhNTEh0dHBSZXF1ZXN0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBBbiBlcnJvciBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBVUkwgb2YgdGhlIGZpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxMb29rdXBUZXh0dXJlPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgbG9va3VwIHRleHR1cmUuXG4gICAqL1xuICBsb2FkKHVybCwgb25Mb2FkID0gKCkgPT4ge1xuICB9LCBvblByb2dyZXNzID0gKCkgPT4ge1xuICB9LCBvbkVycm9yID0gbnVsbCkge1xuICAgIGNvbnN0IGV4dGVybmFsTWFuYWdlciA9IHRoaXMubWFuYWdlcjtcbiAgICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIzKCk7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoaW50ZXJuYWxNYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJ0ZXh0XCIpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpbnRlcm5hbE1hbmFnZXIub25FcnJvciA9ICh1cmwyKSA9PiB7XG4gICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRXJyb3IodXJsMik7XG4gICAgICAgIGlmIChvbkVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgb25FcnJvcihgRmFpbGVkIHRvIGxvYWQgJHt1cmwyfWApO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoYEZhaWxlZCB0byBsb2FkICR7dXJsMn1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgKGRhdGEpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlKGRhdGEpO1xuICAgICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICBpbnRlcm5hbE1hbmFnZXIub25FcnJvcih1cmwpO1xuICAgICAgICB9XG4gICAgICB9LCBvblByb2dyZXNzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgLSBUaGUgTFVUIGRhdGEuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICogQHRocm93cyB7RXJyb3J9IEZhaWxzIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gICAqL1xuICBwYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHJlZ0V4cEdyaWRJbmZvID0gL15bXFxkIF0rJC9tO1xuICAgIGNvbnN0IHJlZ0V4cERhdGFQb2ludHMgPSAvXihbXFxkLmUrLV0rKSArKFtcXGQuZSstXSspICsoW1xcZC5lKy1dKykgKiQvZ207XG4gICAgbGV0IHJlc3VsdCA9IHJlZ0V4cEdyaWRJbmZvLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZ3JpZCBpbmZvcm1hdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgZ3JpZExpbmVzID0gcmVzdWx0WzBdLnRyaW0oKS5zcGxpdCgvXFxzKy9nKS5tYXAoKG4pID0+IE51bWJlcihuKSk7XG4gICAgY29uc3QgZ3JpZFN0ZXAgPSBncmlkTGluZXNbMV0gLSBncmlkTGluZXNbMF07XG4gICAgY29uc3Qgc2l6ZSA9IGdyaWRMaW5lcy5sZW5ndGg7XG4gICAgY29uc3Qgc2l6ZVNxID0gc2l6ZSAqKiAyO1xuICAgIGZvciAobGV0IGkgPSAxLCBsID0gZ3JpZExpbmVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgaWYgKGdyaWRTdGVwICE9PSBncmlkTGluZXNbaV0gLSBncmlkTGluZXNbaSAtIDFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29uc2lzdGVudCBncmlkIHNpemVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiogMyAqIDQpO1xuICAgIGxldCBtYXhWYWx1ZSA9IDA7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cERhdGFQb2ludHMuZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCByID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gICAgICBjb25zdCBnID0gTnVtYmVyKHJlc3VsdFsyXSk7XG4gICAgICBjb25zdCBiID0gTnVtYmVyKHJlc3VsdFszXSk7XG4gICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCByLCBnLCBiKTtcbiAgICAgIGNvbnN0IGJMYXllciA9IGluZGV4ICUgc2l6ZTtcbiAgICAgIGNvbnN0IGdMYXllciA9IE1hdGguZmxvb3IoaW5kZXggLyBzaXplKSAlIHNpemU7XG4gICAgICBjb25zdCByTGF5ZXIgPSBNYXRoLmZsb29yKGluZGV4IC8gc2l6ZVNxKSAlIHNpemU7XG4gICAgICBjb25zdCBkNCA9IChiTGF5ZXIgKiBzaXplU3EgKyBnTGF5ZXIgKiBzaXplICsgckxheWVyKSAqIDQ7XG4gICAgICBkYXRhW2Q0ICsgMF0gPSByO1xuICAgICAgZGF0YVtkNCArIDFdID0gZztcbiAgICAgIGRhdGFbZDQgKyAyXSA9IGI7XG4gICAgICBkYXRhW2Q0ICsgM10gPSAxO1xuICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgY29uc3QgYml0cyA9IE1hdGguY2VpbChNYXRoLmxvZzIobWF4VmFsdWUpKTtcbiAgICBjb25zdCBtYXhCaXRWYWx1ZSA9IE1hdGgucG93KDIsIGJpdHMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaSArIDBdIC89IG1heEJpdFZhbHVlO1xuICAgICAgZGF0YVtpICsgMV0gLz0gbWF4Qml0VmFsdWU7XG4gICAgICBkYXRhW2kgKyAyXSAvPSBtYXhCaXRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb29rdXBUZXh0dXJlKGRhdGEsIHNpemUpO1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVycy9MVVRDdWJlTG9hZGVyLmpzXG5pbXBvcnQgeyBGaWxlTG9hZGVyIGFzIEZpbGVMb2FkZXIyLCBMb2FkZXIgYXMgTG9hZGVyMiwgTG9hZGluZ01hbmFnZXIgYXMgTG9hZGluZ01hbmFnZXI0LCBWZWN0b3IzIGFzIFZlY3RvcjM3IH0gZnJvbSBcInRocmVlXCI7XG52YXIgTFVUQ3ViZUxvYWRlciA9IGNsYXNzIGV4dGVuZHMgTG9hZGVyMiB7XG4gIC8qKlxuICAgKiBMb2FkcyBhIExVVC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIENVQkUtZmlsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGxvYWRlZCBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQSBwcm9ncmVzcyBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBYTUxIdHRwUmVxdWVzdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gQW4gZXJyb3IgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgVVJMIG9mIHRoZSBmaWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TG9va3VwVGV4dHVyZT59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKi9cbiAgbG9hZCh1cmwsIG9uTG9hZCA9ICgpID0+IHtcbiAgfSwgb25Qcm9ncmVzcyA9ICgpID0+IHtcbiAgfSwgb25FcnJvciA9IG51bGwpIHtcbiAgICBjb25zdCBleHRlcm5hbE1hbmFnZXIgPSB0aGlzLm1hbmFnZXI7XG4gICAgY29uc3QgaW50ZXJuYWxNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyNCgpO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyMihpbnRlcm5hbE1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcInRleHRcIik7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGludGVybmFsTWFuYWdlci5vbkVycm9yID0gKHVybDIpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FcnJvcih1cmwyKTtcbiAgICAgICAgaWYgKG9uRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICBvbkVycm9yKGBGYWlsZWQgdG8gbG9hZCAke3VybDJ9YCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGxvYWQgJHt1cmwyfWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCAoZGF0YSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIGludGVybmFsTWFuYWdlci5vbkVycm9yKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH0sIG9uUHJvZ3Jlc3MpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAtIFRoZSBMVVQgZGF0YS5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gRmFpbHMgaWYgdGhlIGRhdGEgaXMgaW52YWxpZC5cbiAgICovXG4gIHBhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcmVnRXhwVGl0bGUgPSAvVElUTEUgK1wiKFteXCJdKilcIi87XG4gICAgY29uc3QgcmVnRXhwU2l6ZSA9IC9MVVRfM0RfU0laRSArKFxcZCspLztcbiAgICBjb25zdCByZWdFeHBEb21haW5NaW4gPSAvRE9NQUlOX01JTiArKFtcXGQuXSspICsoW1xcZC5dKykgKyhbXFxkLl0rKS87XG4gICAgY29uc3QgcmVnRXhwRG9tYWluTWF4ID0gL0RPTUFJTl9NQVggKyhbXFxkLl0rKSArKFtcXGQuXSspICsoW1xcZC5dKykvO1xuICAgIGNvbnN0IHJlZ0V4cERhdGFQb2ludHMgPSAvXihbXFxkLmUrLV0rKSArKFtcXGQuZSstXSspICsoW1xcZC5lKy1dKykgKiQvZ207XG4gICAgbGV0IHJlc3VsdCA9IHJlZ0V4cFRpdGxlLmV4ZWMoaW5wdXQpO1xuICAgIGNvbnN0IHRpdGxlID0gcmVzdWx0ICE9PSBudWxsID8gcmVzdWx0WzFdIDogbnVsbDtcbiAgICByZXN1bHQgPSByZWdFeHBTaXplLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgTFVUXzNEX1NJWkUgaW5mb3JtYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBOdW1iZXIocmVzdWx0WzFdKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICoqIDMgKiA0KTtcbiAgICBjb25zdCBkb21haW5NaW4gPSBuZXcgVmVjdG9yMzcoMCwgMCwgMCk7XG4gICAgY29uc3QgZG9tYWluTWF4ID0gbmV3IFZlY3RvcjM3KDEsIDEsIDEpO1xuICAgIHJlc3VsdCA9IHJlZ0V4cERvbWFpbk1pbi5leGVjKGlucHV0KTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICBkb21haW5NaW4uc2V0KE51bWJlcihyZXN1bHRbMV0pLCBOdW1iZXIocmVzdWx0WzJdKSwgTnVtYmVyKHJlc3VsdFszXSkpO1xuICAgIH1cbiAgICByZXN1bHQgPSByZWdFeHBEb21haW5NYXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgZG9tYWluTWF4LnNldChOdW1iZXIocmVzdWx0WzFdKSwgTnVtYmVyKHJlc3VsdFsyXSksIE51bWJlcihyZXN1bHRbM10pKTtcbiAgICB9XG4gICAgaWYgKGRvbWFpbk1pbi54ID4gZG9tYWluTWF4LnggfHwgZG9tYWluTWluLnkgPiBkb21haW5NYXgueSB8fCBkb21haW5NaW4ueiA+IGRvbWFpbk1heC56KSB7XG4gICAgICBkb21haW5NaW4uc2V0KDAsIDAsIDApO1xuICAgICAgZG9tYWluTWF4LnNldCgxLCAxLCAxKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZG9tYWluXCIpO1xuICAgIH1cbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBEYXRhUG9pbnRzLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgZGF0YVtpKytdID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gICAgICBkYXRhW2krK10gPSBOdW1iZXIocmVzdWx0WzJdKTtcbiAgICAgIGRhdGFbaSsrXSA9IE51bWJlcihyZXN1bHRbM10pO1xuICAgICAgZGF0YVtpKytdID0gMTtcbiAgICB9XG4gICAgY29uc3QgbHV0ID0gbmV3IExvb2t1cFRleHR1cmUoZGF0YSwgc2l6ZSk7XG4gICAgbHV0LmRvbWFpbk1pbi5jb3B5KGRvbWFpbk1pbik7XG4gICAgbHV0LmRvbWFpbk1heC5jb3B5KGRvbWFpbk1heCk7XG4gICAgaWYgKHRpdGxlICE9PSBudWxsKSB7XG4gICAgICBsdXQubmFtZSA9IHRpdGxlO1xuICAgIH1cbiAgICByZXR1cm4gbHV0O1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVycy9TTUFBSW1hZ2VMb2FkZXIuanNcbmltcG9ydCB7IExvYWRlciBhcyBMb2FkZXIzLCBMb2FkaW5nTWFuYWdlciBhcyBMb2FkaW5nTWFuYWdlcjUgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBTTUFBSW1hZ2VMb2FkZXIgPSBjbGFzcyBleHRlbmRzIExvYWRlcjMge1xuICAvKipcbiAgICogTG9hZHMgdGhlIFNNQUEgZGF0YSBpbWFnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkxvYWRdIC0gQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBzZWFyY2ggaW1hZ2UgYW5kIGFyZWEgaW1hZ2UgYXMgYSBwYWlyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBBbiBlcnJvciBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBVUkwgb2YgdGhlIGltYWdlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8SW1hZ2VbXT59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIHNlYXJjaCBpbWFnZSBhbmQgYXJlYSBpbWFnZSBhcyBhIHBhaXIuXG4gICAqL1xuICBsb2FkKG9uTG9hZCA9ICgpID0+IHtcbiAgfSwgb25FcnJvciA9IG51bGwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgb25Mb2FkID0gYXJndW1lbnRzWzFdO1xuICAgICAgb25FcnJvciA9IGFyZ3VtZW50c1szXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgfHwgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvbkxvYWQgPSBhcmd1bWVudHNbMV07XG4gICAgICBvbkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZXJuYWxNYW5hZ2VyID0gdGhpcy5tYW5hZ2VyO1xuICAgIGNvbnN0IGludGVybmFsTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcjUoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGNvbnN0IGFyZWFJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uRXJyb3IgPSAodXJsKSA9PiB7XG4gICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgaWYgKG9uRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICBvbkVycm9yKGBGYWlsZWQgdG8gbG9hZCAke3VybH1gKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGBGYWlsZWQgdG8gbG9hZCAke3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGludGVybmFsTWFuYWdlci5vbkxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtzZWFyY2hJbWFnZSwgYXJlYUltYWdlXTtcbiAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH07XG4gICAgICBzZWFyY2hJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1FcnJvcihcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgfSk7XG4gICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgIGludGVybmFsTWFuYWdlci5pdGVtRXJyb3IoXCJzbWFhLWFyZWFcIik7XG4gICAgICB9KTtcbiAgICAgIHNlYXJjaEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgIH0pO1xuICAgICAgYXJlYUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLWFyZWFcIik7XG4gICAgICAgIGludGVybmFsTWFuYWdlci5pdGVtRW5kKFwic21hYS1hcmVhXCIpO1xuICAgICAgfSk7XG4gICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1zZWFyY2hcIik7XG4gICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1hcmVhXCIpO1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtYXJlYVwiKTtcbiAgICAgIHNlYXJjaEltYWdlLnNyYyA9IHNlYXJjaEltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICAgICAgYXJlYUltYWdlLnNyYyA9IGFyZWFJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgICB9KTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwsXG4gIEFkYXB0aXZlTHVtaW5hbmNlUGFzcyxcbiAgQmxlbmRGdW5jdGlvbixcbiAgQmxlbmRNb2RlLFxuICBCbG9vbUVmZmVjdCxcbiAgS2F3YXNlQmx1clBhc3MgYXMgQmx1clBhc3MsXG4gIEJva2VoRWZmZWN0LFxuICBCb2tlaE1hdGVyaWFsLFxuICBCb3hCbHVyTWF0ZXJpYWwsXG4gIEJveEJsdXJQYXNzLFxuICBCcmlnaHRuZXNzQ29udHJhc3RFZmZlY3QsXG4gIENocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QsXG4gIENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwsXG4gIENsZWFyTWFza1Bhc3MsXG4gIENsZWFyUGFzcyxcbiAgQ29sb3JBdmVyYWdlRWZmZWN0LFxuICBDb2xvckNoYW5uZWwsXG4gIENvbG9yRGVwdGhFZmZlY3QsXG4gIEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCBhcyBDb2xvckVkZ2VzTWF0ZXJpYWwsXG4gIEthd2FzZUJsdXJNYXRlcmlhbCBhcyBDb252b2x1dGlvbk1hdGVyaWFsLFxuICBDb3B5TWF0ZXJpYWwsXG4gIENvcHlQYXNzLFxuICBEZXB0aENvbXBhcmlzb25NYXRlcmlhbCxcbiAgRGVwdGhDb3B5TWF0ZXJpYWwsXG4gIERlcHRoQ29weU1vZGUsXG4gIERlcHRoQ29weVBhc3MsXG4gIERlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWwsXG4gIERlcHRoRG93bnNhbXBsaW5nUGFzcyxcbiAgRGVwdGhFZmZlY3QsXG4gIERlcHRoTWFza01hdGVyaWFsLFxuICBEZXB0aE9mRmllbGRFZmZlY3QsXG4gIERlcHRoUGFzcyxcbiAgRGVwdGhQaWNraW5nUGFzcyxcbiAgRGVwdGhDb3B5UGFzcyBhcyBEZXB0aFNhdmVQYXNzLFxuICBEZXB0aFRlc3RTdHJhdGVneSxcbiAgRGlzcGxheVAzQ29sb3JTcGFjZSxcbiAgRGlzcG9zYWJsZSxcbiAgRG90U2NyZWVuRWZmZWN0LFxuICBEb3duc2FtcGxpbmdNYXRlcmlhbCxcbiAgRWRnZURldGVjdGlvbk1hdGVyaWFsLFxuICBFZGdlRGV0ZWN0aW9uTW9kZSxcbiAgRWZmZWN0LFxuICBFZmZlY3RBdHRyaWJ1dGUsXG4gIEVmZmVjdENvbXBvc2VyLFxuICBFZmZlY3RNYXRlcmlhbCxcbiAgRWZmZWN0UGFzcyxcbiAgRWZmZWN0U2hhZGVyRGF0YSxcbiAgRWZmZWN0U2hhZGVyU2VjdGlvbixcbiAgRlhBQUVmZmVjdCxcbiAgR2FtbWFDb3JyZWN0aW9uRWZmZWN0LFxuICBHYXVzc0tlcm5lbCxcbiAgR2F1c3NpYW5CbHVyTWF0ZXJpYWwsXG4gIEdhdXNzaWFuQmx1clBhc3MsXG4gIEdsaXRjaEVmZmVjdCxcbiAgR2xpdGNoTW9kZSxcbiAgR29kUmF5c0VmZmVjdCxcbiAgR29kUmF5c01hdGVyaWFsLFxuICBHcmlkRWZmZWN0LFxuICBIdWVTYXR1cmF0aW9uRWZmZWN0LFxuICBJbW11dGFibGVUaW1lcixcbiAgSW5pdGlhbGl6YWJsZSxcbiAgS2F3YXNlQmx1ck1hdGVyaWFsLFxuICBLYXdhc2VCbHVyUGFzcyxcbiAgS2VybmVsU2l6ZSxcbiAgTFVUMURFZmZlY3QsXG4gIExVVDNERWZmZWN0LFxuICBMVVQzZGxMb2FkZXIsXG4gIExVVEN1YmVMb2FkZXIsXG4gIExVVDNERWZmZWN0IGFzIExVVEVmZmVjdCxcbiAgTFVUT3BlcmF0aW9uLFxuICBMYW1iZGFQYXNzLFxuICBMZW5zRGlzdG9ydGlvbkVmZmVjdCxcbiAgTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gIExvb2t1cFRleHR1cmUsXG4gIExvb2t1cFRleHR1cmUgYXMgTG9va3VwVGV4dHVyZTNELFxuICBMdW1pbmFuY2VNYXRlcmlhbCxcbiAgTHVtaW5hbmNlUGFzcyxcbiAgTWFza0Z1bmN0aW9uLFxuICBNYXNrTWF0ZXJpYWwsXG4gIE1hc2tQYXNzLFxuICBNaXBtYXBCbHVyUGFzcyxcbiAgTm9Db2xvclNwYWNlLFxuICBOb2lzZUVmZmVjdCxcbiAgTm9pc2VUZXh0dXJlLFxuICBOb3JtYWxQYXNzLFxuICBPdXRsaW5lTWF0ZXJpYWwgYXMgT3V0bGluZUVkZ2VzTWF0ZXJpYWwsXG4gIE91dGxpbmVFZmZlY3QsXG4gIE91dGxpbmVNYXRlcmlhbCxcbiAgT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIsXG4gIFBhc3MsXG4gIFBpeGVsYXRpb25FZmZlY3QsXG4gIFByZWRpY2F0aW9uTW9kZSxcbiAgUmF3SW1hZ2VEYXRhLFxuICBSZWFsaXN0aWNCb2tlaEVmZmVjdCxcbiAgUmVuZGVyUGFzcyxcbiAgUmVzaXphYmxlLFxuICBSZXNvbHV0aW9uIGFzIFJlc2l6ZXIsXG4gIFJlc29sdXRpb24sXG4gIFNNQUFBcmVhSW1hZ2VEYXRhLFxuICBTTUFBRWZmZWN0LFxuICBTTUFBSW1hZ2VHZW5lcmF0b3IsXG4gIFNNQUFJbWFnZUxvYWRlcixcbiAgU01BQVByZXNldCxcbiAgU01BQVNlYXJjaEltYWdlRGF0YSxcbiAgU01BQVdlaWdodHNNYXRlcmlhbCxcbiAgU1JHQkNvbG9yU3BhY2UsXG4gIFNTQU9FZmZlY3QsXG4gIFNTQU9NYXRlcmlhbCxcbiAgQ29weVBhc3MgYXMgU2F2ZVBhc3MsXG4gIFNjYW5saW5lRWZmZWN0LFxuICBFZmZlY3RTaGFkZXJTZWN0aW9uIGFzIFNlY3Rpb24sXG4gIFNlbGVjdGlvbixcbiAgU2VsZWN0aXZlQmxvb21FZmZlY3QsXG4gIFNlcGlhRWZmZWN0LFxuICBTaGFkZXJQYXNzLFxuICBTaG9ja1dhdmVFZmZlY3QsXG4gIFRldHJhaGVkcmFsVXBzY2FsZXIsXG4gIFRleHR1cmVFZmZlY3QsXG4gIFRpbHRTaGlmdEJsdXJNYXRlcmlhbCxcbiAgVGlsdFNoaWZ0Qmx1clBhc3MsXG4gIFRpbHRTaGlmdEVmZmVjdCxcbiAgVGltZXIsXG4gIFRvbmVNYXBwaW5nRWZmZWN0LFxuICBUb25lTWFwcGluZ01vZGUsXG4gIFVwc2FtcGxpbmdNYXRlcmlhbCxcbiAgVmlnbmV0dGVFZmZlY3QsXG4gIFZpZ25ldHRlVGVjaG5pcXVlLFxuICBXZWJHTEV4dGVuc2lvbixcbiAgdmVyc2lvblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postprocessing/build/index.js\n"));

/***/ })

});